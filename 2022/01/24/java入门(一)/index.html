<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java入门（一） | 木雁之间的博客</title><meta name="keywords" content="教程,java"><meta name="author" content="木雁之间"><meta name="copyright" content="木雁之间"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java基础教程一，关于java程序基础，面向对象编程，异常处理，反射，注解，泛型，集合，IO，日期与时间，单元测试，正则表达式，加密与安全和多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="java入门（一）">
<meta property="og:url" content="https://winfredliu.github.io/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/index.html">
<meta property="og:site_name" content="木雁之间的博客">
<meta property="og:description" content="java基础教程一，关于java程序基础，面向对象编程，异常处理，反射，注解，泛型，集合，IO，日期与时间，单元测试，正则表达式，加密与安全和多线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://winfredliu.github.io/img/cover5.jpg">
<meta property="article:published_time" content="2022-01-24T11:50:59.940Z">
<meta property="article:modified_time" content="2022-03-18T12:23:50.218Z">
<meta property="article:author" content="木雁之间">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://winfredliu.github.io/img/cover5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://winfredliu.github.io/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="GYl5vuHFiVm14ACBFzavbBv2K8jmuv2jVUbTA5oOHXE"/><meta name="baidu-site-verification" content="code-7fah9bWOCA"/><meta name="msvalidate.01" content="353E6B4F3B3181C0DF59987FEB5CC4EB"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ed41968fc5a98eec0bd6db0949b7ef93";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-217798011-2"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-217798011-2');
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "aaqriq29pg");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: 木雁之间","link":"链接: ","source":"来源: 木雁之间的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java入门（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-18 04:23:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw far fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw far fa-sticky-note"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木雁之间的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw far fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw far fa-sticky-note"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java入门（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-24T11:50:59.940Z" title="发表于 2022-01-24 03:50:59">2022-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-18T12:23:50.218Z" title="更新于 2022-03-18 04:23:50">2022-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">122.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>473分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java入门（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Java快速入门</h1>
<h2 id="java基本概念">java基本概念</h2>
<p>javaEE,javaSE</p>
<p>JDK,JRE</p>
<p>那JSR、JCP……又是啥？</p>
<p>JSR规范：Java Specification Request</p>
<p>JCP组织：Java Community Process</p>
<p>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</p>
<h2 id="Java程序基础">Java程序基础</h2>
<h3 id="Java程序基本结构">Java程序基本结构</h3>
<h3 id="变量和数据类型">变量和数据类型</h3>
<p>基本数据类型</p>
<p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
<p>int和float需要四个字节<br>
char需要两个字节</p>
<h4 id="var关键字">var关键字</h4>
<p>如果想省略变量类型，可以使用var关键字</p>
<h3 id="整数运算">整数运算</h3>
<p>在Java的计算表达式中，运算优先级从高到低依次是：</p>
<ul>
<li>()</li>
<li>! ~ ++ –</li>
<li>
<ul>
<li>/ %</li>
</ul>
</li>
<li></li>
<li>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</li>
<li>&amp;</li>
<li>|</li>
<li>+= -= *= /=</li>
</ul>
<p>位运算</p>
<h4 id="类型自动提升与强制转型">类型自动提升与强制转型</h4>
<p>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int</p>
<h3 id="浮点数运算">浮点数运算</h3>
<p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>
<p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型</p>
<p>整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：</p>
<p>NaN表示Not a Number<br>
Infinity表示无穷大<br>
-Infinity表示负无穷大</p>
<p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。</p>
<h3 id="布尔运算">布尔运算</h3>
<p>关系运算符的优先级从高到低依次是：</p>
<ul>
<li>!</li>
<li>
<blockquote>
<p>，&gt;=，&lt;，&lt;=</p>
</blockquote>
</li>
<li>==，!=</li>
<li>&amp;&amp;</li>
<li>||</li>
</ul>
<p>注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一</p>
<h3 id="字符和字符串">字符和字符串</h3>
<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可：</p>
<p>因为字符串使用双引号&quot;…&quot;表示开始和结束，那如果字符串本身恰好包含一个&quot;字符怎么表示？例如，“abc&quot;xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\：</p>
<blockquote>
<p>String s = “abc&quot;xyz”; // 包含7个字符: a, b, c, &quot;, x, y, z</p>
</blockquote>
<p>因为\是转义字符，所以，两个\表示一个\字符</p>
<p>&quot; 表示字符&quot;<br>
’ 表示字符’<br>
\ 表示字符<br>
\n 表示换行符<br>
\r 表示回车符<br>
\t 表示Tab</p>
<p>\u#### 表示一个Unicode编码的字符</p>
<p>如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接</p>
<p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 hello</span></span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空值">空值</h4>
<p>引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">null</span>; <span class="comment">// s1是null</span></span><br><span class="line">String s2; <span class="comment">// 没有赋初值值，s2也是null</span></span><br><span class="line">String s3 = s1; <span class="comment">// s3也是null</span></span><br><span class="line">String s4 = <span class="string">&quot;&quot;</span>; <span class="comment">// s4指向空字符串，不是null</span></span><br></pre></td></tr></table></figure>
<h3 id="数组类型">数组类型</h3>
<h2 id="流程控制">流程控制</h2>
<h3 id="输入和输出">输入和输出</h3>
<h4 id="输出">输出</h4>
<p>在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。</p>
<p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()</p>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式</p>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<p>占位符	说明<br>
%d	格式化输出整数<br>
%x	格式化输出十六进制整数<br>
%f	格式化输出浮点数<br>
%e	格式化输出科学计数法表示的浮点数<br>
%s	格式化字符串</p>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p>
<h4 id="输入">输入</h4>
<p>我们先看一个从控制台读取一个字符串和一个整数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if判断">if判断</h3>
<p>在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false：</p>
<p>要判断引用类型的变量内容是否相等，必须使用equals()方法：</p>
<h3 id="switch多重选择">switch多重选择</h3>
<p>使用 <code>switch</code>时，注意 <code>case</code>语句并没有花括号 <code>&#123;&#125;</code>，而且，<code>case</code>语句具有“穿透性”，漏写 <code>break</code>将导致意想不到的结果</p>
<p>使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应</p>
<h4 id="yield-2">yield</h4>
<p>大多数时候，在switch表达式内部，我们会返回简单的值。</p>
<p>但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环">while循环</h3>
<h3 id="do-while循环">do while循环</h3>
<h3 id="for循环">for循环</h3>
<p>很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种for each循环，它可以更简单地遍历数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="break和continue">break和continue</h3>
<p>break语句可以跳出当前循环；</p>
<p>break语句通常配合if，在满足条件时提前结束整个循环；</p>
<p>break语句总是跳出最近的一层循环；</p>
<p>continue语句可以提前结束本次循环；</p>
<p>continue语句通常配合if，在满足条件时提前结束本次循环</p>
<h2 id="数组操作">数组操作</h2>
<h3 id="遍历数组">遍历数组</h3>
<p>使用for each循环打印也很麻烦。幸好Java标准库提供了 <code>Arrays.toString()</code>，可以快速打印数组内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组排序">数组排序</h3>
<p>一些排序算法</p>
<p>Java的标准库已经内置了排序功能，我们只需要调用JDK提供的 <code>Arrays.sort()</code>(升序)就可以排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须注意，对数组排序实际上修改了数组本身</p>
<h3 id="二维数组">二维数组</h3>
<p>ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下：<br>
┌───┬───┬───┬───┐<br>
┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │<br>
ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘<br>
├───┤      ┌───┬───┬───┬───┐<br>
│░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │<br>
├───┤      └───┴───┴───┴───┘<br>
│░░░│──┐   ┌───┬───┬───┬───┐<br>
└───┘  └──&gt;│ 9 │10 │11 │12 │<br>
└───┴───┴───┴───┘</p>
<p>要打印一个二维数组,可以使用Java标准库的Arrays.deepToString()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="命令行参数">命令行参数</h3>
<p>Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。</p>
<p>这个命令行参数由JVM接收用户输入并传给main方法</p>
<p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号</p>
<h1>面向对象编程</h1>
<p>面向对象的三个基本特征：封装、继承、多态</p>
<h2 id="面向对象基础">面向对象基础</h2>
<p>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p>
<h3 id="方法">方法</h3>
<p>一个 <code>class</code>可以包含多个 <code>field</code>，例如，我们给 <code>Person</code>类就定义了两个 <code>field</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，直接把 <code>field</code>用 <code>public</code>暴露给外部可能会破坏封装性。</p>
<p>显然，直接操作 <code>field</code>，容易造成逻辑混乱。为了避免外部代码直接去访问 <code>field</code>，我们可以用 <code>private</code>修饰 <code>field</code>，拒绝外部访问.</p>
<p>把field从public改成private，外部代码不能访问这些field,那怎么才能给它赋值？怎么才能读取它的值？</p>
<p>所以我们需要使用 <code>方法（method）</code>来让外部代码可以间接修改 <code>field</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">        ming.setName(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 设置name</span></span><br><span class="line">        ming.setAge(<span class="number">12</span>); <span class="comment">// 设置age</span></span><br><span class="line">        System.out.println(ming.getName() + <span class="string">&quot;, &quot;</span> + ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid age value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然外部代码不能直接修改 <code>private</code>字段，但是，外部代码可以调用方法 <code>setName()</code>和 <code>setAge()</code>来间接修改 <code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错</p>
<p>调用方法的语法是 <code>实例变量.方法名(参数)</code>;。一个方法调用就是一个语句，所以不要忘了在末尾加 <code>;</code>。</p>
<p>方法返回值通过 <code>return</code>语句实现，如果没有返回值，返回类型设置为 <code>void</code>，可以省略 <code>return</code></p>
<h4 id="private方法">private方法</h4>
<p>有 <code>public</code>方法，自然就有 <code>private</code>方法。和 <code>private</code>字段一样，<code>private</code>方法不允许外部调用，那我们定义 <code>private</code>方法有什么用？</p>
<p>定义 <code>private</code>方法的理由是内部方法是可以调用 <code>private</code>方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(<span class="keyword">int</span> birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcAge</span><span class="params">(<span class="keyword">int</span> currentYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>Person</code>类只定义了 <code>birth</code>字段，没有定义 <code>age</code>字段，获取 <code>age</code>时，通过方法 <code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心 <code>Person</code>实例在内部到底有没有 <code>age</code>字段。</p>
<h4 id="this变量">this变量</h4>
<p>在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。</p>
<p>如果没有命名冲突，可以省略this。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方</p>
<h3 id="构造方法">构造方法</h3>
<p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句</p>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</p>
<p>也可以对字段直接进行初始化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<ol>
<li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为 <code>10</code>，<code>double salary;</code>表示字段默认初始化为 <code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为 <code>null</code>；</li>
<li>执行构造方法的代码进行初始化。</li>
</ol>
<p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定</p>
<h4 id="多构造方法">多构造方法</h4>
<p>可以定义多个构造方法，在通过 <code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用 <code>new Person(&quot;Xiao Ming&quot;, 20);</code>，会自动匹配到构造方法 <code>public Person(String, int)</code>。</p>
<p>如果调用 <code>new Person(&quot;Xiao Ming&quot;);</code>，会自动匹配到构造方法 <code>public Person(String)</code>。</p>
<p>如果调用 <code>new Person()</code>;，会自动匹配到构造方法 <code>public Person()</code>。</p>
<p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是 <code>this(…)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法重载">方法重载</h3>
<p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。</p>
<p>这种方法名相同，但各自的参数不同，称为方法重载（Overload）。</p>
<p>注意：方法重载的返回值类型通常都是相同的。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<p>举个例子，String类提供了多个重载方法indexOf()，可以查找子串：</p>
<ul>
<li>int indexOf(int ch)：根据字符的Unicode码查找；</li>
<li>int indexOf(String str)：根据字符串查找；</li>
<li>int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置；</li>
<li>int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。</li>
</ul>
<h3 id="继承">继承</h3>
<p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让 <code>Student</code>从 <code>Person</code>继承时，<code>Student</code>就获得了 <code>Person</code>的所有功能，我们只需要为 <code>Student</code>编写新增的功能。</p>
<p>Java使用 <code>extends</code>关键字来实现继承</p>
<p>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p>
<p>在OOP的术语中，我们把 <code>Person</code>称为超类（super class），父类（parent class），基类（base class），把 <code>Student</code>称为子类（subclass），扩展类（extended class）</p>
<p>注意到我们在定义 <code>Person</code>的时候，没有写 <code>extends</code>。在Java中，没有明确写 <code>extends</code>的类，编译器会自动加上 <code>extends Object</code>。所以，任何类，除了 <code>Object</code>，都会继承自某个类。</p>
<p>下图是Person、Student的继承树：</p>
<p>┌───────────┐<br>
│  Object   │<br>
└───────────┘<br>
▲<br>
│<br>
┌───────────┐<br>
│  Person   │<br>
└───────────┘<br>
▲<br>
│<br>
┌───────────┐<br>
│  Student  │<br>
└───────────┘<br>
Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有 <code>Object</code>特殊，它没有父类。</p>
<h4 id="protected">protected</h4>
<p>继承有个特点，就是子类无法访问父类的private字段或者private方法。</p>
<p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为 <code>protected</code>。用 <code>protected</code>修饰的字段可以被子类访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问.</p>
<h4 id="super">super</h4>
<p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用 <code>super.fieldName</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="keyword">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这里使用 <code>super.name</code>，或者 <code>this.name</code>，或者 <code>name</code>，效果都是一样的。编译器会自动定位到父类的 <code>name</code>字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。</p>
<p>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句 <code>super()</code>;，所以，Student类的构造方法实际上是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，Person类并没有无参数的构造方法，因此，编译失败。</p>
<p>解决方法是调用Person类存在的某个构造方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<p>这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>
<h4 id="阻止继承">阻止继承</h4>
<p>正常情况下，只要某个class没有 <code>final</code>修饰符，那么任何类都可以从该class继承。</p>
<p>从 <code>Java 15</code>开始，允许使用 <code>sealed</code>修饰class，并通过 <code>permits</code>明确写出能够从该class继承的子类名称。</p>
<p>例如，定义一个 <code>Shape</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="title">permits</span> <span class="title">Rect</span>, <span class="title">Circle</span>, <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Shape类就是一个sealed类，它只允许指定的3个类继承它。</p>
<p><code>sealed</code>类在 <code>Java 15</code>中目前是预览状态，要启用它，必须使用参数 <code>--enable-preview</code>和 <code>--source 15</code>。</p>
<h4 id="向上转型">向上转型</h4>
<p>如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例</p>
<blockquote>
<p>Student s = new Student();</p>
</blockquote>
<p>如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例：</p>
<blockquote>
<p>Person p = new Person();</p>
</blockquote>
<p>现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？</p>
<blockquote>
<p>Person p = new Student(); // ???</p>
</blockquote>
<p>测试一下就可以发现，这种指向是允许的！</p>
<p>这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！</p>
<p>这种把一个子类类型安全地变为父类类型的赋值，被称为 <code>向上转型（upcasting）</code>。</p>
<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
<p>注意到继承树是 <code>Student &gt; Person &gt; Object</code>，所以，可以把 <code>Student</code>类型转型为 <code>Person</code>，或者更高层次的 <code>Object</code></p>
<h4 id="向下转型">向下转型</h4>
<p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是 <code>向下转型（downcasting）</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Student(); <span class="comment">// upcasting, ok</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Student s1 = (Student) p1; <span class="comment">// ok</span></span><br><span class="line">Student s2 = (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>
<p>如果测试上面的代码，可以发现：</p>
<p><code>Person</code>类型 <code>p1</code>实际指向 <code>Student</code>实例，<code>Person</code>类型变量 <code>p2</code>实际指向 <code>Person</code>实例。在向下转型的时候，把 <code>p1</code>转型为 <code>Student</code>会成功，因为 <code>p1</code>确实指向 <code>Student</code>实例，把 <code>p2</code>转型为 <code>Student</code>会失败，因为 <code>p2</code>的实际类型是 <code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p>
<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报 <code>ClassCastException</code>。</p>
<p>为了避免向下转型出错，Java提供了 <code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为 <code>null</code>，那么对任何 <code>instanceof</code>的判断都为 <code>false</code>。</p>
<h4 id="区分继承和组合">区分继承和组合</h4>
<p>在使用继承时，我们要注意逻辑一致性。</p>
<p>考察下面的Book类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。</p>
<p>究其原因，是因为 <code>Student</code>是 <code>Person</code>的一种，它们是 <code>is</code>关系，而 <code>Student</code>并不是 <code>Book</code>。实际上 <code>Student</code>和 <code>Book</code>的关系是 <code>has</code>关系。</p>
<p>具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，继承是is关系，组合是has关系。</p>
<h3 id="多态">多态</h3>
<p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为 <code>覆写（Override）</code>。</p>
<p>例如，在Person类中，我们定义了 <code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类Student中，覆写这个 <code>run()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Student.run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Override</code>和 <code>Overload</code>不同的是，如果方法参数不同，就是 <code>Overload</code>，<code>Overload</code>方法是一个新方法；如果方法参数相同，并且返回值也相同，就是 <code>Override</code>。</p>
<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
<p>加上 <code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p>
<p>但是 <code>@Override</code>不是必需的。</p>
<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<p>这个非常重要的特性在面向对象编程中称之为 <code>多态</code>。它的英文拼写非常复杂：<code>Polymorphic</code>。</p>
<h4 id="多态-2">多态</h4>
<p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure>
<p>有童鞋会问，从上面的代码一看就明白，肯定调用的是 <code>Student</code>的 <code>run()</code>方法啊。</p>
<p>但是，假设我们编写这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。</p>
<p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>
<p>我们还是来举栗子。</p>
<p>假设我们定义一种收入，需要给它报税，那么先定义一个Income类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">        total = total + income.getTax();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 <code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和 <code>Income</code>打交道，它完全不需要知道 <code>Salary</code>和 <code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从 <code>Income</code>派生，然后正确覆写 <code>getTax()</code>方法就可以。把新的类型传入 <code>totalTax()</code>，不需要修改任何代码。</p>
<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>
<h4 id="覆写Object方法">覆写Object方法</h4>
<p>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为String；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。<br>
在必要的情况下，我们可以覆写Object的这几个方法。</li>
</ul>
<h4 id="调用super">调用super</h4>
<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过 <code>super</code>来调用。</p>
<h4 id="final">final</h4>
<p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 <code>final</code>。用 <code>final</code>修饰的方法不能被 <code>Override</code></p>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为 <code>final</code>。用 <code>final</code>修饰的类不能被继承</p>
<h3 id="抽象类">抽象类</h3>
<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把一个方法声明为 <code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译 <code>Person</code>类，因为它包含抽象方法。</p>
<p>必须把 <code>Person</code>类本身也声明为 <code>abstract</code>，才能正确编译它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：</p>
<blockquote>
<p>Person p = new Person(); // 编译错误</p>
</blockquote>
<p>抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
<p>例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法</p>
<p>当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person s = <span class="keyword">new</span> Student();</span><br><span class="line">Person t = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure>
<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line">Person e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure>
<p>尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：abstract class Person）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>
<h3 id="接口">接口</h3>
<p>在Java中，使用 <code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓 <code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 <code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。<br>
当一个具体的 <code>class</code>去实现一个 <code>interface</code>时，需要使用 <code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个 <code>interface</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的接口特指 <code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class     	interface</span><br></pre></td></tr></table></figure>
<p>继承	     只能extends一个class	可以implements多个interface<br>
字段	     可以定义实例字段	     不能定义实例字段<br>
抽象方法	 可以定义抽象方法	     可以定义抽象方法<br>
非抽象方法	 可以定义非抽象方法	     可以定义default方法</p>
<h4 id="接口继承">接口继承</h4>
<p>一个 <code>interface</code>可以继承自另一个 <code>interface</code>。<code>interface</code>继承自 <code>interface</code>使用 <code>extends</code>，它相当于扩展了接口的方法。</p>
<h4 id="default方法">default方法</h4>
<p>在接口中，可以定义 <code>default</code>方法。例如，把 <code>Person</code>接口的 <code>run()</code>方法改为 <code>default</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类可以不必覆写 <code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是 <code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为 <code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h3 id="静态字段和静态方法">静态字段和静态方法</h3>
<p>在一个 <code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
<p>还有一种字段，是用 <code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>
<p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 定义静态字段number:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        Person hong = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        ming.number = <span class="number">88</span>;</span><br><span class="line">        System.out.println(hong.number);  <span class="comment">//  88</span></span><br><span class="line">        hong.number = <span class="number">99</span>;</span><br><span class="line">        System.out.println(ming.number);  <span class="comment">//  99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：<br>
┌──────────────────┐<br>
ming ──&gt;│Person instance   │<br>
├──────────────────┤<br>
│name = &quot;Xiao Ming&quot;│<br>
│age = 12          │<br>
│number ───────────┼──┐    ┌─────────────┐<br>
└──────────────────┘  │    │Person class │<br>
│    ├─────────────┤<br>
├───&gt;│number = 99  │<br>
┌──────────────────┐  │    └─────────────┘<br>
hong ──&gt;│Person instance   │  │<br>
├──────────────────┤  │<br>
│name = &quot;Xiao Hong&quot;│  │<br>
│age = 15          │  │<br>
│number ───────────┼──┘<br>
└──────────────────┘<br>
虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。</p>
<p>因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。</p>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）</p>
<h4 id="静态方法">静态方法</h4>
<p>有静态字段，就有静态方法。用static修饰的方法称为静态方法。</p>
<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。<br>
因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p>
<p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。<br>
静态方法经常用于工具类。例如：</p>
<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
<p>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</p>
<h4 id="抽象的静态字段">抽象的静态字段</h4>
<p>因为 <code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为 <code>final</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，因为 <code>interface</code>的字段只能是 <code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会自动把该字段变为 <code>public static final</code>类型。</p>
<h3 id="包">包</h3>
<h4 id="包作用域">包作用域</h4>
<p>位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域</p>
<h3 id="作用域">作用域</h3>
<h4 id="final-2">final</h4>
<p>Java还提供了一个 <code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p>
<p>用 <code>final</code>修饰 <code>class</code>可以阻止被继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法被继承:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>final</code>修饰 <code>method</code>可以阻止被子类覆写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无法被覆写:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>final</code>修饰 <code>field</code>可以阻止被重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>final</code>修饰局部变量可以阻止被重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。</p>
<p>把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。</p>
<p>一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。</p>
<h3 id="内部类">内部类</h3>
<h4 id="Inner-Class">Inner Class</h4>
<p>如果一个类定义在另一个类的内部，这个类就是 <code>Inner Class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Inner Class</code>的实例不能单独存在，必须依附于一个 <code>Outer Class</code>的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，要实例化一个 <code>Inner</code>，我们必须首先创建一个 <code>Outer</code>的实例，然后，调用 <code>Outer</code>实例的 <code>new</code>来创建 <code>Inner</code>实例：</p>
<blockquote>
<p>Outer.Inner inner = outer.new Inner();</p>
</blockquote>
<p>这是因为Inner Class除了有一个 <code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用 <code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p>
<p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的 <code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的 <code>private</code>字段和方法。</p>
<p>观察Java编译器编译后的 <code>.class</code>文件可以发现，<code>Outer</code>类被编译为 <code>Outer.class</code>，而 <code>Inner</code>类被编译为 <code>Outer$Inner.class</code>。</p>
<h4 id="Anonymous-Class-匿名类">Anonymous Class(匿名类)</h4>
<p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asyncHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 <code>asyncHello()</code>方法，我们在方法内部实例化了一个 <code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了 <code>Runnable</code>接口的匿名类，并且通过 <code>new</code>实例化该匿名类，然后转型为 <code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>匿名类和 <code>Inner Class</code>一样，可以访问 <code>Outer Class</code>的 <code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义 <code>Inner Class</code>可以少写很多代码。</p>
<p>观察Java编译器编译后的 <code>.class</code>文件可以发现，<code>Outer</code>类被编译为 <code>Outer.class</code>，而匿名类被编译为 <code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为 <code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p>
<p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码<br>
：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map1</code>是一个普通的 <code>HashMap</code>实例，但 <code>map2</code>是一个匿名类实例，只是该匿名类继承自 <code>HashMap</code>。<code>map3</code>也是一个继承自 <code>HashMap</code>的匿名类实例，并且添加了 <code>static</code>代码块来初始化数据。观察编译输出可发现 <code>Main$1.class</code>和 <code>Main$2.class</code>两个匿名类文件。</p>
<h4 id="Static-Nested-Class">Static Nested Class</h4>
<p>最后一种内部类和 <code>Inner Clas</code>s类似，但是使用 <code>static</code>修饰，称为静态内部类（Static Nested Class）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.StaticNested sn = <span class="keyword">new</span> Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>static</code>修饰的内部类和 <code>Inner Class</code>有很大的不同，它不再依附于 <code>Outer</code>的实例，而是一个完全独立的类，因此无法引用 <code>Outer.this</code>，但它可以访问 <code>Outer</code>的 <code>private</code>静态字段和静态方法。如果把 <code>StaticNested</code>移到 <code>Outer</code>之外，就失去了访问 <code>private</code>的权限。</p>
<h3 id="classpath和jar">classpath和jar</h3>
<h4 id="classpath">classpath</h4>
<p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索 <code>class</code>。</p>
<p>因为Java是编译型语言，源码文件是 <code>.java</code>，而编译后的 <code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个 <code>abc.xyz.Hello</code>的类，应该去哪搜索对应的 <code>Hello.class</code>文件。</p>
<p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用 <code>;</code>分隔，带空格的目录用 <code>&quot;&quot;</code>括起来，可能长这样：</p>
<blockquote>
<p>C:\work\project1\bin;C:\shared;“D:\My Documents\project1\bin”</p>
</blockquote>
<p>在Linux系统上，用 <code>:</code>分隔，可能长这样：</p>
<blockquote>
<p>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</p>
</blockquote>
<p>现在我们假设classpath是.;C:\work\project1\bin;C:\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p>注意到 <code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpat</code>h的设定方法有两种：</p>
<ol>
<li>在系统环境变量中设置 <code>classpath</code>环境变量，不推荐；</li>
<li>在启动JVM时设置 <code>classpath</code>变量，推荐。</li>
</ol>
<p>我们强烈不推荐在系统环境变量中设置 <code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置 <code>classpath</code>才是推荐的做法。实际上就是给 <code>java</code>命令传入 <code>-classpat</code>h或 <code>-cp</code>参数：</p>
<blockquote>
<p>java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</p>
</blockquote>
<p>或者使用 <code>-cp</code>的简写：</p>
<blockquote>
<p>java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</p>
</blockquote>
<p>没有设置系统环境变量，也没有传入 <code>-cp</code>参数，那么JVM默认的classpath为 <code>.</code>，即当前目录：</p>
<blockquote>
<p>java abc.xyz.Hello</p>
</blockquote>
<p>上述命令告诉JVM只在当前目录搜索Hello.class。</p>
<p>在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。</p>
<p>通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？</p>
<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的 <code>rt.jar</code>放入 <code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找 <code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>
<div class="note info simple"><p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库</p>
</div>
<p>更好的做法是，不要设置 <code>classpath</code>！默认的当前目录.对于绝大多数情况都够用了。</p>
<p>假设我们有一个编译后的 <code>Hello.class</code>，它的包名是 <code>com.example</code>，当前目录是 <code>C:\work</code>，那么，目录结构必须如下：</p>
<p>C:\work<br>
└─ com<br>
└─ example<br>
└─ Hello.class<br>
运行这个Hello.class必须在当前目录下使用如下命令：</p>
<blockquote>
<p>C:\work&gt; java -cp . com.example.Hello</p>
</blockquote>
<p>JVM根据 <code>classpath</code>设置的.在当前目录下查找 <code>com.example.Hello</code>，即实际搜索文件必须位于 <code>com/example/Hello.class</code>。如果指定的 <code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p>
<h4 id="jar包">jar包</h4>
<p>如果有很多 <code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>jar包就是用来干这个事的，它可以把 <code>package</code>组织的目录层级，以及各个目录下的所有文件（包括 <code>.class</code>文件和其他文件）都打成一个 <code>jar</code>文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的 <code>class</code>，就可以把jar包放到 <code>classpath</code>中：</p>
<blockquote>
<p>java -cp ./hello.jar abc.xyz.Hello</p>
</blockquote>
<p>这样JVM会自动在 <code>hello.jar</code>文件里去搜索某个类。</p>
<p>那么问题来了：如何创建jar包？</p>
<p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从 <code>.zip</code>改为 <code>.jar</code>，一个jar包就创建成功。</p>
<p>假设编译输出的目录结构是这样：</p>
<p>package_sample<br>
└─ bin<br>
├─ hong<br>
│  └─ Person.class<br>
│  ming<br>
│  └─ Person.class<br>
└─ mr<br>
└─ jun<br>
└─ Arrays.class<br>
这里需要特别注意的是，jar包里的第一层目录，不能是 <code>bin</code>，而应该是 <code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l" alt=""></p>
<p>如果长这样：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l" alt=""></p>
<p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的 <code>class</code>，原因是 <code>hong.Person</code>必须按 <code>hong/Person.class</code>存放，而不是 <code>bin/hong/Person.class</code>。</p>
<p>jar包还可以包含一个特殊的 <code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定 <code>Main-Class</code>和其它信息。JVM会自动读取这个 <code>MANIFEST.MF</code>文件，如果存在 <code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<blockquote>
<p>java -jar hello.jar</p>
</blockquote>
<p>jar包还可以包含其它jar包，这个时候，就需要在 <code>MANIFEST.MF</code>文件里配置 <code>classpath</code>了。</p>
<p>在大型项目中，不可能手动编写 <code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如 <code>Maven</code>，可以非常方便地创建jar包。</p>
<h4 id="模块">模块</h4>
<p>从Java 9开始，JDK又引入了模块（Module）。</p>
<p>什么是模块？这要从Java 9之前的版本说起。</p>
<p>我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。</p>
<p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫 <code>rt.jar</code>，一共有60多M。</p>
<p>如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<blockquote>
<p>java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</p>
</blockquote>
<div class="note info simple"><p>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。<br>
如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出 <code>ClassNotFoundException</code>。</p>
</div>
<p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p>
<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。</p>
<p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的 <code>rt.jar</code>分拆成了几十个模块，这些模块以 <code>.jmod</code>扩展名标识，可以在 <code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些 <code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块 <code>java.base</code>对应的文件就是 <code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的 <code>module-info.class</code>文件了。所有的模块都直接或间接地依赖 <code>java.base</code>模块，只有 <code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从 <code>Object</code>直接或间接继承而来。</p>
<p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p>
<h4 id="编写模块">编写模块</h4>
<p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以 <code>oop-module</code>工程为例，它的目录结构如下：</p>
<p>oop-module<br>
├── bin<br>
├── <a target="_blank" rel="noopener" href="http://build.sh">build.sh</a><br>
└── src<br>
├── com<br>
│   └── itranswarp<br>
│       └── sample<br>
│           ├── Greeting.java<br>
│           └── Main.java<br>
└── module-info.java</p>
<p>其中，<code>bin</code>目录存放编译后的 <code>class</code>文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在 <code>src</code>目录下多了一个 <code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>module</code>是关键字，后面的 <code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的 <code>requires xxx</code>;表示这个模块需要引用的其他模块名。除了 <code>java.base</code>可以被自动引入外，这里我们引入了一个 <code>java.xml</code>的模块。<br>
当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Greeting g = <span class="keyword">new</span> Greeting();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把 <code>requires java.xml;</code>从 <code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。<br>
下面，我们用JDK提供的命令行工具来编译并创建模块。</p>
<p>首先，我们把工作目录切换到 <code>oop-module</code>，在当前目录下编译所有的 <code>.java</code>文件，并存放到 <code>bin</code>目录下，命令如下：</p>
<blockquote>
<p>$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</p>
</blockquote>
<p>如果编译成功，现在项目结构如下：<br>
oop-module<br>
├── bin<br>
│   ├── com<br>
│   │   └── itranswarp<br>
│   │       └── sample<br>
│   │           ├── Greeting.class<br>
│   │           └── Main.class<br>
│   └── module-info.class<br>
└── src<br>
├── com<br>
│   └── itranswarp<br>
│       └── sample<br>
│           ├── Greeting.java<br>
│           └── Main.java<br>
└── module-info.java</p>
<p>注意到 <code>src</code>目录下的 <code>module-info.java</code>被编译到 <code>bin</code>目录下的 <code>module-info.class</code>。</p>
<p>下一步，我们需要把 <code>bin</code>目录下的所有 <code>class</code>文件先打包成 <code>jar</code>，在打包的时候，注意传入 <code>--main-class</code>参数，让这个jar包能自己定位main方法所在的类：</p>
<blockquote>
<p>$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</p>
</blockquote>
<p>现在我们就在当前目录下得到了 <code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令 <code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块：</p>
<blockquote>
<p>$ jmod create --class-path hello.jar hello.jmod</p>
</blockquote>
<p>于是，在当前目录下我们又得到了 <code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p>
<h4 id="运行模块">运行模块</h4>
<p>要运行一个jar，我们使用 <code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p>
<blockquote>
<p>$ java --module-path hello.jmod --module hello.world</p>
</blockquote>
<p>结果是一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure>
<p>原因是 <code>.jmod</code>不能被放入 <code>--module-path</code>中。换成 <code>.jar</code>就没问题了：</p>
<blockquote>
<p>$ java --module-path hello.jar --module hello.world<br>
Hello, xml!</p>
</blockquote>
<p>那我们辛辛苦苦创建的 <code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p>
<h4 id="打包JRE">打包JRE</h4>
<p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的 <code>rt.jar</code>拆成了几十个.<code>jmod模块</code>，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p>
<p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>
<p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下：</p>
<blockquote>
<p>$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</p>
</blockquote>
<p>我们在 <code>--module-path</code>参数指定了我们自己的模块 <code>hello.jmod</code>，然后，在 <code>--add-modules</code>参数中指定了我们用到的3个模块 <code>java.base</code>、<code>java.xml</code>和 <code>hello.world</code>，用,分隔。最后，在 <code>--output</code>参数指定输出目录。</p>
<p>现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己 <code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p>
<blockquote>
<p>$ jre/bin/java --module hello.world<br>
Hello, xml!</p>
</blockquote>
<p>要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p>
<h4 id="访问权限">访问权限</h4>
<p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p>
<p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p>
<p>举个例子：我们编写的模块 <code>hello.world</code>用到了模块 <code>java.xml</code>的一个类 <code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块 <code>java.xml</code>的 <code>module-info.java</code>中声明了若干导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的 <code>hello.world</code>模块中的 <code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，模块进一步隔离了代码的访问权限。</p>
<h2 id="Java核心类">Java核心类</h2>
<h3 id="字符串和编码">字符串和编码</h3>
<h4 id="String">String</h4>
<p>在Java中，<code>String</code>是一个引用类型，它本身也是一个 <code>class</code>。但是，Java编译器对String有特殊处理，即可以直接用 <code>&quot;...&quot;</code>来表示一个字符串：</p>
<blockquote>
<p>String s1 = “Hello!”;</p>
</blockquote>
<p>实际上字符串在String内部是通过一个 <code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>
<blockquote>
<p>String s2 = new String(new char[] {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘!’});</p>
</blockquote>
<p>因为 <code>String</code>太常用了，所以Java提供了 <code>&quot;...&quot;</code>这种字符串字面量表示方法。</p>
<p>Java字符串的一个重要特点就是 <code>字符串不可变</code>。这种不可变性是通过内部的 <code>private final char[]</code>字段，以及没有任何修改 <code>char[]</code>的方法实现的。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(s);  <span class="comment">// Hello</span></span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        System.out.println(s);  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/one12138/p/11379840.html">关于字符串不可变的进一步参考</a></p>
<h4 id="字符串比较">字符串比较</h4>
<p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用 <code>equals()</code>方法而不能用==。</p>
<p>我们看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);    <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2));  <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从表面上看，两个字符串用 <code>==</code>和 <code>equals()</code>比较都为 <code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然 <code>s1</code>和 <code>s2</code>的引用就是相同的。</p>
<p>所以，这种 <code>==</code>比较返回 <code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);        <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s2));   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：两个字符串比较，必须总是使用 <code>equals()</code>方法。</p>
<p>要忽略大小写比较，使用 <code>equalsIgnoreCase()</code>方法。</p>
<p>String类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p>
<blockquote>
<p>// 是否包含子串:<br>
“Hello”.contains(“ll”); // true</p>
</blockquote>
<p>注意到 <code>contains()</code>方法的参数是 <code>CharSequence</code>而不是 <code>String</code>，因为 <code>CharSequence</code>是 <code>String</code>的父类。</p>
<p>搜索子串的更多的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>提取子串的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意索引号是从0开始的。</p>
<h4 id="去除首尾空白字符">去除首尾空白字符</h4>
<p>使用 <code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p>
<blockquote>
<p>&quot;  \tHello\r\n &quot;.trim(); // “Hello”</p>
</blockquote>
<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
<p>另一个 <code>strip()</code>方法也可以移除字符串首尾空白字符。它和 <code>trim()</code>不同的是，类似中文的空格字符 <code>\u3000</code>也会被移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>String还提供了 <code>isEmpty()</code>和 <code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>
<h4 id="替换子串">替换子串</h4>
<p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一种是通过正则表达式替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码通过正则表达式，把匹配的子串统一替换为 <code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p>
<h4 id="分割字符串">分割字符串</h4>
<p>要分割字符串，使用 <code>split()</code>方法，并且传入的也是正则表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="拼接字符串">拼接字符串</h4>
<p>拼接字符串使用静态方法 <code>join()</code>，它用指定的字符串连接字符串数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="格式化字符串">格式化字符串</h4>
<p>字符串提供了 <code>formatted()</code>方法和 <code>format()静态方法</code>，可以传入其他参数，替换占位符，然后生成新的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));    <span class="comment">//Hi Alice, your score is 80!</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));     <span class="comment">//Hi Bob, your score is 59.50!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p>
<ul>
<li>%s：显示字符串；</li>
<li>%d：显示整数；</li>
<li>%x：显示十六进制整数；</li>
<li>%f：显示浮点数。</li>
</ul>
<p>占位符还可以带格式，例如 <code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用 <code>%s</code>，因为 <code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p>
<h4 id="类型转换">类型转换</h4>
<p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法 <code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为 <code>int</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为 <code>boolean</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，<code>Integer</code>有个 <code>getInteger(String)</code>方法，它不是将字符串转换为 <code>int</code>，而是把该字符串对应的系统变量转换为 <code>Integer</code>：</p>
<blockquote>
<p>Integer.getInteger(“java.version”); // 版本号，11</p>
</blockquote>
<h4 id="转换为char">转换为char[]</h4>
<p><code>String</code>和 <code>char[]</code>类型可以互相转换，方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>
<p>如果修改了 <code>char[]</code>数组，<code>String</code>并不会改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        String s = <span class="keyword">new</span> String(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为通过 <code>new String(char[])</code>创建新的 <code>String</code>实例时，它并不会直接引用传入的 <code>char[]</code>数组，而是会复制一份，所以，修改外部的 <code>char[]</code>数组不会影响 <code>String</code>实例内部的 <code>char[]</code>数组，因为这是两个不同的数组。</p>
<p>从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>
<p>例如，下面的代码设计了一个 <code>Score类</code>保存一组学生的成绩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        Score s = <span class="keyword">new</span> Score(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] scores;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Score</span><span class="params">(<span class="keyword">int</span>[] scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scores = scores;</span><br><span class="line">       <span class="comment">// this.scores = Arrays.copyOf(scores, scores.length);  方法一</span></span><br><span class="line">       <span class="comment">/**   方法二</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; scores.length; i++) &#123;</span></span><br><span class="line"><span class="comment">        this.scores[i]=scores[i]</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printScores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察两次输出，由于 <code>Score</code>内部直接引用了外部传入的 <code>int[]</code>数组，这会造成外部代码对 <code>int[]</code>数组的修改，影响到 <code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p>
<p>请修复 <code>Score</code>的构造方法，使得外部代码对数组的修改不影响 <code>Score</code>实例的 <code>int[]</code>字段。</p>
<h4 id="字符编码">字符编码</h4>
<p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从 <code>0</code>到 <code>127</code>，最高位始终为 <code>0</code>，称为 <code>ASCII编码</code>。例如，字符 <code>'A'</code>的编码是 <code>0x41</code>，字符 <code>'1'</code>的编码是 <code>0x31</code>。</p>
<p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和 <code>ASCII</code>编码区分开。例如，汉字 <code>'中'</code>的 <code>GB2312</code>编码是 <code>0xd6d0</code>。</p>
<p>类似的，日文有 <code>Shift_JIS</code>编码，韩文有 <code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p>
<p>为了统一全球所有语言的编码，全球统一码联盟发布了 <code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在 <code>ASCII</code>、<code>GB2312</code>和 <code>Unicode</code>的编码：</p>
<p>英文字符 <code>'A'</code>的 <code>ASCII</code>编码和 <code>Unicode</code>编码：<br>
┌────┐<br>
ASCII:   │ 41 │<br>
└────┘<br>
┌────┬────┐<br>
Unicode: │ 00 │ 41 │<br>
└────┴────┘</p>
<p>英文字符的 <code>Unicode</code>编码就是简单地在前面添加一个 <code>00</code>字节。</p>
<p>中文字符’中’的 <code>GB2312</code>编码和 <code>Unicode</code>编码：<br>
┌────┬────┐<br>
GB2312:  │ d6 │ d0 │<br>
└────┴────┘<br>
┌────┬────┐<br>
Unicode: │ 4e │ 2d │<br>
└────┴────┘</p>
<p>GBK中文占两个字节，英文占一个字节。</p>
<p>那我们经常使用的 <code>UTF-8</code>又是什么编码呢？因为英文字符的 <code>Unicode</code>编码高字节总是 <code>00</code>，包含大量英文的文本会浪费空间，所以，出现了 <code>UTF-8</code>编码，它是一种 <code>变长编码</code>，用来把固定长度的 <code>Unicode编码</code>变成 <code>1～4字节的变长编码</code>。通过 <code>UTF-8</code>编码，英文字符 <code>'A'</code>的 <code>UTF-8</code>编码变为0x41，正好和 <code>ASCII码</code>一致，而中文 <code>'中'</code>的 <code>UTF-8</code>编码为3字节 <code>0xe4b8ad</code>。</p>
<p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为 <code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
<p>在Java中，<code>char</code>类型实际上就是两个字节的 <code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>
<p>注意：转换编码后，就不再是 <code>char</code>类型，而是 <code>byte</code>类型表示的数组。</p>
<p>如果要把已知编码的 <code>byte[]</code>转换为 <code>String</code>，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<p>始终牢记：Java的 <code>String</code>和 <code>char</code>在内存中总是以 <code>Unicode</code>编码表示。</p>
<h4 id="延伸阅读">延伸阅读</h4>
<p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的 <code>String</code>总是以char[]存储，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而较新的JDK版本的 <code>String</code>则以 <code>byte[]</code>存储：如果String仅包含 <code>ASCII</code>字符，则每个 <code>byte</code>存储一个字符，否则，每两个 <code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的 <code>String</code>通常仅包含 <code>ASCII字符</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure>
<p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的 <code>public</code>方法签名是不变的。</p>
<h3 id="StringBuilder">StringBuilder</h3>
<p>Java编译器对 <code>String</code>做了特殊处理，使得我们可以直接用 <code>+</code>拼接字符串。</p>
<p>考察下面的循环代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC(垃圾收集 Garbage Collection)效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了 <code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往 <code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure>
<p><code>StringBuilder</code>还可以进行链式操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());  <span class="comment">//Hello, Mr Bob!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们查看 <code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的 <code>append()</code>方法会返回 <code>this</code>，这样，就可以不断调用自身的其他方法。</p>
<p>仿照 <code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Adder adder = <span class="keyword">new</span> Adder();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());  <span class="comment">//19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adder <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adder <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对于普通的字符串 <code>+</code>操作，并不需要我们将其改写为 <code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的 <code>+</code>操作编码为 <code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者 <code>StringBuilder</code>操作。</p>
<p>你可能还听说过 <code>StringBuffer</code>，这是Java早期的一个 <code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作 <code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p>
<p><code>StringBuilder</code>和 <code>StringBuffer</code>接口完全相同，现在完全没有必要使用 <code>StringBuffer</code>。</p>
<h3 id="StringJoiner">StringJoiner</h3>
<p>要高效拼接字符串，应该使用 <code>StringBuilder</code>。</p>
<p>很多时候，我们拼接的字符串像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个 <code>StringJoiner</code>来干这个事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>慢着！用 <code>StringJoiner</code>的结果少了前面的 <code>&quot;Hello &quot;</code>和结尾的 <code>&quot;!&quot;</code>！遇到这种情况，需要给 <code>StringJoiner</code>指定“开头”和“结尾”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="String-join">String.join()</h4>
<p><code>String</code>还提供了一个静态方法 <code>join()</code>，这个方法在内部使用了 <code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用 <code>String.join()</code>更方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>
<h3 id="包装类型">包装类型</h3>
<p>我们已经知道，Java的数据类型分两种：</p>
<p>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></p>
<p>引用类型：所有 <code>class</code>和 <code>interface</code>类型</p>
<p>引用类型可以赋值为 <code>null</code>，表示空，但基本类型不能赋值为 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>那么，如何把一个基本类型视为对象（引用类型）？</p>
<p>比如，想要把 <code>int</code>基本类型变成一个引用类型，我们可以定义一个 <code>Integer</code>类，它只包含一个实例字段 <code>int</code>，这样，<code>Integer</code>类就可以视为int的包装类 <code>（Wrapper Class）</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好了 <code>Integer</code>类，我们就可以把 <code>int</code>和 <code>Integer</code>互相转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">null</span>;</span><br><span class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</span><br><span class="line"><span class="keyword">int</span> n3 = n2.intValue();</span><br></pre></td></tr></table></figure>
<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
</tbody>
</table>
<p>我们可以直接使用，并不需要自己去定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        Integer n3 = Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Auto-Boxing">Auto Boxing</h4>
<p>因为int和Integer可以互相转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer n = Integer.valueOf(i);</span><br><span class="line"><span class="keyword">int</span> x = n.intValue();</span><br></pre></td></tr></table></figure>
<p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<p>这种直接把 <code>int</code>变为 <code>Integer</code>的赋值写法，称为自动装箱 <code>（Auto Boxing）</code>，反过来，把 <code>Integer</code>变为 <code>int</code>的赋值写法，称为自动拆箱 <code>（Auto Unboxing）</code>。</p>
<p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
<p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报 <code>NullPointerException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;java.lang.Integer.intValue()&quot; because &quot;&lt;local1&gt;&quot; is null</span></span><br><span class="line"><span class="comment">at Main.main(Main.java:5)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="不变类">不变类</h4>
<p>所有的包装类型都是不变类。我们查看 <code>Integer</code>的源码可知，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，一旦创建了Integer对象，该对象就是不变的。</p>
<p>对两个 <code>Integer</code>实例进行比较要特别注意：绝对不能用 <code>==</code>比较，因为 <code>Integer</code>是引用类型，必须使用 <code>equals()</code>比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">127</span>;</span><br><span class="line">        Integer y = <span class="number">127</span>;</span><br><span class="line">        Integer m = <span class="number">99999</span>;</span><br><span class="line">        Integer n = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x == y: &quot;</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m == n: &quot;</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x.equals(y): &quot;</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m.equals(n): &quot;</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的 <code>Integer</code>返回 <code>true</code>，较大的两个相同的 <code>Integer</code>返回 <code>false</code>，这是因为 <code>Integer</code>是不变类，编译器把 <code>Integer x = 127;</code>自动变为 <code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为 <code>true</code>，但我们绝不能因为Java标准库的 <code>Integer</code>内部有缓存优化就用 <code>==</code>比较，必须用 <code>equals()</code>方法比较两个 <code>Integer</code>。</p>
<p>因为 <code>Integer.valueOf()</code>可能始终返回同一个 <code>Integer</code>实例，因此，在我们自己创建 <code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li>方法1：Integer n = new Integer(100);</li>
<li>方法2：Integer n = Integer.valueOf(100);</li>
</ul>
<p>方法2更好，因为方法1总是创建新的 <code>Integer</code>实例，方法2把内部优化留给 <code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
<p>我们把能创建“新”对象的静态方法称为 <code>静态工厂方法</code>。<code>Integer.valueOf()</code>就是 <code>静态工厂方法</code>，它尽可能地返回缓存的实例以节省内存。</p>
<div class="note info simple"><p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p>
</div>
<p>如果我们考察 <code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的 <code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p>
<h4 id="进制转换">进制转换</h4>
<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法 <code>parseInt()</code>可以把字符串解析成一个整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br></pre></td></tr></table></figure>
<p>注意：上述方法的输出都是 <code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p>
<p>┌────────┬────────┬────────┬────────┐<br>
│00000000│00000000│00000000│01100100│<br>
└────────┴────────┴────────┴────────┘<br>
我们经常使用的 <code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用 <code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p>
<p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p>
<p>Java的包装类型还定义了一些有用的静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>
<p>最后，所有的整数和浮点数的包装类型都继承自 <code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="keyword">byte</span> b = num.byteValue();</span><br><span class="line"><span class="keyword">int</span> n = num.intValue();</span><br><span class="line"><span class="keyword">long</span> ln = num.longValue();</span><br><span class="line"><span class="keyword">float</span> f = num.floatValue();</span><br><span class="line"><span class="keyword">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure>
<h4 id="处理无符号整型">处理无符号整型</h4>
<p>在Java中，并没有 <code>无符号整型（Unsigned）</code>的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和 <code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>byte</code>的 <code>-1</code>的二进制表示是 <code>11111111</code>，以无符号整型转换后的 <code>int</code>就是 <code>255</code>。</p>
<p>类似的，可以把一个 <code>short</code>按 <code>unsigned</code>转换为 <code>int</code>，把一个 <code>int</code>按 <code>unsigned</code>转换为 <code>long</code>。</p>
<h3 id="JavaBean">JavaBean</h3>
<p>在Java中，有很多 <code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果读写方法符合以下这种命名规范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure>
<p>那么这种class被称为 <code>JavaBean</code>：</p>
<p>上面的字段是 <code>xyz</code>，那么读写方法名分别以 <code>get</code>和 <code>set</code>开头，并且后接大写字母开头的字段名 <code>Xyz</code>，因此两个读写方法名分别是 <code>getXyz()</code>和 <code>setXyz()</code>。</p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为 <code>isXyz()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br></pre></td></tr></table></figure>
<p>我们通常把一组对应的 <code>读方法（getter）</code>和 <code>写方法（setter）</code>称为 <code>属性（property）</code>。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有 <code>getter</code>的属性称为 <code>只读属性（read-only）</code>，例如，定义一个 <code>age</code>只读属性：</p>
<ul>
<li>对应的读方法是<code>int getAge()</code></li>
<li>无对应的写方法<code>setAge(int)</code></li>
</ul>
<p>类似的，只有 <code>setter</code>的属性称为 <code>只写属性（write-only）</code>。</p>
<p>很明显，只读属性很常见，只写属性不常见。</p>
<p>属性只需要定义 <code>getter</code>和 <code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>getter</code>和 <code>setter</code>也是一种数据封装的方法。</p>
<h4 id="JavaBean的作用">JavaBean的作用</h4>
<p><code>JavaBean</code>主要用来传递数据，即把一组数据组合成一个J <code>avaBean</code>便于传输。此外，<code>JavaBean</code>可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p>
<p>通过IDE，可以快速生成 <code>getter</code>和 <code>setter</code>。例如，在Eclipse中，先输入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成 <code>getter</code>和 <code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p>
<h4 id="枚举JavaBean属性">枚举JavaBean属性</h4>
<p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的 <code>Introspector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              age</span></span><br><span class="line"><span class="comment">            public int Person.getAge()</span></span><br><span class="line"><span class="comment">            public void Person.setAge(int)</span></span><br><span class="line"><span class="comment">              class</span></span><br><span class="line"><span class="comment">            public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">            null</span></span><br><span class="line"><span class="comment">              name</span></span><br><span class="line"><span class="comment">            public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">            public void Person.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意 <code>class</code>属性是从 <code>Object</code>继承的 <code>getClass()</code>方法带来的</p>
<h3 id="枚举类">枚举类</h3>
<p>在Java中，我们可以通过static final来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的int表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MON = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THU = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRI = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAT = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用常量的时候，可以这么引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> work at home</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RED = <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREEN = <span class="string">&quot;g&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BLUE = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用常量的时候，可以这么引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String color = ...</span><br><span class="line"><span class="keyword">if</span> (Color.RED.equals(color)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是int常量还是String常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekday == <span class="number">6</span> || weekday == <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == Weekday.MON) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码编译和运行均不会报错，但存在两个问题：</p>
<p>注意到 <code>Weekday</code>定义的常量范围是 <code>0~6</code>，并不包含7，编译器无法检查不在枚举中的int值；<br>
定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</p>
<h4 id="enum">enum</h4>
<p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到定义枚举类是通过关键字 <code>enum</code>实现的，我们只需依次列出枚举的常量名。</p>
<p>和int定义的常量相比，使用 <code>enum</code>定义枚举有如下好处：</p>
<p>首先，<code>enum</code>常量本身带有类型信息，即 <code>Weekday.SUN</code>类型是 <code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> day = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>
<p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个 <code>Weekday</code>枚举类型的变量赋值为 <code>Color</code>枚举类型的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Weekday x = Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line">Weekday y = Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure>
<p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p>
<h4 id="enum的比较">enum的比较</h4>
<p>使用 <code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用 <code>equals()</code>方法，如果使用 <code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用 <code>equals()</code>方法，但 <code>enum</code>类型可以例外。</p>
<p>这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用 <code>==</code>比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enum类型">enum类型</h4>
<p>通过 <code>enum</code>定义的枚举类，和其他的 <code>class</code>有什么区别？</p>
<p>答案是没有任何区别。<code>enum</code>定义的类型就是 <code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
<li>例如，我们定义的<code>Color</code>枚举类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器编译出的class大概就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，编译后的 <code>enum</code>类和普通 <code>class</code>并没有任何区别。但是我们自己无法按定义普通 <code>class</code>那样来定义 <code>enum</code>，必须使用 <code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为 <code>enum</code>是一个 <code>class</code>，每个枚举的值都是 <code>class</code>实例，因此，这些实例有一些方法：</p>
<h5 id="name">name()</h5>
<p>返回常量名，例如：</p>
<blockquote>
<p>String s = <a target="_blank" rel="noopener" href="http://Weekday.SUN.name">Weekday.SUN.name</a>(); // “SUN”</p>
</blockquote>
<h5 id="ordinal">ordinal()</h5>
<p>返回定义的常量的顺序，从0开始计数，例如：</p>
<blockquote>
<p>int n = Weekday.MON.ordinal(); // 1</p>
</blockquote>
<p>改变枚举常量定义的顺序就会导致 <code>ordinal()</code>返回值发生变化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的 <code>ordinal</code>就是不同的。如果在代码中编写了类似 <code>if(x.ordinal()==1)</code>这样的语句，就要保证 <code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p>
<p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和 <code>int</code>转换，使用 <code>ordinal()</code>不是非常方便？比如这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String task = Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure>
<p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠 <code>ordinal()</code>的返回值。因为 <code>enum</code>本身是 <code>class</code>，所以我们可以定义 <code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个 <code>int</code>值。</p>
<p>注意：枚举类的字段也可以是非 <code>final</code>类型，即可以在运行期修改，但是不推荐这样做！</p>
<p>默认情况下，对枚举常量调用 <code>toString()</code>会返回和 <code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而 <code>name()</code>则不行。我们可以给 <code>Weekday</code>添加 <code>toString()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆写 <code>toString()</code>的目的是在输出时更有可读性。</p>
<p>注意：判断枚举常量的名字，要始终使用 <code>name()</code>方法，绝不能调用 <code>toString()</code>！</p>
<h4 id="switch">switch</h4>
<p>最后，枚举类可以应用在 <code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比 <code>int</code>、<code>String</code>类型更适合用在 <code>switch</code>语句中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录类">记录类</h3>
<p>使用 <code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ol>
<li>定义<code>class</code>时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<p>假设我们希望定义一个 <code>Point</code>类，有 <code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证不变类的比较，还需要正确覆写 <code>equals()</code>和 <code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写 <code>equals()</code>和 <code>hashCode()</code>，这里演示 <code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p>
<h4 id="record">record</h4>
<p>从Java 14开始，引入了新的 <code>Record</code>类。我们定义 <code>Record</code>类时，使用关键字 <code>record</code>。把上述 <code>Point</code>类改写为 <code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 456</span></span><br><span class="line"><span class="comment">// Point[x=123, y=456]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察 <code>Point</code>的定义：</p>
<blockquote>
<p>public record Point(int x, int y) {}</p>
</blockquote>
<p>把上述定义改写为class，相当于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了用 <code>final</code>修饰 <code>class</code>以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写 <code>toString()</code>、<code>equals()</code>和 <code>hashCode()</code>方法。</p>
<p>换句话说，使用 <code>record</code>关键字，可以一行写出一个不变类。</p>
<p>和 <code>enum</code>类似，我们自己不能直接从 <code>Record</code>派生，只能通过 <code>record</code>关键字由编译器实现继承。</p>
<h4 id="构造方法-2">构造方法</h4>
<p>编译器默认按照 <code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>
<p>假设 <code>Point</code>类的 <code>x</code>、<code>y</code>不允许负数，我们就得给 <code>Point</code>的构造方法加上检查逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到方法 <code>public Point &#123;...&#125;</code>被称为 <code>Compact Constructor</code>，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为 <code>record</code>的 <code>Point</code>仍然可以添加静态方法。一种常用的静态方法是 <code>of()</code>方法，用来创建 <code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以写出更简洁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> z = Point.of();</span><br><span class="line"><span class="keyword">var</span> p = Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>
<h3 id="BigInteger">BigInteger</h3>
<p>在Java中，由CPU原生提供的整型最大范围是 <code>64位long</code>型整数。使用 <code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了 <code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个 <code>int[]</code>数组来模拟一个非常大的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>
<p>对 <code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>
<p>和 <code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p>
<p>也可以把 <code>BigInteger</code>转换成 <code>long</code>型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p><code>BigInteger</code>和 <code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自 <code>Number</code>类。因为 <code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为byte：byteValue()</li>
<li>转换为short：shortValue()</li>
<li>转换为int：intValue()</li>
<li>转换为long：longValue()</li>
<li>转换为float：floatValue()</li>
<li>转换为double：doubleValue()</li>
</ul>
<p>因此，通过上述方法，可以把 <code>BigInteger</code>转换成基本类型。如果 <code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用 <code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出 <code>ArithmeticException</code>异常。</p>
<p>如果 <code>BigInteger</code>的值甚至超过了 <code>float</code>的最大范围（3.4x1038），那么返回的 <code>float</code>是  <code>Infinity</code></p>
<h3 id="BigDecimal">BigDecimal</h3>
<p>和 <code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure>
<p><code>BigDecimal</code>用 <code>scale()</code>表示小数位数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>BigDecimal</code>的 <code>stripTrailingZeros()</code>方法，可以将一个 <code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的 <code>BigDecimal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<p>如果一个 <code>BigDecimal</code>的 <code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>
<p>可以对一个 <code>BigDecimal</code>设置它的 <code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>
<p>还可以对 <code>BigDecimal</code>做除法的同时求余数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>divideAndRemainder()</code>方法时，返回的数组包含两个 <code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个 <code>BigDecimal</code>是否是整数倍数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较BigDecimal">比较BigDecimal</h4>
<p>在比较两个 <code>BigDecimal</code>的值是否相等时，要特别注意，使用 <code>equals()</code>方法不但要求两个 <code>BigDecimal</code>的值相等，还要求它们的 <code>scale()相</code>等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>必须使用 <code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。</p>
<p>总是使用 <code>compareTo()</code>比较两个 <code>BigDecimal</code>的值，不要使用 <code>equals()</code>！</p>
<p>如果查看 <code>BigDecimal</code>的源码，可以发现，实际上一个 <code>BigDecimal</code>是通过一个 <code>BigInteger</code>和一个 <code>scale</code>来表示的，即 <code>BigInteger</code>表示一个完整的整数，而 <code>scale</code>表示小数位数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BigDecimal</code>也是从 <code>Number</code>继承的，也是不可变对象。</p>
<h3 id="常用工具类">常用工具类</h3>
<h4 id="Math">Math</h4>
<p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p>
<p>求绝对值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure>
<p>取最大或最小值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure>
<p>计算xy次方：</p>
<blockquote>
<p>Math.pow(2, 10); // 2的10次方=1024</p>
</blockquote>
<p>计算√x：</p>
<blockquote>
<p>Math.sqrt(2); // 1.414…</p>
</blockquote>
<p>计算ex次方：</p>
<blockquote>
<p>Math.exp(2); // 7.389…</p>
</blockquote>
<p>计算以e为底的对数：</p>
<blockquote>
<p>Math.log(4); // 1.386…</p>
</blockquote>
<p>计算以10为底的对数：</p>
<blockquote>
<p>Math.log10(100); // 2</p>
</blockquote>
<p>三角函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure>
<p><code>Math</code>还提供了几个数学常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure>
<p>生成一个随机数x，x的范围是0 &lt;= x &lt; 1：</p>
<blockquote>
<p>Math.random(); // 0.53907… 每次都不一样</p>
</blockquote>
<p>如果我们要生成一个区间在 <code>[MIN, MAX)</code>的随机数，可以借助 <code>Math.random()</code>实现，计算如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="keyword">double</span> min = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">double</span> y = x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="keyword">long</span> n = (<span class="keyword">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些童鞋可能注意到Java标准库还提供了一个 <code>StrictMath</code>，它提供了和 <code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如 <code>x86</code>和 <code>ARM</code>）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而 <code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 <code>Math</code>就足够了。</p>
<h4 id="Random">Random</h4>
<p><code>Random</code>用来创建 <code>伪随机数</code>。所谓 <code>伪随机数</code>，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<p>要生成一个随机数，可以使用 <code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。</p>
<p>这是因为我们创建 <code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p>
<p>如果我们在创建 <code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面我们使用的 <code>Math.random()</code>实际上内部调用了 <code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p>
<h4 id="SecureRandom">SecureRandom</h4>
<p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>无法指定种子，它使用 <code>RNG（random number generator）</code>算法。JDK的 <code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
<p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 <code>SecureRandom</code>来产生安全的随机数。</p>
<p>需要使用安全随机数的时候，必须使用 <code>SecureRandom</code>，绝不能使用 <code>Random</code>！</p>
<h1>异常处理</h1>
<h2 id="Java的异常">Java的异常</h2>
<p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p>
<p>调用方如何获知调用失败的信息？有两种方法：</p>
<p>方法一：约定返回错误码。</p>
<p>例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> code = processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为使用 <code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p>
<p>方法二：在语言层面上提供一个异常处理机制。</p>
<p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p>
<p>异常是一种 <code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Java的异常是 <code>class</code>，它的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            ┌───────────┐</span><br><span class="line">            │  Object   │</span><br><span class="line">            └───────────┘</span><br><span class="line">                  ▲</span><br><span class="line">                  │</span><br><span class="line">            ┌───────────┐</span><br><span class="line">            │ Throwable │</span><br><span class="line">            └───────────┘</span><br><span class="line">                  ▲</span><br><span class="line">        ┌─────────┴─────────┐</span><br><span class="line">        │                   │</span><br><span class="line">  ┌───────────┐       ┌───────────┐</span><br><span class="line">  │   Error   │       │ Exception │</span><br><span class="line">  └───────────┘       └───────────┘</span><br><span class="line">        ▲                   ▲</span><br><span class="line">┌───────┘              ┌────┴──────────┐</span><br><span class="line">│                      │               │</span><br></pre></td></tr></table></figure>
<p>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>
│OutOfMemoryError │… │RuntimeException ││IOException│…<br>
└─────────────────┘    └─────────────────┘└───────────┘<br>
▲<br>
┌───────────┴─────────────┐<br>
│                         │<br>
┌─────────────────────┐ ┌─────────────────────────┐<br>
│NullPointerException │ │IllegalArgumentException │…<br>
└─────────────────────┘ └─────────────────────────┘</p>
<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自 <code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和 <code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而 <code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><code>RuntimeException</code>以及它的子类；</li>
<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p>Java规定:</p>
<ul>
<li>必须捕获的异常，包括 <code>Exception</code>及其子类，但不包括 <code>RuntimeException</code>及其子类，这种类型的异常称为 <code>Checked Exception</code>。</li>
<li>不需要捕获的异常，包括 <code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<h4 id="捕获异常">捕获异常</h4>
<p>捕获异常使用 <code>try...catch</code>语句，把可能发生异常的代码放到 <code>try &#123;...&#125;</code>中，然后使用 <code>catch</code>捕获对应的 <code>Exception</code>及其子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">        <span class="comment">//[-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不捕获 <code>UnsupportedEncodingException</code>，会出现编译失败的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main.java:11: error: unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</span></span><br><span class="line"><span class="comment">//         return s.getBytes(&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//                          ^</span></span><br><span class="line"><span class="comment">// 1 error</span></span><br><span class="line"><span class="comment">// error: compilation failed</span></span><br></pre></td></tr></table></figure>
<p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是 <code>return s.getBytes(&quot;GBK&quot;);</code>。意思是说，像 <code>UnsupportedEncodingException</code>这样的 <code>Checked Exception</code>，必须被捕获。</p>
<p>这是因为 <code>String.getBytes(String)</code>方法定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法定义的时候，使用 <code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>
<p>在 <code>toGBK()</code>方法中，因为调用了 <code>String.getBytes(String)</code>方法，就必须捕获 <code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用 <code>throws</code>表示 <code>toGBK()</code>方法可能会抛出 <code>UnsupportedEncodingException</code>，就可以让 <code>toGBK()</code>方法通过编译器检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java:6: error: unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</span></span><br><span class="line"><span class="comment">//         byte[] bs = toGBK(&quot;中文&quot;);</span></span><br><span class="line"><span class="comment">//                          ^</span></span><br><span class="line"><span class="comment">// 1 error</span></span><br><span class="line"><span class="comment">// error: compilation failed</span></span><br></pre></td></tr></table></figure>
<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用 <code>return s.getBytes(&quot;GBK&quot;)</code>;的问题，而是 <code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在 <code>main()</code>方法中，调用 <code>toGBK()</code>，没有捕获它声明的可能抛出的 <code>UnsupportedEncodingException</code>。</p>
<p>修复方法是在 <code>main()</code>方法中捕获异常并处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，只要是方法声明的 <code>Checked Exception</code>，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在 <code>main()</code>方法中捕获，不会出现漏写 <code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获 <code>Exception</code>的机会。</p>
<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何 <code>try</code>代码，可以直接把 <code>main()</code>方法定义为 <code>throws Exception</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">        <span class="comment">// [-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>main()</code>方法声明了可能抛出 <code>Exception</code>，也就声明了可能抛出所有的 <code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>
<p>还有一些童鞋喜欢在 <code>toGBK()</code>内部“消化”异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>所有异常都可以调用 <code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>
<h2 id="捕获异常-2">捕获异常</h2>
<p>在Java中，凡是可能抛出异常的语句，都可以用 <code>try ... catch</code>捕获。把可能发生异常的语句放在 <code>try &#123; ... &#125;</code>中，然后使用catch捕获对应的 <code>Exception</code>及其子类。</p>
<h4 id="多catch语句">多catch语句</h4>
<p>可以使用多个 <code>catch</code>语句，每个 <code>catch</code>分别捕获对应的 <code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配 <code>catch</code>语句，匹配到某个 <code>catch</code>后，执行 <code>catch</code>代码块，然后不再继续匹配。</p>
<p>简单地说就是：多个 <code>catch</code>语句只有一个能被执行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的，因为它是 <code>IOException</code>的子类。当抛出 <code>UnsupportedEncodingException</code>异常时，会被 <code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p>
<p>因此，正确的写法是把子类放到前面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finally语句">finally语句</h4>
<p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p>
<p>可以把执行语句写若干遍：正常执行的放到 <code>try</code>中，每个 <code>catch</code>再写一遍。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码无论是否发生异常，都会执行 <code>System.out.println(&quot;END&quot;);</code>这条语句。</p>
<p>那么如何消除这些重复的代码？Java的 <code>try ... catch</code>机制还提供了 <code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意finally有几个特点：</p>
<ol>
<li>finally语句不是必须的，可写可不写；</li>
<li>finally总是最后执行。</li>
</ol>
<p>如果没有发生异常，就正常执行 <code>try &#123; ... &#125;</code>语句块，然后执行 <code>finally</code>。如果发生了异常，就中断执行 <code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的 <code>catch</code>语句块，最后执行 <code>finally</code>。</p>
<p>可见，<code>finally</code>是用来保证一些代码必须执行的。</p>
<p>某些情况下，可以没有 <code>catch</code>，只使用 <code>try ... finally</code>结构。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方法声明了可能抛出的异常，所以可以不写 <code>catch</code>。</p>
<h4 id="捕获多种异常">捕获多种异常</h4>
<p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条 <code>catch</code>子句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为处理 <code>IOException</code>和 <code>NumberFormatException</code>的代码是相同的，所以我们可以把它两用|合并到一起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抛出异常">抛出异常</h2>
<h3 id="异常的传播">异常的传播</h3>
<p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个 <code>try ... catch</code>被捕获为止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            process1(); <span class="comment">//4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();    <span class="comment">//11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException  // 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.NumberFormatException: null</span></span><br><span class="line"><span class="comment">// 	at java.lang.Integer.parseInt(Integer.java:542)</span></span><br><span class="line"><span class="comment">// 	at java.lang.Integer.parseInt(Integer.java:615)</span></span><br><span class="line"><span class="comment">// 	at Main.process2(Main.java:15)</span></span><br><span class="line"><span class="comment">// 	at Main.process1(Main.java:11)</span></span><br><span class="line"><span class="comment">// 	at Main.main(Main.java:4)</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="keyword">null</span></span><br><span class="line">	at java.lang.Integer.parseInt(Integer.java:<span class="number">542</span>)</span><br><span class="line">	at java.lang.Integer.parseInt(Integer.java:<span class="number">615</span>)</span><br><span class="line">	at Main.process2(Main.java:<span class="number">15</span>)</span><br><span class="line">	at Main.process1(Main.java:<span class="number">11</span>)</span><br><span class="line">	at Main.main(Main.java:<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在 <code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p>
<ol>
<li>main()调用process1()；</li>
<li>process1()调用process2()；</li>
<li>process2()调用Integer.parseInt(String)；</li>
<li>Integer.parseInt(String)调用Integer.parseInt(String, int)。</li>
</ol>
<p>查看 <code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，每层调用均给出了源代码的行号，可直接定位。</p>
<h3 id="抛出异常-2">抛出异常</h3>
<p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p>
<p>如何抛出异常？参考 <code>Integer.parseInt()</code>方法，抛出异常分两步：</p>
<ol>
<li>创建某个Exception的实例；</li>
<li>用throw语句抛出。</li>
</ol>
<p>下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个方法捕获了某个异常后，又在 <code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>process2()</code>抛出 <code>NullPointerException</code>后，被 <code>process1()</code>捕获，然后抛出 <code>IllegalArgumentException()</code>。</p>
<p>如果在 <code>main()</code>中捕获 <code>IllegalArgumentException</code>，我们看看打印的异常栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的异常栈类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常 <code>NullPointerException</code>的信息了。</p>
<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的 <code>Exception</code>实例传进去，新的 <code>Exception</code>就可以持有原始 <code>Exception</code>信息。对上述代码改进如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，打印出的异常栈类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:<span class="number">20</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>注意到 <code>Caused by: Xxx</code>，说明捕获的 <code>IllegalArgumentException</code>并不是造成问题的根源，根源在于 <code>NullPointerException</code>，是在 <code>Main.process2()</code>方法抛出的。</p>
<p>在代码中获取原始异常可以使用 <code>Throwable.getCause()</code>方法。如果返回 <code>null</code>，说明已经是“根异常”了。</p>
<p>如果我们在 <code>try</code>或者 <code>catch</code>语句块中抛出异常，<code>finally</code>语句会执行</p>
<h3 id="异常屏蔽">异常屏蔽</h3>
<p>如果在执行 <code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，发现异常信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">at Main.main(Main.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>这说明 <code>finally</code>抛出异常后，原来在 <code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为 <code>“被屏蔽”的异常（Suppressed Exception）</code>。</p>
<p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用 <code>origin</code>变量保存原始异常，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally</code>抛出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>catch</code>和 <code>finally</code>都抛出了异常时，虽然 <code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:<span class="number">11</span>)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">652</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>通过 <code>Throwable.getSuppressed()</code>可以获取所有的 <code>Suppressed Exception</code>。</p>
<p>绝大多数情况下，在 <code>finally</code>中不要抛出异常。因此，我们通常不需要关心 <code>Suppressed Exception</code></p>
<h2 id="自定义异常">自定义异常</h2>
<p>Java标准库定义的常用异常包括：</p>
<p>Exception<br>
│<br>
├─ RuntimeException<br>
│  │<br>
│  ├─ NullPointerException<br>
│  │<br>
│  ├─ IndexOutOfBoundsException<br>
│  │<br>
│  ├─ SecurityException<br>
│  │<br>
│  └─ IllegalArgumentException<br>
│     │<br>
│     └─ NumberFormatException<br>
│<br>
├─ IOException<br>
│  │<br>
│  ├─ UnsupportedCharsetException<br>
│  │<br>
│  ├─ FileNotFoundException<br>
│  │<br>
│  └─ SocketException<br>
│<br>
├─ ParseException<br>
│<br>
├─ GeneralSecurityException<br>
│<br>
├─ SQLException<br>
│<br>
└─ TimeoutException</p>
<p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p>
<p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p>一个常见的做法是自定义一个 <code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>
<p><code>BaseException</code>需要从一个适合的 <code>Exception</code>派生，通常建议从 <code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他业务类型的异常就可以从 <code>BaseException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义的 <code>BaseException</code>应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述构造方法实际上都是原样照抄 <code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<h2 id="NullPointerException">NullPointerException</h2>
<p>在所有的 <code>RuntimeException</code>异常中，Java程序员最熟悉的恐怕就是 <code>NullPointerException</code>了。</p>
<p><code>NullPointerException</code>即空指针异常，俗称 <code>NPE</code>。如果一个对象为 <code>null</code>，调用其方法或访问其字段就会产生 <code>NullPointerException</code>，这个异常通常是由JVM抛出的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;&lt;local1&gt;&quot; is null</span></span><br><span class="line"><span class="comment">// at Main.main(Main.java:5)</span></span><br></pre></td></tr></table></figure>
<p>指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，<code>Null Pointer</code>更确切地说是 <code>Null Reference</code>，不过两者区别不大。</p>
<h3 id="处理NullPointerException">处理NullPointerException</h3>
<p>如果遇到 <code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code>是一种代码逻辑错误，遇到 <code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用 <code>catch</code>来隐藏这种编码错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例: 捕获NullPointerException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    transferMoney(from, to, amount);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的编码习惯可以极大地降低 <code>NullPointerException</code>的产生，例如：</p>
<p>成员变量在定义时初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用空字符串 <code>&quot;&quot;</code>而不是默认的 <code>null</code>可避免很多 <code>NullPointerException</code>，编写业务逻辑时，用空字符串 <code>&quot;&quot;</code>表示未填写比 <code>null</code>安全得多。</p>
<p>返回空字符串 <code>&quot;&quot;</code>、空数组而不是 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以使得调用方无需检查结果是否为 <code>null</code>。</p>
<p>如果调用方一定要根据 <code>null</code>判断，比如返回 <code>null</code>表示文件不存在，那么考虑返回 <code>Optional&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用方必须通过 <code>Optional.isPresent()</code>判断是否有结果。</p>
<h3 id="定位NullPointerException">定位NullPointerException</h3>
<p>如果产生了 <code>NullPointerException</code>，例如，调用 <code>a.b.c.x()</code>时产生了 <code>NullPointerException</code>，原因可能是：</p>
<ul>
<li>a是null；</li>
<li>a.b是null；</li>
<li>a.b.c是null；</li>
</ul>
<p>确定到底是哪个对象是 <code>null</code>以前只能打印这样的日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure>
<p>从Java 14开始，如果产生了 <code>NullPointerException</code>，JVM可以给出详细的信息告诉我们null对象到底是谁。我们来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;&lt;local1&gt;.address.city&quot; is null</span></span><br><span class="line"><span class="comment">// at Main.main(Main.java:5)</span></span><br></pre></td></tr></table></figure>
<p>可以在 <code>NullPointerException</code>的详细信息中看到类似 <code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是 <code>city</code>字段为 <code>null</code>，这样我们就能快速定位问题所在。</p>
<p>这种增强的 <code>NullPointerException</code>详细信息是 <code>Java 14</code>新增的功能，但默认是关闭的，我们可以给JVM添加一个 <code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p>
<blockquote>
<p>java -XX:+ShowCodeDetailsInExceptionMessages Main.java</p>
</blockquote>
<h2 id="使用断言">使用断言</h2>
<p><code>断言（Assertion）</code>是一种调试程序的方式。在Java中，使用 <code>assert</code>关键字来实现断言。</p>
<p>我们先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句 <code>assert x &gt;= 0;</code>即为断言，断言条件 <code>x &gt;= 0</code>预期为 <code>true</code>。如果计算结果为false，则断言失败，抛出 <code>AssertionError</code>。</p>
<p>使用 <code>assert</code>语句时，还可以添加一个可选的断言消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样，断言失败的时候，<code>AssertionError</code>会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p>
<p>实际上并不是这样，因为在运行时默认是关闭 <code>assert</code>的，因为开启 <code>assert</code>校验，也会损耗一定的性能，并且如果在关键部分的校验使用了 <code>assert</code>验证，但是忘记开启 <code>assert</code>功能，那么肯定会造成重大的失误，所以在生产环境下的代码，是不建议使用 <code>assert</code>功能的，一般都是在测试类里面使用的比较多。</p>
<p>Java断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p>
<p>对于可恢复的程序错误，不应该使用断言。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该抛出异常并在上层捕获：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在程序中使用 <code>assert</code>时，例如，一个简单的断言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言 <code>x</code>必须大于 <code>0</code>，实际上 <code>x</code>为 <code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code>的值。</p>
<p>这是因为JVM默认关闭断言指令，即遇到 <code>assert</code>语句就自动忽略了，不执行。</p>
<p>要执行 <code>assert</code>语句，必须给Java虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -ea Main.java</span><br></pre></td></tr></table></figure>
<p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对 <code>com.itranswarp.sample.Main</code>这个类启用断言。</p>
<p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个 <code>.</code>），表示对 <code>com.itranswarp.sample</code>这个包启动断言。</p>
<p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解 <code>JUnit</code>的使用。</p>
<h2 id="使用JDK-Logging">使用JDK Logging</h2>
<p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>
<p>代码改好了怎么办？当然是删除没有用的 <code>System.out.println()</code>语句了。</p>
<p>如果改代码又改出问题怎么办？再加上 <code>System.out.println()</code>。</p>
<p>反复这么搞几次，很快大家就发现使用 <code>System.out.println()</code>非常麻烦。</p>
<p>怎么办？</p>
<p>解决方法是使用日志。</p>
<p>那什么是日志？日志就是 <code>Logging</code>，它的目的是为了取代 <code>System.out.println()</code>。</p>
<p>输出日志，而不是用 <code>System.out.println()</code>，有以下几个好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写&quot;ERROR: &quot; + var；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以……</li>
</ol>
<p>因为Java标准库内置了日志包 <code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，得到类似如下的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>
<p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p>
<p>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的 <code>Logging</code>定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>因为默认级别是 INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>
<p>使用Java标准库内置的Logging有以下局限：</p>
<p><code>Logging</code>系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置；</p>
<p>配置不太方便，需要在JVM启动时传递参数 <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<p>因此，Java标准库内置的 <code>Logging</code>使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p>
<h2 id="使用Commons-Logging">使用Commons Logging</h2>
<p>和Java标准库提供的日志不同，<code>Commons Logging</code>是一个第三方日志库，它是由 <code>Apache</code>创建的日志模块。</p>
<p><code>Commons Logging</code>的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，<code>Commons Loggin</code>自动搜索并使用 <code>Log4j</code>（<code>Log4j</code>是另一个流行的日志系统），如果没有找到 <code>Log4j</code>，再使用 <code>JDK Logging</code>。</p>
<p>使用 <code>Commons Logging</code>只需要和两个类打交道，并且只有两步：</p>
<p>第一步，通过 <code>LogFactory</code>获取 <code>Log</code>类的实例； 第二步，使用 <code>Log</code>实例的方法打日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，肯定会得到编译错误，类似 <code>error: package org.apache.commons.logging does not exist</code>（找不到 <code>org.apache.commons.logging</code>这个包）。因为 <code>Commons Logging</code>是一个第三方提供的库，所以，必须先把它<a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到 <code>commons-logging-1.2.jar</code>这个文件，再把Java源码 <code>Main.java</code>放到一个目录下，例如 <code>work</code>目录：</p>
<p>work<br>
│<br>
├─ commons-logging-1.2.jar<br>
│<br>
└─ Main.java</p>
<p>然后用 <code>javac</code>编译 <code>Main.java</code>，编译的时候要指定 <code>classpath</code>，不然编译器找不到我们引用的 <code>org.apache.commons.logging</code>包。编译命令如下：</p>
<blockquote>
<p>javac -cp commons-logging-1.2.jar Main.java</p>
</blockquote>
<p>如果编译成功，那么当前目录下就会多出一个 <code>Main.class</code>文件：</p>
<p>work<br>
│<br>
├─ commons-logging-1.2.jar<br>
│<br>
├─ Main.java<br>
│<br>
└─ Main.class</p>
<p>现在可以执行这个 <code>Main.class</code>，使用java命令，也必须指定 <code>classpath</code>，命令如下：</p>
<blockquote>
<p>java -cp .;commons-logging-1.2.jar Main</p>
</blockquote>
<p>注意到传入的 <code>classpath</code>有两部分：一个是 <code>.</code>，一个是 <code>commons-logging-1.2.jar</code>，用 <code>;</code>分割。<code>.</code>表示当前目录，如果没有这个 <code>.</code>，JVM不会在当前目录搜索 <code>Main.class</code>，就会报错。</p>
<p>如果在Linux或macOS下运行，注意classpath的分隔符不是 <code>;</code>，而是 <code>:</code>：</p>
<blockquote>
<p>java -cp .:commons-logging-1.2.jar Main</p>
</blockquote>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">15</span>:<span class="number">31</span> PM Main main</span><br><span class="line">INFO: start...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">15</span>:<span class="number">31</span> PM Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure>
<p><code>Commons Logging</code>定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是 <code>INFO</code>。</p>
<p>使用 <code>Commons Logging</code>时，如果在静态方法中引用 <code>Log</code>，通常直接定义一个静态类型变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例方法中引用 <code>Log</code>，通常定义一个实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到实例变量log的获取方式是 <code>LogFactory.getLog(getClass())</code>，虽然也可以用 <code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该 <code>log</code>实例。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Java类的动态特性，子类获取的log字段实际上相当于 <code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p>
<p>此外，<code>Commons Logging</code>的日志方法，例如 <code>info()</code>，除了标准的 <code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Log4j">使用Log4j</h2>
<p>前面介绍了 <code>Commons Logging</code>，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 <code>Log4j</code>。</p>
<p><code>Log4j</code>是一种非常流行的日志框架，最新版本是2.x。</p>
<p><code>Log4j</code>是一个组件化设计的日志系统，它的架构大致如下：</p>
<p><a target="_blank" rel="noopener" href="http://log.info">log.info</a>(“User signed in.”);<br>
│<br>
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>
├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │<br>
│   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br>
│<br>
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>
├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │<br>
│   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br>
│<br>
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>
└──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │<br>
└──────────┘    └──────────┘    └──────────┘    └──────────┘</p>
<p>当我们使用 <code>Log4j</code>输出一条日志时，<code>Log4j</code>自动通过不同的 <code>Appender</code>把同一条日志输出到不同的目的地。例如：</p>
<ul>
<li><code>console</code>：输出到屏幕；</li>
<li><code>file</code>：输出到文件；</li>
<li><code>socket</code>：通过网络输出到远程计算机；</li>
<li><code>jdbc</code>：输出到数据库</li>
</ul>
<p>在输出日志的过程中，通过 <code>Filter</code>来过滤哪些 <code>log</code>需要被输出，哪些 <code>log</code>不需要被输出。例如，仅输出 <code>ERROR</code>级别的日志。</p>
<p>最后，通过 <code>Layout</code>来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心 <code>Log4j</code>的 <code>API</code>，而是通过配置文件来配置它。</p>
<p>以 <code>XML配置</code>为例，使用 <code>Log4j</code>的时候，我们把一个 <code>log4j2.xml</code>的文件放到 <code>classpath</code>下就可以让 <code>Log4j</code>读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然配置 <code>Log4j</code>比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是 <code>INFO</code>级别的日志，会自动输出到屏幕，而 <code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>
<p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载 <code>Log4j</code>，解压后，把以下3个jar包放到 <code>classpath</code>中：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>因为 <code>Commons Logging</code>会自动发现并使用 <code>Log4j</code>，所以，把上一节下载的 <code>commons-logging-1.2.jar</code>也放到 <code>classpath</code>中。</p>
<p>要打印日志，只需要按 <code>Commons Logging</code>的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">03</span> <span class="number">12</span>:09:<span class="number">45.880</span> [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure>
<h2 id="使用SLF4J和Logback">使用SLF4J和Logback</h2>
<p>前面介绍了 <code>Commons Logging</code>和 <code>Log4j</code>这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>
<p>有的童鞋可能还听说过 <code>SLF4J</code>和 <code>Logback</code>。这两个东东看上去也像日志，它们又是啥？</p>
<p>其实 <code>SLF4J</code>类似于 <code>Commons Logging</code>，也是一个日志接口，而 <code>Logback</code>类似于 <code>Log4j</code>，是一个日志的实现。</p>
<p>为什么有了 <code>Commons Logging</code>和 <code>Log4j</code>，又会蹦出来 <code>SLF4J</code>和 <code>Logback</code>？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p>
<p>因为对 <code>Commons Logging</code>的接口不满意，有人就搞了 <code>SLF4J</code>。因为对 <code>Log4j</code>的性能不满意，有人就搞了 <code>Logback</code>。</p>
<p>我们先来看看 <code>SLF4J</code>对 <code>Commons Logging</code>的接口有何改进。在 <code>Commons Logging</code>中，我们要打印日志，有时候得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>拼字符串是一个非常麻烦的事情，所以 <code>SLF4J</code>的日志接口改进成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure>
<p>我们靠猜也能猜出来，<code>SLF4J</code>的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p>
<p>如何使用 <code>SLF4J</code>？它的接口实际上和 <code>Commons Logging</code>几乎一模一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下 <code>Commons Logging</code>和 <code>SLF4J</code>的接口：</p>
<table>
<thead>
<tr>
<th>Commons Logging</th>
<th>SLF4J</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.apache.commons.logging.Log</td>
<td>org.slf4j.Logger</td>
</tr>
<tr>
<td>org.apache.commons.logging.LogFactory</td>
<td>org.slf4j.LoggerFactory</td>
</tr>
</tbody>
</table>
<p>不同之处就是 <code>Log</code>变成了 <code>Logger</code>，<code>LogFactory</code>变成了 <code>LoggerFactory</code>。</p>
<p>使用 <code>SLF4J</code>和 <code>Logback</code>和前面讲到的使用 <code>Commons Logging</code>加 <code>Log4j</code>是类似的，先分别下载<a target="_blank" rel="noopener" href="https://www.slf4j.org/download.html">SLF4J</a>和<a target="_blank" rel="noopener" href="https://logback.qos.ch/download.html">Logback</a>，然后把以下jar包放到 <code>classpath</code>下：</p>
<ul>
<li>slf4j-api-1.7.x.jar</li>
<li>logback-classic-1.2.x.jar</li>
<li>logback-core-1.2.x.jar</li>
</ul>
<p>然后使用 <code>SLF4J</code>的 <code>Logger</code>和 <code>LoggerFactory</code>即可。和 <code>Log4j</code>类似，我们仍然需要一个 <code>Logback</code>的配置文件，把 <code>logback.xml</code>放到 <code>classpath</code>下，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行即可获得类似如下的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">15</span>:<span class="number">25.328</span> [main] INFO  com.itranswarp.learnjava.Main - Start process...</span><br></pre></td></tr></table></figure>
<p>从目前的趋势来看，越来越多的开源项目从 <code>Commons Logging</code>加 <code>Log4j</code>转向了 <code>SLF4J</code>加 <code>Logback</code>。</p>
<h1>反射</h1>
<p>反射就是 <code>Reflection</code>，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p>
<p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果不能获得 <code>Person</code>类，只有一个 <code>Object</code>实例，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么办？有童鞋会说：强制转型啊！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用 <code>Person</code>类。不然，去掉 <code>import</code>语句，你看能不能编译通过？</p>
<p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>
<h2 id="Class类">Class类</h2>
<p>除了int等基本类型外，Java的其他类型全部都是 <code>class</code>（包括 <code>interface</code>）。例如：</p>
<ul>
<li>String</li>
<li>Object</li>
<li>Runnable</li>
<li>Exception</li>
<li>…</li>
</ul>
<p>仔细思考，我们可以得出结论：<code>class</code>（包括 <code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>而 <code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种 <code>class</code>类型时，将其加载进内存。</p>
<p>每加载一种 <code>class</code>，JVM就为其创建一个 <code>Class</code>类型的实例，并关联起来。注意：这里的 <code>Class</code>类型是一个名叫 <code>Class</code>的 <code>class</code>。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>String</code>类为例，当JVM加载 <code>String</code>类时，它首先读取 <code>String.class</code>文件到内存，然后，为 <code>String</code>类创建一个 <code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
<p>这个 <code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现 <code>Class</code>类的构造方法是 <code>private</code>，只有JVM能创建 <code>Class</code>实例，我们自己的Java程序是无法创建 <code>Class</code>实例的。</p>
<p>所以，JVM持有的每个 <code>Class</code>实例都指向一个数据类型（<code>class</code>或 <code>interface</code>）：</p>
<p>┌───────────────────────────┐<br>
│      Class Instance       │──────&gt; String<br>
├───────────────────────────┤<br>
│name = “java.lang.String”  │<br>
└───────────────────────────┘<br>
┌───────────────────────────┐<br>
│      Class Instance       │──────&gt; Random<br>
├───────────────────────────┤<br>
│name = “java.util.Random”  │<br>
└───────────────────────────┘<br>
┌───────────────────────────┐<br>
│      Class Instance       │──────&gt; Runnable<br>
├───────────────────────────┤<br>
│name = &quot;java.lang.Runnable&quot;│<br>
└───────────────────────────┘<br>
一个 <code>Class</code>实例包含了该class的所有完整信息：</p>
<p>┌───────────────────────────┐<br>
│      Class Instance       │──────&gt; String<br>
├───────────────────────────┤<br>
│name = “java.lang.String”  │<br>
├───────────────────────────┤<br>
│package = “java.lang”      │<br>
├───────────────────────────┤<br>
│super = “java.lang.Object” │<br>
├───────────────────────────┤<br>
│interface = CharSequence…│<br>
├───────────────────────────┤<br>
│field = value[],hash,…   │<br>
├───────────────────────────┤<br>
│method = indexOf()…      │<br>
└───────────────────────────┘</p>
<p>由于JVM为每个加载的 <code>class</code>创建了对应的 <code>Class</code>实例，并在实例中保存了该 <code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code>实例，我们就可以通过这个 <code>Class</code>实例获取到该实例对应的 <code>class</code>的所有信息。</p>
<p>这种通过 <code>Class</code>实例获取 <code>class</code>信息的方法称为反射 <code>（Reflection)</code>。</p>
<p>如何获取一个 <code>class</code>的 <code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个 <code>class</code>的静态变量 <code>class</code>获取：</p>
<blockquote>
<p>Class cls = String.class;</p>
</blockquote>
<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 <code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>
<p>方法三：如果知道一个 <code>class</code>的完整类名，可以通过静态方法 <code>Class.forName()</code>获取：</p>
<blockquote>
<p>Class cls = Class.forName(“java.lang.String”);</p>
</blockquote>
<p>因为 <code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的 <code>Class</code>实例是同一个实例。可以用 <code>==</code>比较两个 <code>Class</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意一下 <code>Class</code>实例比较和 <code>instanceof</code>的差别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>
<p>用 <code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code>判断 <code>class实例</code>可以精确地判断数据类型，但不能作子类型比较。</p>
<p>通常情况下，我们应该用 <code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 <code>class</code>的时候，我们才使用 <code>==</code>判断 <code>class</code>实例。</p>
<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个Object实例时，我们可以通过反射获取该 <code>Object</code>的 <code>class</code>信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要从 <code>Class</code>实例获取获取的基本信息，参考下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br></pre></td></tr></table></figure>
<p>注意到数组（例如 <code>String[]</code>）也是一种类，而且不同于 <code>String.class</code>，它的类名是 <code>[Ljava.lang.String</code>;。此外，JVM为每一种基本类型如 <code>int</code>也创建了 <code>Class</code>实例，通过 <code>int.class</code>访问。</p>
<p>如果获取到了一个 <code>Class</code>实例，我们就可以通过该 <code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure>
<p>上述代码相当于 <code>new String()</code>。通过 <code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用 <code>public</code>的无参数构造方法。带参数的构造方法，或者非 <code>public</code>的构造方法都无法通过 <code>Class.newInstance()</code>被调用。</p>
<h3 id="动态加载">动态加载</h3>
<p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 <code>Main.java</code>时，由于用到了 <code>Main</code>，因此，JVM首先会把 <code>Main.class</code>加载到内存。然而，并不会加载 <code>Person.class</code>，除非程序执行到 <code>create()</code>方法，JVM发现需要加载Person类时，才会首次加载 <code>Person.class</code>。如果没有执行 <code>create()</code>方法，那么 <code>Person.class</code>根本就不会被加载。</p>
<p>这就是JVM动态加载 <code>class</code>的特性。</p>
<p>动态加载 <code>class</code>的特性对于Java程序非常重要。利用JVM动态加载 <code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，<code>Commons Logging</code>总是优先使用 <code>Log4j</code>，只有当 <code>Log4j</code>不存在时，才使用JDK的 <code>logging</code>。利用JVM动态加载特性，大致的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问字段">访问字段</h2>
<p>对任意的一个 <code>Object</code>实例，只要我们获取了它的 <code>Class</code>，就可以获取它的一切信息。</p>
<p>我们先看看如何通过 <code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li><code>Field getField(name)</code>：根据字段名获取某个<code>public</code>的<code>field</code>（包括父类）</li>
<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个<code>field</code>（不包括父类）</li>
<li><code>Field[] getFields()</code>：获取所有<code>public</code>的<code>field</code>（包括父类）</li>
<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有<code>field</code>（不包括父类）</li>
</ul>
<p>我们来看一下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码首先获取 <code>Student</code>的 <code>Class</code>实例，然后，分别获取 <code>public</code>字段、继承的 <code>public</code>字段以及 <code>private</code>字段，打印出的 <code>Field</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.grade</span><br></pre></td></tr></table></figure>
<p>一个 <code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的<code>bit</code>表示不同的含义。</li>
</ul>
<p>以 <code>String</code>类的 <code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="获取字段值">获取字段值</h3>
<p>利用反射拿到字段的一个 <code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p>
<p>例如，对于一个 <code>Person</code>实例，我们可以先拿到 <code>name</code>字段对应的 <code>Field</code>，再获取这个实例的 <code>name</code>字段的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码先获取 <code>Class</code>实例，再获取 <code>Field</code>实例，然后，用 <code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>
<p>运行代码，如果不出意外，会得到一个 <code>IllegalAccessException</code>，这是因为 <code>name</code>被定义为一个 <code>private</code>字段，正常情况下，<code>Main</code>类无法访问 <code>Person</code>类的 <code>private</code>字段。要修复错误，可以将 <code>private</code>改为 <code>public</code>，或者，在调用 <code>Object value = f.get(p);</code>前，先写一句：</p>
<blockquote>
<p>f.setAccessible(true);</p>
</blockquote>
<p>调用 <code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是 <code>public</code>，一律允许访问。</p>
<p>可以试着加上上述语句，再运行代码，就可以打印出 <code>private</code>字段的值。</p>
<p>有童鞋会问：如果使用反射可以获取 <code>private</code>字段的值，那么类的封装还有什么意义？</p>
<p>答案是正常情况下，我们总是通过 <code>p.name</code>来访问 <code>Person</code>的 <code>name</code>字段，编译器会根据 <code>public</code>、<code>protected</code>和 <code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p>
<p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在 <code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code>。例如，某个 <code>SecurityManager</code>可能不允许对 <code>java</code>和 <code>javax</code>开头的 <code>package</code>的类调用 <code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h3 id="设置字段值">设置字段值</h3>
<p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p>
<p>设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，打印的 <code>name</code>字段从 <code>Xiao Ming</code>变成了 <code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p>
<p>同样的，修改非 <code>public</code>字段，需要首先调用 <code>setAccessible(true)</code>。</p>
<h2 id="调用方法">调用方法</h2>
<p>我们已经能通过 <code>Class</code>实例获取所有 <code>Field</code>对象，同样的，可以通过 <code>Class</code>实例获取所有 <code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取 <code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>我们来看一下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先获取 <code>Student</code>的 <code>Class</code>实例，然后，分别获取 <code>public</code>方法、继承的 <code>public</code>方法以及 <code>private</code>方法，打印出的 <code>Method</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>一个 <code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：“getScore”；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个<code>Class</code>实例，例如：String.class；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个<code>Class</code>数组，例如：{String.class, int.class}；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h3 id="调用方法-2">调用方法</h3>
<p>当我们获取到一个 <code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果用反射来调用 <code>substring</code>方法，需要以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>Method</code>实例调用 <code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>
<h3 id="调用静态方法">调用静态方法</h3>
<p>如果获取到的 <code>Method</code>表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code>方法传入的第一个参数永远为 <code>null</code>。我们以 <code>Integer.parseInt(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用非public方法">调用非public方法</h3>
<p>和 <code>Field</code>类似，对于 <code>非public</code>方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code>。为了调用 <code>非public</code>方法，我们通过 <code>Method.setAccessible(true)</code>允许其调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在 <code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code>。例如，某个 <code>SecurityManager</code>可能不允许对 <code>java</code>和 <code>javax</code>开头的 <code>package</code>的类调用 <code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h3 id="多态-3">多态</h3>
<p>我们来考察这样一种情况：一个 <code>Person</code>类定义了 <code>hello()</code>方法，并且它的子类 <code>Student</code>也覆写了 <code>hello()</code>方法，那么，从 <code>Person.class</code>获取的 <code>Method</code>，作用于 <code>Student</code>实例时，调用的方法到底是哪个？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，发现打印出的是 <code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure>
<p>实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>
<h2 id="调用构造方法">调用构造方法</h2>
<p>我们通常使用 <code>new</code>操作符创建新的实例：</p>
<blockquote>
<p>Person p = new Person();</p>
</blockquote>
<p>如果通过反射来创建新的实例，可以调用 <code>Class</code>提供的 <code>newInstance()</code>方法：</p>
<blockquote>
<p>Person p = Person.class.newInstance();</p>
</blockquote>
<p>调用 <code>Class.newInstance()</code>的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过 <code>Class.newInstance()</code>来调用。</p>
<p>为了调用任意的构造方法，Java的反射API提供了 <code>Constructor</code>对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code>对象和 <code>Method</code>非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 <code>Class</code>实例获取 <code>Constructor</code>的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<p>注意 <code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
<p>调用非 <code>public</code>的 <code>Constructor</code>时，必须首先通过 <code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<h2 id="获取继承关系">获取继承关系</h2>
<p>当我们获取到某个 <code>Class</code>对象时，实际上就获取到了一个类的类型：</p>
<blockquote>
<p>Class cls = String.class; // 获取到String的Class</p>
</blockquote>
<p>还可以用实例的 <code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure>
<p>最后一种获取Class的方法是通过 <code>Class.forName(&quot;&quot;)</code>，传入 <code>Class</code>的完整类名获取：</p>
<blockquote>
<p>Class s = Class.forName(“java.lang.String”);</p>
</blockquote>
<p>这三种方式获取的 <code>Class</code>实例都是同一个实例，因为JVM对每个加载的 <code>Class</code>只创建一个 <code>Class</code>实例来表示它的类型。</p>
<h3 id="获取父类的Class">获取父类的Class</h3>
<p>有了 <code>Class</code>实例，我们还可以获取它的父类的 <code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以看到，<code>Integer</code>的父类类型是 <code>Number</code>，<code>Number</code>的父类是 <code>Object</code>，<code>Object</code>的父类是 <code>null</code>。除 <code>Object</code>外，其他任何非 <code>interface</code>的 <code>Class</code>都必定存在一个父类类型</p>
<h3 id="获取interface">获取interface</h3>
<p>由于一个类可能实现一个或多个接口，通过 <code>Class</code>我们就可以查询到实现的接口类型。例如，查询 <code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>要特别注意： <code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Integer</code>的父类是 <code>Number</code>，<code>Number</code>实现的接口是 <code>java.io.Serializable</code>。</p>
<p>此外，对所有 <code>interface</code>的 <code>Class</code>调用 <code>getSuperclass()</code>返回的是 <code>null</code>，获取接口的父接口要用 <code>getInterfaces()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); <span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); <span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure>
<p>如果一个类没有实现任何 <code>interface</code>，那么 <code>getInterfaces()</code>返回空数组。</p>
<h3 id="继承关系">继承关系</h3>
<p>当我们判断一个实例是否是某个类型时，正常情况下，使用 <code>instanceof</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果是两个 <code>Class</code>实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>
<h2 id="动态处理">动态处理</h2>
<p>我们来比较Java的 <code>class</code>和 <code>interface</code>的区别：</p>
<ul>
<li>可以实例化<code>class</code>（非<code>abstract</code>）；</li>
<li>不能实例化<code>interface</code>。</li>
</ul>
<p>所有 <code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>
<blockquote>
<p>CharSequence cs = new StringBuilder();</p>
</blockquote>
<p>有没有可能不编写实现类，直接在运行期创建某个 <code>interface</code>的实例呢？</p>
<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个 <code>interface</code>的实例。</p>
<p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实例，转型为接口并调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>还有一种方式是动态代码，我们仍然先定义了接口 <code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个 <code>Proxy.newProxyInstance()</code>创建了一个 <code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>
<p>一个最简单的动态代理实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public abstract void Hello.morning(java.lang.String)</span></span><br><span class="line"><span class="comment">// Good morning, Bob</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在运行期动态创建一个 <code>interface</code>实例的方法如下：</p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：
<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>
<h1>注解</h1>
<p>本节我们将介绍Java程序的一种特殊“注释”——<code>注解（Annotation）</code></p>
<h2 id="使用注解">使用注解</h2>
<p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<h3 id="注解的作用">注解的作用</h3>
<p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>Java的注解可以分为三类：</p>
<p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li>@Override：让编译器检查该方法是否正确地实现了覆写；</li>
<li>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入 <code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p>第二类是由工具处理 <code>.class</code>文件使用的注解，比如有些工具会在加载 <code>class</code>的时候，对 <code>class</code>做动态修改，实现一些特殊的功能。这类注解会被编译进入 <code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了 <code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>
<p>此外，大部分注解会有一个名为 <code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了 <code>value</code>参数。</p>
<p>如果只写注解，相当于全部使用默认值。</p>
<p>举个栗子，对以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Check</code>就是一个注解。第一个 <code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个 <code>@Check(value=99)</code>只定义了一个 <code>value</code>参数，它实际上和 <code>@Check(99)</code>是完全一样的。最后一个 <code>@Check</code>表示所有参数都使用默认值。</p>
<h2 id="定义注解">定义注解</h2>
<p>Java语言使用 <code>@interface</code>语法来定义 <code>注解（Annotation）</code>，它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解的参数类似无参数方法，可以用 <code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为 <code>value</code>。</p>
<h3 id="元注解">元注解</h3>
<p>有一些注解可以修饰其他注解，这些注解就称为 <code>元注解（meta annotation）</code>。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h4 id="Target">@Target</h4>
<p>最常用的元注解是 <code>@Target</code>。使用 <code>@Target</code>可以定义 <code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解 <code>@Report</code>可用在方法上，我们必须添加一个 <code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义注解 <code>@Report</code>可用在方法或字段上，可以把 <code>@Target</code>注解参数变为数组 <code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <code>@Target</code>定义的 <code>value</code>是 <code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>
<h4 id="Retention">@Retention</h4>
<p>另一个重要的元注解 <code>@Retention</code>定义了 <code>Annotation</code>的生命周期：</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
<p>如果 <code>@Retention</code>不存在，则该 <code>Annotation</code>默认为 <code>CLASS</code>。因为通常我们自定义的 <code>Annotation</code>都是 <code>RUNTIME</code>，所以，务必要加上 <code>@Retention(RetentionPolicy.RUNTIME</code>)这个元注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Repeatable">@Repeatable</h4>
<p>使用 <code>@Repeatable</code>这个元注解可以定义 <code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 <code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个@Report注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Inherited">@Inherited</h4>
<p>用 <code>@Inherited</code>定义子类是否可继承父类定义的 <code>Annotation</code>。<code>@Inherited</code>仅针对 <code>@Target(ElementType.TYPE)</code>类型的 <code>annotation</code>有效，并且仅针对 <code>class</code>的继承，对 <code>interface</code>的继承无效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候，如果一个类用到了 <code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何定义Annotation">如何定义Annotation</h3>
<p>我们总结一下定义Annotation的步骤：</p>
<p>第一步，用@interface定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，添加参数、默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把最常用的参数定义为 <code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，必须设置 <code>@Target</code>和 <code>@Retention</code>，<code>@Retention</code>一般设置为 <code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写 <code>@Inherited</code>和 <code>@Repeatable</code>。</p>
<h2 id="处理注解">处理注解</h2>
<p>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</p>
<ul>
<li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li>
<li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有 <code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>因此，我们只讨论如何读取RUNTIME类型的注解。</p>
<p>因为注解定义后也是一种 <code>class</code>，所有的注解都继承自 <code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取 <code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于 <code>Class</code>、<code>Field</code>、<code>Method</code>或 <code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>
<p>使用反射API读取Annotation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.getAnnotation(Class)</span><br><span class="line">Field.getAnnotation(Class)</span><br><span class="line">Method.getAnnotation(Class)</span><br><span class="line">Constructor.getAnnotation(Class)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">int</span> type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure>
<p>使用 <code>反射API</code>读取 <code>Annotation</code>有两种方法。方法一是先判断 <code>Annotation</code>是否存在，如果存在，就直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法是直接读取 <code>Annotation</code>，如果 <code>Annotation</code>不存在，将返回 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取方法、字段和构造方法的 <code>Annotation</code>和 <code>Class</code>类似。但要读取方法参数的 <code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要读取方法参数的注解，我们先用反射获取 <code>Method</code>实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line">Method m = ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        Range r = (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        NotNull n = (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用注解-2">使用注解</h3>
<p>注解如何使用，完全由程序自己决定。例如，<code>JUnit</code>是一个测试框架，它会自动运行所有标记为 <code>@Test</code>的方法。</p>
<p>我们来看一个 <code>@Range</code>注解，我们希望用它来定义一个 <code>String</code>字段的规则：字段长度满足 <code>@Range</code>的参数定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查 <code>Person</code>实例的 <code>String</code>字段长度是否满足 <code>@Range</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们通过 <code>@Range</code>注解，配合 <code>check()</code>方法，就可以完成 <code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h1>泛型</h1>
<p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p>
<h2 id="什么是泛型">什么是泛型</h2>
<p>在讲解什么是泛型之前，我们先观察Java标准库提供的 <code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p>
<p>实际上 <code>ArrayList</code>内部就是一个 <code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用上述 <code>ArrayList</code>存储 <code>String</code>类型，会有这么几个缺点：</p>
<ul>
<li>需要强制转型；</li>
<li>不方便，易出错。</li>
</ul>
<p>例如，代码必须这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">很容易出现ClassCastException，因为容易“误转型”：</span><br><span class="line"></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>要解决上述问题，我们可以为 <code>String</code>单独编写一种 <code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringArrayList list = <span class="keyword">new</span> StringArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br></pre></td></tr></table></figure>
<p>问题暂时解决。</p>
<p>然而，新的问题是，如果要存储 <code>Integer</code>，还需要为 <code>Integer</code>单独编写一种ArrayList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，还需要为其他所有class单独编写一种ArrayList：</p>
<ul>
<li>LongArrayList</li>
<li>DoubleArrayList</li>
<li>PersonArrayList</li>
<li>…</li>
</ul>
<p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p>
<p>为了解决新的问题，我们必须把 <code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>可以是任何 <code>class</code>。这样一来，我们就实现了：编写一次模版，可以创建任意类型的 <code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure>
<p>因此，泛型就是定义一种模板，例如 <code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的 <code>ArrayList&lt;类型&gt;</code>：</p>
<blockquote>
<p>ArrayList<code>&lt;String&gt;</code> strList = new ArrayList<code>&lt;String&gt;</code>();</p>
</blockquote>
<p>由编译器针对类型作检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p>
<h3 id="向上转型-2">向上转型</h3>
<p>在Java标准库中的 <code>ArrayList&lt;T&gt;</code>实现了 <code>List&lt;T&gt;</code>接口，它可以向上转型为 <code>List&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>即类型 <code>ArrayList&lt;T&gt;</code>可以向上转型为 <code>List&lt;T&gt;</code>。</p>
<p>要特别注意：不能把 <code>ArrayList&lt;Integer&gt;</code>向上转型为 <code>ArrayList&lt;Number&gt;</code>或 <code>List&lt;Number&gt;</code>。</p>
<p>这是为什么呢？假设 <code>ArrayList&lt;Integer&gt;</code>可以向上转型为 <code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> Float(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line">Integer n = integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure>
<p>我们把一个 <code>ArrayList&lt;Integer&gt;</code>转型为 <code>ArrayList&lt;Number&gt;</code>类型后，这个 <code>ArrayList&lt;Number&gt;</code>就可以接受Float类型，因为Float是Number的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和 <code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是 <code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受Float类型， 所以在获取Integer的时候将产生 <code>ClassCastException</code>。</p>
<p>实际上，编译器为了避免这种错误，根本就不允许把 <code>ArrayList&lt;Integer&gt;</code>转型为 <code>ArrayList&lt;Number&gt;</code>。</p>
<h2 id="使用泛型">使用泛型</h2>
<p>使用 <code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是 <code>Object</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>此时，只能把 <code>&lt;T&gt;</code>当作 <code>Object</code>使用，没有发挥泛型的优势。</p>
<p>当我们定义泛型类型 <code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型 <code>List&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>当我们定义泛型类型 <code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型 <code>List&lt;Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br><span class="line">Number first = list.get(<span class="number">0</span>);</span><br><span class="line">Number second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p>
<blockquote>
<p>List<code>&lt;Number&gt;</code> list = new ArrayList<code>&lt;Number&gt;</code>();</p>
</blockquote>
<p>编译器看到泛型类型 <code>List&lt;Number&gt;</code>就可以自动推断出后面的 <code>ArrayList&lt;T&gt;</code>的泛型类型必须是 <code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口">泛型接口</h3>
<p>除了 <code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现 <code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接对 <code>String</code>数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(ss);</span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为 <code>String</code>本身已经实现了 <code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的 <code>Person</code>类型试试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将 <code>Person</code>转型为 <code>Comparable</code>。我们修改代码，让 <code>Person</code>实现 <code>Comparable&lt;T&gt;</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Alice,88, Bob,61, Lily,75]</span></span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以正确实现按 <code>name</code>进行排序。</p>
<p>也可以修改比较逻辑，例如，按 <code>score</code>从高到低排序。请自行修改测试。</p>
<h2 id="编写泛型">编写泛型</h2>
<p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如 <code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p>
<p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p>
<p>可以按照以下步骤来编写一个泛型类。</p>
<p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，标记所有的特定类型，这里是 <code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，把特定类型 <code>String</code>替换为 <code>T</code>，并申明 <code>&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟练后即可直接从T开始编写。</p>
<h3 id="静态方法-2">静态方法</h3>
<p>编写泛型类时，要特别注意，泛型类型 <code>&lt;T&gt;</code>不能用于静态方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。</p>
<p>有些同学在网上搜索发现，可以在 <code>static</code>修饰符后面加一个 <code>&lt;T&gt;</code>，编译就能通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上，这个 <code>&lt;T&gt;</code>和 <code>Pair&lt;T&gt;</code>类型的 <code>&lt;T&gt;</code>已经没有任何关系了。</p>
<p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的 <code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p>
<h3 id="多个泛型类型">多个泛型类型</h3>
<p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;<code>T, K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，需要指出两种类型：</p>
<blockquote>
<p>Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(“test”, 123);</p>
</blockquote>
<p>Java标准库的 <code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>
<h2 id="擦拭法">擦拭法</h2>
<p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p>
<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>例如，我们编写了一个泛型类 <code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure>
<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure>
<p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为 <code>Object</code>处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p>
<p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p>
<p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如 <code>int</code>，因为实际类型是 <code>Object</code>，<code>Object</code>类型无法持有基本类型：</p>
<p>局限二：无法取得带泛型的Class。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为T是Object，我们对Pair<code>&lt;String&gt;</code>和Pair<code>&lt;Integer&gt;</code>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</p>
<p>换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<code>&lt;Object&gt;</code>。</p>
<p>局限三：无法判断带泛型的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因和前面一样，并不存在 <code>Pair&lt;String&gt;.class</code>，而是只有唯一的 <code>Pair.class</code>。</p>
<p>局限四：不能实例化 <code>T</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure>
<p>擦拭后实际上变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>这样一来，创建 <code>new Pair&lt;String&gt;()</code>和创建n <code>ew Pair&lt;Integer&gt;()</code>就全部成了Object，显然编译器要阻止这种类型不对的代码。</p>
<p>要实例化 <code>T</code>类型，我们必须借助额外的 <code>Class&lt;T&gt;</code>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码借助 <code>Class&lt;T&gt;</code>参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code>。例如：</p>
<blockquote>
<p>Pair<code>&lt;String&gt;</code> pair = new Pair&lt;&gt;(String.class);</p>
</blockquote>
<p>因为传入了 <code>Class&lt;String&gt;</code>的实例，所以我们借助 <code>String.class</code>就可以实例化 <code>String</code>类型。</p>
<h3 id="不恰当的覆写方法">不恰当的覆写方法</h3>
<p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为，定义的 <code>equals(T t)</code>方法实际上会被擦拭成 <code>equals(Object t)</code>，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p>
<p>换个方法名，避开与 <code>Object.equals(Object)</code>的冲突就可以成功编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">same</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型继承">泛型继承</h3>
<p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code>，子类的类型是 <code>IntPair</code>，可以这么继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，因为子类 <code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<blockquote>
<p>IntPair ip = new IntPair(1, 2);</p>
</blockquote>
<p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code>的T类型，即给定一个变量 <code>Pair&lt;Integer&gt; p</code>，无法从 <code>p</code>中获取到 <code>Integer</code>类型。</p>
<p>但是，在父类是泛型类型的情况下，编译器就必须把类型T（对 <code>IntPair</code>来说，也就是 <code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道 <code>IntPair</code>只能存取 <code>Integer</code>这种类型。</p>
<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Java引入了泛型，所以，只用Class来标识类型已经不够了。实际上，Java的类型系统结构如下：<br>
┌────┐<br>
│Type│<br>
└────┘<br>
▲<br>
│<br>
┌────────────┬────────┴─────────┬───────────────┐<br>
│            │                  │               │<br>
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐<br>
│Class││ParameterizedType││GenericArrayType││WildcardType│<br>
└─────┘└─────────────────┘└────────────────┘└────────────┘</p>
<h2 id="extends通配符">extends通配符</h2>
<p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是 <code>Pair&lt;Number&gt;</code>的子类。</p>
<p>假设我们定义了 <code>Pair&lt;T&gt;</code>：</p>
<blockquote>
<p>public class Pair<code>&lt;T&gt;</code> { … }</p>
</blockquote>
<p>然后，我们又针对 <code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是 <code>Pair&lt;Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>
<blockquote>
<p>int sum = PairHelper.add(new Pair<code>&lt;Number&gt;</code>(1, 2));</p>
</blockquote>
<p>注意：传入的类型是 <code>Pair&lt;Number&gt;</code>，实际参数类型是 <code>(Integer, Integer)</code>。</p>
<p>既然实际参数是 <code>Integer</code>类型，试试传入 <code>Pair&lt;Integer&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接运行，会得到一个编译错误：</p>
<blockquote>
<p>incompatible types: Pair<code>&lt;Integer&gt;</code> cannot be converted to Pair<code>&lt;Number&gt;</code></p>
</blockquote>
<p>原因很明显，因为 <code>Pair&lt;Integer&gt;</code>不是 <code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型 <code>Pair&lt;Integer&gt;</code>。</p>
<p>但是从 <code>add()</code>方法的代码可知，传入 <code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p>
<blockquote>
<p>Number first = p.getFirst();<br>
Number last = p.getLast();</p>
</blockquote>
<p>实际类型是 <code>Integer</code>，引用类型是 <code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入 <code>Pair&lt;Number&gt;</code>。</p>
<p>有没有办法使得方法参数接受 <code>Pair&lt;Integer&gt;</code>？办法是有的，这就是使用 <code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为 <code>Number</code>或 <code>Number</code>子类的 <code>Pair</code>类型。我们把代码改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，给方法传入 <code>Pair&lt;Integer&gt;</code>类型时，它符合参数 <code>Pair&lt;? extends Number&gt;</code>类型。这种使用 <code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型 <code>T</code>的上界限定在 <code>Number</code>了。</p>
<p>除了可以传入 <code>Pair&lt;Integer&gt;</code>类型，我们还可以传入 <code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为 <code>Double</code>和 <code>BigDecimal</code>都是Number的子类。</p>
<p>如果我们考察对 <code>Pair&lt;? extends Number&gt;</code>类型调用 <code>getFirst()</code>方法，实际的方法签名变成了：</p>
<blockquote>
<? extends Number> getFirst();
</blockquote>
<p>即返回值是 <code>Number</code>或 <code>Number</code>的子类，因此，可以安全赋值给 <code>Number</code>类型的变量：</p>
<blockquote>
<p>Number x = p.getFirst();</p>
</blockquote>
<p>然后，我们不可预测实际类型就是 <code>Integer</code>，例如，下面的代码是无法通过编译的：</p>
<blockquote>
<p>Integer x = p.getFirst();</p>
</blockquote>
<p>这是因为实际的返回类型可能是 <code>Integer</code>，也可能是 <code>Double</code>或者其他类型，编译器只能确定类型一定是 <code>Number</code>的子类（包括 <code>Number</code>类型本身），但具体类型无法确定。</p>
<p>我们再来考察一下 <code>Pair&lt;T&gt;</code>的 <code>set</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        p.setFirst(<span class="keyword">new</span> Integer(first.intValue() + <span class="number">100</span>));</span><br><span class="line">        p.setLast(<span class="keyword">new</span> Integer(last.intValue() + <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出意外，我们会得到一个编译错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">incompatible types: Integer cannot be converted to CAP#<span class="number">1</span></span><br><span class="line">where CAP#<span class="number">1</span> is a fresh type-variable:</span><br><span class="line">    CAP#<span class="number">1</span> extends Number from capture of ? extends Number</span><br></pre></td></tr></table></figure>
<p>编译错误发生在 <code>p.setFirst()</code>传入的参数是Integer类型。有些童鞋会问了，既然p的定义是 <code>Pair&lt;? extends Number&gt;</code>，那么 <code>setFirst(? extends Number)</code>为什么不能传入Integer？</p>
<p>原因还在于擦拭法。如果我们传入的 <code>p</code>是 <code>Pair&lt;Double&gt;</code>，显然它满足参数定义 <code>Pair&lt;? extends Number</code>&gt;，然而，<code>Pair&lt;Double&gt;</code>的setFirst()显然无法接受Integer类型。</p>
<p>这就 <code>是&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名 <code>setFirst(? extends Number)</code>无法传递任何Number的子类型给 <code>setFirst(? extends Number)</code>。</p>
<p>这里唯一的例外是可以给方法参数传入 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.setFirst(<span class="keyword">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure>
<h3 id="extends通配符的作用">extends通配符的作用</h3>
<p>如果我们考察Java标准库的 <code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 获取个数</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 根据索引获取指定元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>; <span class="comment">// 添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span></span>; <span class="comment">// 删除一个已有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，让我们定义一个方法来处理列表的每个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">        Integer n = list.get(i);</span><br><span class="line">        sum = sum + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么我们定义的方法参数类型是 <code>List&lt;? extends Integer&gt;</code>而不是 <code>List&lt;Integer&gt;</code>？从方法内部代码看，传入 <code>List&lt;? extends Integer&gt;</code>或者 <code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到 <code>List&lt;? extends Integer&gt;</code>的限制：</p>
<ul>
<li>允许调用<code>get()</code>方法获取Integer的引用；</li>
<li>不允许调用<code>set(? extends Integer)</code>方法并传入任何Integer的引用（null除外）。</li>
</ul>
<p>因此，方法参数类型 <code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取 <code>List</code>的元素，不会修改 <code>List</code>的元素（因为无法调用 <code>add(? extends Integer)、remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数 <code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用 <code>set(null)</code>除外）。</p>
<h3 id="使用extends限定T类型">使用extends限定T类型</h3>
<p>在定义泛型类型 <code>Pair&lt;T&gt;</code>的时候，也可以使用extends通配符来限定T的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们只能定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Number&gt; p1 = <span class="keyword">null</span>;</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Pair&lt;Double&gt; p3 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Number</code>、<code>Integer</code>和 <code>Double</code>都符合 <code>&lt;T extends Number&gt;</code>。</p>
<p>非 <code>Number</code>类型将无法通过编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br><span class="line">Pair&lt;Object&gt; p2 = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>String</code>、<code>Object</code>都不符合 <code>&lt;T extends Number&gt;</code>，因为它们不是 <code>Number</code>类型或 <code>Number</code>的子类。</p>
<h1>集合</h1>
<p>本节我们将介绍Java的集合类型。集合类型也是Java标准库中被使用最多的类型。</p>
<h2 id="Java集合简介">Java集合简介</h2>
<p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。例如，5只小兔构成的集合：</p>
<p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</p>
<p>│   (_(\     (_/)     (_/)     (_/)      ((\   │<br>
( -.-)    (•.•)     (&gt;.&lt;)     (^.^)     (=‘.’)<br>
│  C(“)<em>(“)  (”)</em>(”)   (“)<em>(“)   (”)</em>(”)   O(_“)”)  │</p>
<p>└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘<br>
在数学中，我们经常遇到集合的概念。例如：</p>
<ul>
<li>
<p>有限集合：</p>
<ul>
<li>一个班所有的同学构成的集合；</li>
<li>一个网站所有的商品构成的集合；</li>
<li>…</li>
</ul>
</li>
<li>
<p>无限集合：</p>
<ul>
<li>全体自然数集合：1，2，3，……</li>
<li>有理数集合；</li>
<li>实数集合；</li>
<li>…</li>
</ul>
</li>
</ul>
<p>为什么要在计算机中引入集合呢？这是为了便于处理一组类似的数据，例如：</p>
<ul>
<li>计算所有同学的总成绩和平均成绩；</li>
<li>列举所有的商品名称和价格；</li>
<li>……</li>
</ul>
<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line">String first = ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>
<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
<li>数组初始化后大小不可变；</li>
<li>数组只能按索引顺序存取。</li>
</ul>
<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
<li>可变大小的顺序链表；</li>
<li>保证无重复元素的集合；</li>
<li>…</li>
</ul>
<h3 id="Collection">Collection</h3>
<p>Java标准库自带的 <code>java.util</code>包提供了集合类：<code>Collection</code>，它是除Map外所有其他集合类的根接口。Java的 <code>java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（<code>key-value</code>）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是 <code>List</code>，具体的实现类有 <code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<blockquote>
<p>List<code>&lt;String&gt;</code> list = new ArrayList&lt;&gt;(); // 只能放入String类型</p>
</blockquote>
<p>最后，Java访问集合总是通过统一的方式——迭代器（<code>Iterator</code>）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
<h2 id="使用List">使用List</h2>
<p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p>
<p><code>List</code>的行为和数组几乎完全相同：List内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从 <code>0</code>开始。</p>
<p>数组和 <code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组 <code>&#123;'A', 'B', 'C', 'D', 'E'&#125;</code>中删除索引为2的元素：</p>
<p>┌───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ C │ D │ E │   │<br>
└───┴───┴───┴───┴───┴───┘<br>
│   │<br>
┌───┘   │<br>
│   ┌───┘<br>
│   │<br>
▼   ▼<br>
┌───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ D │ E │   │   │<br>
└───┴───┴───┴───┴───┴───┘<br>
这个“删除”操作实际上是把 <code>'C'</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p>
<p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是 <code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个 <code>ArrayList</code>拥有5个元素，实际数组大小为6（即有一个空位）：</p>
<p>size=5<br>
┌───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ C │ D │ E │   │<br>
└───┴───┴───┴───┴───┴───┘<br>
当添加一个元素并指定索引到 <code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p>
<p>size=5<br>
┌───┬───┬───┬───┬───┬───┐<br>
│ A │ B │   │ C │ D │ E │<br>
└───┴───┴───┴───┴───┴───┘<br>
然后，往内部指定索引的数组位置添加一个元素，然后把 <code>size</code>加 <code>1</code>：</p>
<p>size=6<br>
┌───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ F │ C │ D │ E │<br>
└───┴───┴───┴───┴───┴───┘<br>
继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p>
<p>size=6<br>
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br>
现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时 <code>size</code>加 <code>1</code>：</p>
<p>size=7<br>
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>
│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br>
可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。</p>
<p>我们考察 <code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>但是，实现 <code>List</code>接口并非只能通过数组（即 <code>ArrayList</code>的实现方式）来实现，另一种 <code>LinkedList</code>通过“链表”也实现了 <code>List</code>接口。在 <code>LinkedList</code>中，它的内部每个元素都指向下一个元素：<br>
┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>
HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>
└───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br>
我们来比较一下 <code>ArrayList</code>和 <code>LinkedList</code>：</p>
<p>|ArrayList|LinkedList|<br>
|获取指定元素|速度很快|需要从头开始查找元素|<br>
|添加元素到末尾|速度很快|速度很快|<br>
|在指定位置添加/删除|需要移动元素|不需要移动元素|<br>
|内存占用|少|较大|</p>
<p>通常情况下，我们总是优先使用 <code>ArrayList</code>。</p>
<h3 id="List的特点">List的特点</h3>
<p>使用List时，我们要关注List接口的规范。List接口允许我们添加重复的元素，即List内部的元素可以重复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 允许重复添加元素，size=3</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>List</code>还允许添加 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="keyword">null</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=3</span></span><br><span class="line">        String second = list.get(<span class="number">1</span>); <span class="comment">// null</span></span><br><span class="line">        System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建List">创建List</h3>
<p>除了使用 <code>ArrayList</code>和 <code>LinkedList</code>，我们还可以通过 <code>List</code>接口提供的 <code>of()</code>方法，根据给定元素快速创建 <code>List</code>：</p>
<blockquote>
<p>List<code>&lt;Integer&gt;</code> list = List.of(1, 2, 5);</p>
</blockquote>
<p>但是 <code>List.of()</code>方法不接受 <code>null</code>值，如果传入 <code>null</code>，会抛出 <code>NullPointerException</code>异常。</p>
<h3 id="遍历List">遍历List</h3>
<p>和数组类型，我们要遍历一个 <code>List</code>，完全可以用 <code>for</code>循环根据索引配合·方法遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种方式并不推荐，一是代码复杂，二是因为 <code>get(int)</code>方法只有 <code>ArrayList</code>的实现是高效的，换成 <code>LinkedList</code>后，索引越大，访问速度越慢。</p>
<p>所以我们要始终坚持使用迭代器 <code>Iterator</code>来访问 <code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由 <code>List</code>的实例调用 <code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个 <code>List</code>，并且不同的 <code>List</code>类型，返回的 <code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p>
<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用 <code>Iterator</code>遍历 <code>List</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有童鞋可能觉得使用 <code>Iterator</code>访问 <code>List</code>的代码比使用索引更复杂。但是，要记住，通过 <code>Iterator</code>遍历 <code>List</code>永远是最高效的方式。并且，由于 <code>Iterator</code>遍历是如此常用，所以，Java的 <code>for each</code>循环本身就可以帮我们使用 <code>Iterator</code>遍历。把上面的代码再改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是我们编写遍历 <code>List</code>的常见代码。</p>
<p>实际上，只要实现了 <code>Iterable</code>接口的集合类都可以直接用 <code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把 <code>for each</code>循环变成 <code>Iterator</code>的调用，原因就在于 <code>Iterable</code>接口定义了一个 <code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个 <code>Iterator</code>实例。</p>
<h3 id="List和Array转换">List和Array转换</h3>
<p>把 <code>List</code>变为 <code>Array</code>有三种方法，第一种是调用 <code>toArray()</code>方法直接返回一个 <code>Object[]</code>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        Object[] array = list.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法会丢失类型信息，所以实际应用很少。</p>
<p>第二种方式是给 <code>toArray(T[])</code>传入一个类型相同的 <code>Array</code>，<code>List</code>内部自动把元素复制到传入的 <code>Array</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这个 <code>toArray(T[])</code>方法的泛型参数 <code>&lt;T&gt;</code>并不是 <code>List</code>接口定义的泛型参数 <code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入 <code>Number</code>类型的数组，返回的仍然是 <code>Number</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Number[] array = list.toArray(<span class="keyword">new</span> Number[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于List的元素是 <code>Integer</code>，所以无法放入 <code>String</code>数组，这个方法会抛出 <code>ArrayStoreException</code>。</p>
<p>如果我们传入的数组大小和 <code>List</code>实际的  元素个数不一致怎么办？根据<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray%28T%5B%5D%29">List接口</a>的文档，我们可以知道：</p>
<p>如果传入的数组不够大，那么 <code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比 <code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充 <code>null</code>。</p>
<p>实际上，最常用的是传入一个“恰好”大小的数组：</p>
<blockquote>
<p>Integer[] array = list.toArray(new Integer[list.size()]);</p>
</blockquote>
<p>最后一种更简洁的写法是通过 <code>List</code>接口定义的 <code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p>
<blockquote>
<p>Integer[] array = list.toArray(Integer[]::new);</p>
</blockquote>
<p>这种函数式写法我们会在后续讲到。</p>
<p>反过来，把Array变为List就简单多了，通过 <code>List.of(T...)</code>方法最简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>
<p>对于JDK 11之前的版本，可以使用 <code>Arrays.asList(T...)</code>方法把数组转换成List。</p>
<p>要注意的是，返回的List不一定就是 <code>ArrayList</code>或者 <code>LinkedList</code>，因为List只是一个接口，如果我们调用 <code>List.of()</code>，它返回的是一个只读List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        list.add(<span class="number">999</span>); <span class="comment">// UnsupportedOperationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对只读 <code>List</code>调用 <code>add()</code>、<code>remove()</code>方法会抛出 <code>UnsupportedOperationException</code>。</p>
<h2 id="编写equals方法">编写equals方法</h2>
<p>我们知道 <code>List</code>是一种有序链表：<code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。</p>
<p>List还提供了 <code>boolean contains(Object o)</code>方法来判断 <code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回 <code>-1</code>。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;C&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;X&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;X&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们注意一个问题，我们往 <code>List</code>中添加的 <code>&quot;C&quot;</code>和调用 <code>contains(&quot;C&quot;)</code>传入的 <code>&quot;C&quot;</code>是不是同一个实例？</p>
<p>如果这两个 <code>&quot;C&quot;</code>不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> String(<span class="string">&quot;C&quot;</span>))); <span class="comment">// true or false?</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="keyword">new</span> String(<span class="string">&quot;C&quot;</span>))); <span class="comment">// 2 or -1?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们传入的是 <code>new String(&quot;C&quot;)</code>，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？</p>
<p>因为List内部并不是通过 <code>==</code>判断两个元素是否相等，而是使用 <code>equals()</code>方法判断两个元素是否相等，例如 <code>contains()</code>方法可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementData.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，要正确使用 <code>List</code>的 <code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写 <code>equals()</code>方法，否则，放进去的实例，查找不到。我们之所以能正常放入 <code>String</code>、<code>Integer</code>这些对象，是因为Java标准库定义的这些类已经正确实现了 <code>equals()</code>方法。</p>
<p>我们以 <code>Person</code>对象为例，测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出意外，虽然放入了 <code>new Person(&quot;Bob&quot;)</code>，但是用另一个 <code>new Person(&quot;Bob&quot;)</code>查询不到，原因就是 <code>Person</code>类没有覆写 <code>equals()</code>方法。</p>
<h3 id="编写equals">编写equals</h3>
<p>如何正确编写 <code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的x来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的x和y来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的x、y和z来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么x.equals(z)也必须为true；</li>
<li>一致性（Consistent）：对于非<code>null</code>的x和y来说，只要x和y状态不变，则<code>x.equals(y)</code>总是一致地返回true或者<code>false</code>；</li>
<li>对null的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
<p>上述规则看上去似乎非常复杂，但其实代码实现 <code>equals()</code>方法是很简单的，我们以 <code>Person</code>类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们要定义“相等”的逻辑含义。对于 <code>Person</code>类，如果 <code>name</code>相等，并且age相等，我们就认为两个 <code>Person</code>实例相等。</p>
<p>因此，编写 <code>equals()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于引用字段比较，我们使用 <code>equals()</code>，对于基本类型字段的比较，我们使用 <code>==</code>。</p>
<p>如果 <code>this.name</code>为 <code>null</code>，那么 <code>equals()</code>方法会报错，因此，需要继续改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">boolean</span> nameEquals = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; p.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nameEquals &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用 <code>Objects.equals()</code>静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们总结一下 <code>equals()</code>方法的正确编写方法：</p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<p>使用 <code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断 <code>null</code>的麻烦。两个引用类型都是 <code>null</code>时它们也是相等的。</p>
<p>如果不调用 <code>List</code>的 <code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现 <code>equals()</code>方法。</p>
<h2 id="使用Map">使用Map</h2>
<p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生 <code>Student</code>实例的 <code>List</code>，要在 <code>List</code>中根据 <code>name</code>查找某个指定的 <code>Student</code>的分数，应该怎么办？</p>
<p>最简单的方法是遍历 <code>List</code>并判断 <code>name</code>是否相等，然后返回指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; list = ...</span><br><span class="line">Student target = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;Xiao Ming&quot;</span>.equals(s.name)) &#123;</span><br><span class="line">        target = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(target.score);</span><br></pre></td></tr></table></figure>
<p>这种需求其实非常常见，即通过一个键去查询对应的值。使用 <code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而 <code>Map</code>这种键值 <code>（key-value）</code>映射表的数据结构，作用就是能高效通过 <code>key</code>快速查找 <code>value</code>（元素）。</p>
<p>用 <code>Map</code>来实现根据 <code>name</code>查询某个 <code>Student</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">        Student target = map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        Student another = map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用 <code>put(K key, V value)</code>方法时，就把 <code>key</code>和 <code>value</code>做了映射并放入Map。当我们调用 <code>V get(K key)</code>时，就可以通过 <code>key</code>获取到对应的 <code>value</code>。如果 <code>key</code>不存在，则返回 <code>null</code>。和 <code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是 <code>HashMap</code>。</p>
<p>如果只是想查询某个 <code>key</code>是否存在，可以调用 <code>boolean containsKey(K key)</code>方法。</p>
<p>如果我们在存储Map映射关系的时候，对同一个 <code>key</code>调用两次 <code>put()</code>方法，分别放入不同的 <code>value</code>，会有什么问题呢？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">789</span>); <span class="comment">// 再次放入apple作为key，但value变为789</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 789</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复放入 <code>key-value</code>并不会有任何问题，但是一个 <code>key</code>只能关联一个 <code>value</code>。在上面的代码中，一开始我们把 <code>key</code>对象 <code>&quot;apple&quot;</code>映射到 <code>Integer</code>对象 <code>123</code>，然后再次调用 <code>put()</code>方法把 <code>&quot;apple&quot;</code>映射到 <code>789</code>，这时，原来关联的 <code>value</code>对象 <code>123</code>就被“冲掉”了。实际上，<code>put()</code>方法的签名是 <code>V put(K key, V value)</code>，如果放入的 <code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的 <code>value</code>，否则，返回 <code>null</code>。</p>
<div class="note warning simple"><p>始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉.</p>
</div>
<p>此外，在一个 <code>Map</code>中，虽然 <code>key</code>不能重复，但 <code>value</code>是可以重复的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">123</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历Map">遍历Map</h3>
<p>对 <code>Map</code>来说，要遍历 <code>key</code>可以使用 <code>for each</code>循环遍历 <code>Map</code>实例的 <code>keySet()</code>方法返回的 <code>Set</code>集合，它包含不重复的 <code>key</code>的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时遍历 <code>key</code>和 <code>value</code>可以使用 <code>for each</code>循环遍历 <code>Map</code>对象的 <code>entrySet()</code>集合，它包含每一个 <code>key-value</code>映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Map</code>和 <code>List</code>不同的是，<code>Map</code>存储的是 <code>key-value</code>的映射关系，并且，它 <code>不保证顺序</code>。在遍历的时候，遍历的顺序既不一定是 <code>put()</code>时放入的 <code>key</code>的顺序，也不一定是 <code>key</code>的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以 <code>HashMap</code>为例，假设我们放入 <code>&quot;A&quot;，&quot;B&quot;，&quot;C&quot;</code>这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的</p>
<div class="note warning simple"><p>遍历Map时，不可假设输出的key是有序的！</p>
</div>
<h2 id="编写equals和hashCode">编写equals和hashCode</h2>
<p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p>
<p>以HashMap为例，观察下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Jun&quot;</span>));</span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>); <span class="comment">// Person(&quot;Xiao Ming&quot;)</span></span><br><span class="line">map.get(<span class="string">&quot;x&quot;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><code>HashMap</code>之所以能根据 <code>key</code>直接拿到 <code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有 <code>value</code>，并根据key直接计算出 <code>value</code>应该存储在哪个索引：</p>
<p>┌───┐<br>
0 │   │<br>
├───┤<br>
1 │ ●─┼───&gt; Person(“Xiao Ming”)<br>
├───┤<br>
2 │   │<br>
├───┤<br>
3 │   │<br>
├───┤<br>
4 │   │<br>
├───┤<br>
5 │ ●─┼───&gt; Person(“Xiao Hong”)<br>
├───┤<br>
6 │ ●─┼───&gt; Person(“Xiao Jun”)<br>
├───┤<br>
7 │   │<br>
└───┘<br>
如果 <code>key</code>的值为 <code>&quot;a&quot;</code>，计算得到的索引总是 <code>1</code>，因此返回 <code>value</code>为 <code>Person(&quot;Xiao Ming&quot;)</code>，如果 <code>key</code>的值为 <code>&quot;b&quot;</code>，计算得到的索引总是5，因此返回 <code>value</code>为 <code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取 <code>key</code>对应的 <code>value</code>。</p>
<p>当我们使用 <code>key</code>存取 <code>value</code>的时候，就会引出一个问题：</p>
<p>我们放入Map的key是字符串 <code>&quot;a&quot;</code>，但是，当我们获取 <code>Map</code>的 <code>value</code>时，传入的变量不一定就是放入的那个key对象。</p>
<p>换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String key1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(key1, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        String key2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.get(key2); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        System.out.println(key1 == key2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(key1.equals(key2)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在 <code>Map</code>的内部，对 <code>key</code>做比较是通过 <code>equals()</code>实现的，这一点和List查找元素需要正确覆写 <code>equals()</code>是一样的，即正确使用 <code>Map</code>必须保证：作为 <code>key</code>的对象必须正确覆写 <code>equals()</code>方法。</p>
<p>我们经常使用 <code>String</code>作为 <code>key</code>，因为 <code>String</code>已经正确覆写了 <code>equals()</code>方法。但如果我们放入的 <code>key</code>是一个自己写的类，就必须保证正确覆写了 <code>equals()</code>方法。</p>
<p>我们再思考一下 <code>HashMap</code>为什么能通过 <code>key</code>直接计算出 <code>value</code>存储的索引。相同的 <code>key</code>对象（使用 <code>equals()</code>判断时返回 <code>true</code>）必须要计算出相同的索引，否则，相同的 <code>key</code>每次取出的 <code>value</code>就不一定对。</p>
<p>通过 <code>key</code>计算索引的方式就是调用 <code>key</code>对象的 <code>hashCode()</code>方法，它返回一个int整数。<code>HashMap</code>正是通过这个方法直接定位 <code>key</code>对应的 <code>value</code>的索引，继而直接返回 <code>value</code>。</p>
<p>因此，正确使用 <code>Map</code>必须保证：</p>
<ol>
<li>作为 <code>key</code>的对象必须正确覆写 <code>equals()</code>方法，相等的两个 <code>key</code>实例调用 <code>equals()</code>必须返回true；</li>
<li>作为key的对象还必须正确覆写 <code>hashCode()</code>方法，且 <code>hashCode()</code>方法要严格遵循以下规范：</li>
</ol>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
<p>即对应两个实例 <code>a</code>和 <code>b</code>：</p>
<ul>
<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>
<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>
</ul>
<p>上述第一条规范是正确性，必须保证实现，否则 <code>HashMap</code>不能正常工作。</p>
<p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的 <code>hashCode()</code>，会造成 <code>Map</code>内部存储冲突，使存取的效率下降。</p>
<p>正确编写 <code>equals()</code>的方法我们已经在编写 <code>equals</code>方法一节中讲过了，以 <code>Person</code>类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把需要比较的字段找出来：</p>
<ul>
<li>firstName</li>
<li>lastName</li>
<li>age</li>
</ul>
<p>然后，引用类型使用 <code>Objects.equals()</code>比较，基本类型使用==比较。</p>
<p>在正确实现 <code>equals()</code>的基础上，我们还需要正确实现 <code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的 <code>int</code>必须相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + age;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>String</code>类已经正确实现了 <code>hashCode()</code>方法，我们在计算 <code>Person</code>的 <code>hashCode()</code>时，反复使用 <code>31*h</code>，这样做的目的是为了尽量把不同的 <code>Person</code>实例的 <code>hashCode()</code>均匀分布到整个 <code>int</code>范围。</p>
<p>和实现 <code>equals()</code>方法遇到的问题类似，如果 <code>firstName</code>或 <code>lastName</code>为 <code>null</code>，上述代码工作起来就会抛 <code>NullPointerException</code>。为了解决这个问题，我们在计算 <code>hashCode()</code>的时候，经常借助 <code>Objects.hash()</code>来计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，编写 <code>equals()</code>和 <code>hashCode()</code>遵循的原则是：</p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在 <code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在 <code>hashCode()</code>中计算。</p>
<p>另外注意，对于放入 <code>HashMap</code>的 <code>value</code>对象，没有任何要求。</p>
<h3 id="延伸阅读-2">延伸阅读</h3>
<p>既然 <code>HashMap</code>内部使用了数组，通过计算 <code>key</code>的 <code>hashCode()</code>直接定位 <code>value</code>所在的索引，那么第一个问题来了：<code>hashCode()</code>返回的 <code>int</code>范围高达 <code>±21亿</code>，先不考虑负数，<code>HashMap</code>内部使用的数组得有多大？</p>
<p>实际上 <code>HashMap</code>初始化时默认的数组大小只有 <code>16</code>，任何key，无论它的hashCode()有多大，都可以简单地通过：</p>
<blockquote>
<p>int index = key.hashCode() &amp; 0xf; // 0xf = 15</p>
</blockquote>
<p>把索引确定在 <code>0～15</code>，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p>
<p>第二个问题：如果添加超过 <code>16</code>个 <code>key-value</code>到 <code>HashMap</code>，数组不够用了怎么办？</p>
<p>添加超过一定数量的 <code>key-value</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。例如，对长度为32的数组计算 <code>hashCode()</code>对应的索引，计算方式要改为：</p>
<blockquote>
<p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31</p>
</blockquote>
<p>由于扩容会导致重新分布已有的 <code>key-value</code>，所以，频繁扩容对 <code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为 <code>10000</code>个 <code>key-value</code>的 <code>HashMap</code>，更好的方式是创建 <code>HashMap</code>时就指定容量：</p>
<blockquote>
<p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);</p>
</blockquote>
<p>虽然指定容量是 <code>10000</code>，但HashMap内部的数组长度总是 <code>2n</code>，因此，实际数组长度被初始化为比 <code>10000</code>大的 <code>16384（214）</code>。</p>
<p>最后一个问题：如果不同的两个key，例如&quot;a&quot;和&quot;b&quot;，它们的hashCode()恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求hashCode()尽量不相等），那么，当我们放入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>时，由于计算出的数组索引相同，后面放入的 <code>&quot;Xiao Hong&quot;</code>会不会把 <code>&quot;Xiao Ming&quot;</code>覆盖了？</p>
<p>当然不会！使用 <code>Map</code>的时候，只要 <code>key</code>不相同，它们映射的 <code>value</code>就互不干扰。但是，在 <code>HashMap</code>内部，确实可能存在不同的key，映射到相同的 <code>hashCode()</code>，即相同的数组索引上，肿么办？</p>
<p>我们就假设 <code>&quot;a&quot;</code>和 <code>&quot;b&quot;</code>这两个key最终计算出的索引都是5，那么，在 <code>HashMap</code>的数组中，实际存储的不是一个 <code>Person</code>实例，而是一个 <code>List</code>，它包含两个 <code>Entry</code>，一个是 <code>&quot;a&quot;</code>的映射，一个是 <code>&quot;b&quot;</code>的映射：</p>
<p>┌───┐<br>
0 │   │<br>
├───┤<br>
1 │   │<br>
├───┤<br>
2 │   │<br>
├───┤<br>
3 │   │<br>
├───┤<br>
4 │   │<br>
├───┤<br>
5 │ ●─┼───&gt; <code>List&lt;Entry&lt;String, Person&gt;&gt;</code><br>
├───┤<br>
6 │   │<br>
├───┤<br>
7 │   │<br>
└───┘<br>
在查找的时候，例如：</p>
<blockquote>
<p>Person p = map.get(“a”);</p>
</blockquote>
<p><code>HashMap</code>内部通过 <code>&quot;a&quot;</code>找到的实际上是 <code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个 <code>List</code>，并找到一个 <code>Entry</code>，它的 <code>key</code>字段是 <code>&quot;a&quot;</code>，才能返回对应的 <code>Person</code>实例。</p>
<p>我们把不同的key具有相同的 <code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用 <code>List</code>存储 <code>hashCode()</code>相同的 <code>key-value</code>。显然，如果冲突的概率越大，这个 <code>List</code>就越长，<code>Map</code>的 <code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p>
<div class="note info simple"><p>如果两个对象不相等，则两个对象的 <code>hashCode()</code>尽量不要相等。</p>
</div>
<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高</p>
<h2 id="使用EnumMap">使用EnumMap</h2>
<p>因为 <code>HashMap</code>是一种通过对 <code>key</code>计算 <code>hashCode()</code>，通过空间换时间的方式，直接定位到 <code>value</code>所在的内部数组的索引，因此，查找效率非常高。</p>
<p>如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种 <code>EnumMap</code>，它在内部以一个非常紧凑的数组存储 <code>value</code>，并且根据 <code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算 <code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<p>我们以 <code>DayOfWeek</code>这个枚举类型为例，为它做一个“翻译”功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br><span class="line">        map.put(DayOfWeek.MONDAY, <span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.TUESDAY, <span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.WEDNESDAY, <span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.THURSDAY, <span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.FRIDAY, <span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SATURDAY, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SUNDAY, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>EnumMap</code>的时候，我们总是用 <code>Map</code>接口来引用它，因此，实际上把 <code>HashMap</code>和 <code>EnumMap</code>互换，在客户端看来没有任何区别。</p>
<h2 id="使用TreeMap">使用TreeMap</h2>
<p>我们已经知道，<code>HashMap</code>是一种以空间换时间的映射表，它的实现原理决定了内部的 <code>Key</code>是无序的，即遍历 <code>HashMap</code>的 <code>Key</code>时，其顺序是不可预测的（但每个 <code>Key</code>都会遍历一次且仅遍历一次）。</p>
<p>还有一种 <code>Map</code>，它在内部会对 <code>Key</code>进行排序，这种 <code>Map</code>就是 <code>SortedMap</code>。注意到 <code>SortedMap</code>是接口，它的实现类是 <code>TreeMap</code>。<br>
┌───┐<br>
│Map│<br>
└───┘<br>
▲<br>
┌────┴─────┐<br>
│          │<br>
┌───────┐ ┌─────────┐<br>
│HashMap│ │SortedMap│<br>
└───────┘ └─────────┘<br>
▲<br>
│<br>
┌─────────┐<br>
│ TreeMap │<br>
└─────────┘<br>
<code>SortedMap</code>保证遍历时以 <code>Key</code>的顺序来进行排序。例如，放入的 <code>Key</code>是 <code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是 <code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为 <code>String</code>默认按字母排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// apple, orange, pear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>TreeMap</code>时，放入的Key必须实现 <code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了 <code>Comparable</code>接口，因此可以直接作为 <code>Key</code>使用。作为Value的对象则没有任何要求。</p>
<p>如果作为Key的class没有实现 <code>Comparable</code>接口，那么，必须在创建 <code>TreeMap</code>时同时指定一个自定义排序算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果 <code>a&lt;b</code>，则返回负数，通常是 <code>-1</code>，如果 <code>a==b</code>，则返回 <code>0</code>，如果 <code>a&gt;b</code>，则返回正数，通常是 <code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p>
<p>从上述代码执行结果可知，打印的Key确实是按照Comparator定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个 <code>new Person(&quot;Bob&quot;)</code>作为Key，它会返回对应的Integer值2。</p>
<p>另外，注意到 <code>Person</code>类并未覆写 <code>equals()</code>和 <code>hashCode()</code>，因为 <code>TreeMap</code>不使用 <code>equals()</code>和 <code>hashCode()</code>。</p>
<p>我们来看一个稍微复杂的例子：这次我们定义了 <code>Student</code>类，并用分数 <code>score</code>进行排序，高分在前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">77</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Lily&quot;</span>, <span class="number">99</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>))); <span class="comment">// null?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    Student(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>for</code>循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的 <code>Key：new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为null！</p>
<p>这是怎么肥四？难道 <code>TreeMap</code>有问题？遇到 <code>TreeMap</code>工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p>
<p>在这个例子中，<code>TreeMap</code>出现问题，原因其实出在这个 <code>Comparator</code>上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>p1.score</code>和 <code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在 <code>p1.score</code>和 <code>p2.score</code>相等的时候，它并没有返回0！这就是为什么 <code>TreeMap</code>工作不正常的原因：<code>TreeMap</code>在比较两个 <code>Key</code>是否相等时，依赖 <code>Key</code>的 <code>compareTo()</code>方法或者 <code>Comparator.compare()</code>方法。在两个 <code>Key</code>相等时，必须返回0。因此，修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接借助 <code>Integer.compare(int, int)</code>也可以返回正确的比较结果。</p>
<h2 id="使用Properties">使用Properties</h2>
<p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 上次最后打开的文件:</span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line"># 自动保存文件的时间间隔:</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>配置文件的特点是，它的 <code>Key-Value</code>一般都是 <code>String-String</code>类型的，因此我们完全可以用 <code>Map&lt;String, String&gt;</code>来表示它。</p>
<p>因为配置文件非常常用，所以Java集合库提供了一个 <code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个Hashtable，但我们只需要用到 <code>Properties</code>自身关于读写配置的接口。</p>
<h3 id="读取配置文件">读取配置文件</h3>
<p>用 <code>Properties</code>读取配置文件非常简单。Java默认配置文件以 <code>.properties</code>为扩展名，每行以 <code>key=value</code>表示，以#课开头的是注释。以下是一个典型的配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>可以从文件系统读取这个 <code>.properties</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f = <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> java.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line">String filepath = props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line">String interval = props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可见，用 <code>Properties</code>读取配置文件，一共有三步：</p>
<ol>
<li>创建<code>Properties</code>实例；</li>
<li>调用<code>load()</code>读取文件；</li>
<li>调用<code>getProperty()</code>获取配置。</li>
</ol>
<p>调用 <code>getProperty()</code>获取配置时，如果 <code>key</code>不存在，将返回 <code>null</code>。我们还可以提供一个默认值，这样，当 <code>key</code>不存在的时候，就返回默认值。</p>
<p>也可以从 <code>classpath</code>读取 <code>.properties</code>文件，因为 <code>load(InputStream)</code>方法接收一个 <code>InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>试试从内存读取一个字节流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String settings = <span class="string">&quot;# test&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;course=Java&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;</span><br><span class="line">        ByteArrayInputStream input = <span class="keyword">new</span> ByteArrayInputStream(settings.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.load(input);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;course: &quot;</span> + props.getProperty(<span class="string">&quot;course&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_date&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_file&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="string">&quot;auto_save&quot;</span>, <span class="string">&quot;60&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// course: Java</span></span><br><span class="line"><span class="comment">// last_open_date: 2019-08-07T12:35:01</span></span><br><span class="line"><span class="comment">// last_open_file: null</span></span><br><span class="line"><span class="comment">// auto_save: 60</span></span><br></pre></td></tr></table></figure>
<p>如果有多个 <code>.properties</code>文件，可以反复调用 <code>load()</code>读取，后读取的 <code>key-value</code>会覆盖已读取的 <code>key-value</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line">props.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>上面的代码演示了 <code>Properties</code>的一个常用用法：可以把默认配置文件放到 <code>classpath</code>中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p>
<p><code>Properties</code>设计的目的是存储 <code>String</code>类型的 <code>key－value</code>，但 <code>Properties</code>实际上是从 <code>Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了 <code>getProperty()</code>和 <code>setProperty()</code>方法外，还有从 <code>Hashtable</code>继承下来的 <code>get()</code>和 <code>put()</code>方法，这些方法的参数签名是 <code>Object</code>，我们在使用 <code>Properties</code>的时候，不要去调用这些从 <code>Hashtable</code>继承下来的方法。</p>
<h3 id="写入配置文件">写入配置文件</h3>
<p>如果通过 <code>setProperty()</code>修改了 <code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用 <code>store()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="编码">编码</h3>
<p>早期版本的Java规定 <code>.properties</code>文件编码是 <code>ASCII编码（ISO8859-1）</code>，如果涉及到中文就必须用 <code>name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的 <code>.properties</code>文件可以使用UTF-8编码了。</p>
<p>不过，需要注意的是，由于 <code>load(InputStream)</code>默认总是以 <code>ASCII编码</code>读取字节流，所以会导致读到乱码。我们需要用另一个重载方法 <code>load(Reader)</code>读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>
<p>就可以正常读取中文。<code>InputStream</code>和 <code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。</p>
<h2 id="使用Set">使用Set</h2>
<p>我们知道，<code>Map</code>用于存储 <code>key-value</code>的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写 <code>equals()</code>方法，还要正确覆写 <code>hashCode()</code>方法。</p>
<p>如果我们只需要存储不重复的key，并不需要存储映射的 <code>value</code>，那么就可以使用 <code>Set</code>。</p>
<p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>我们来看几个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// false，添加失败，因为元素已存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true，元素存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;XYZ&quot;</span>)); <span class="comment">// false，元素不存在</span></span><br><span class="line">        System.out.println(set.remove(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// false，删除失败，因为元素不存在</span></span><br><span class="line">        System.out.println(set.size()); <span class="comment">// 2，一共两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set</code>实际上相当于只存储 <code>key</code>、不存储value的Map。我们经常用Set用于去除重复元素。</p>
<p>因为放入 <code>Set</code>的元素和Map的key类似，都要正确实现 <code>equals()</code>和 <code>hashCode()</code>方法，否则该元素无法正确地放入Set。</p>
<p>最常用的Set实现类是 <code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对 <code>HashMap</code>的一个简单封装，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set</code>接口并不保证有序，而 <code>SortedSet</code>接口则保证元素是有序的：</p>
<ul>
<li>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；</li>
<li>TreeSet是有序的，因为它实现了SortedSet接口。<br>
用一张图表示：<br>
┌───┐<br>
│Set│<br>
└───┘<br>
▲<br>
┌────┴─────┐<br>
│          │<br>
┌───────┐ ┌─────────┐<br>
│HashSet│ │SortedSet│<br>
└───────┘ └─────────┘<br>
▲<br>
│<br>
┌─────────┐<br>
│ TreeSet │<br>
└─────────┘<br>
我们来看<code>HashSet</code>的输出：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p>
<p>把 <code>HashSet</code>换成 <code>TreeSet</code>，在遍历 <code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>TreeSet</code>和使用 <code>TreeMap</code>的要求一样，添加的元素必须正确实现 <code>Comparable接口</code>，如果没有实现 <code>Comparable</code>接口，那么创建 <code>TreeSet</code>时必须传入一个 <code>Comparator对象</code>。</p>
<h2 id="使用Queue">使用Queue</h2>
<p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个 <code>先进先出（FIFO：First In First Out）</code>的 <code>有序表</code>。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
<p>超市的收银台就是一个队列：</p>
<p>在Java的标准库中，队列接口 <code>Queue</code>定义了以下几个方法：</p>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)/boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()/E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()/E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>
<p>对于具体的实现类，有的 <code>Queue</code>有最大队列长度限制，有的 <code>Queue</code>没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p>
<p>||throw Exception|返回false或null|<br>
||---------------|---------------|<br>
|添加元素到队尾|add(E e)|boolean offer(E e)|<br>
|取队首元素并删除|E remove()|E poll()|<br>
|取队首元素但不删除|E element()|E peek()|</p>
<p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    q.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们调用 <code>offer()</code>方法来添加元素，当添加失败时，它不会抛异常，而是返回 <code>false</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">if</span> (q.offer(<span class="string">&quot;Apple&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要从 <code>Queue</code>中取出队首元素时，如果当前 <code>Queue</code>是一个空队列，调用 <code>remove()</code>方法，它会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = q.remove();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们调用 <code>poll()</code>方法来取出队首元素，当获取失败时，它不会抛异常，而是返回 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line">String s = q.poll();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，两套方法可以根据需要来选择使用。</p>
<p>注意：不要把 <code>null</code>添加到队列中，否则 <code>poll()</code>方法返回 <code>null</code>时，很难确定是取到了 <code>null</code>元素还是队列为空。</p>
<p>接下来我们以 <code>poll()</code>和 <code>peek()</code>为例来说说“获取并删除”与“获取但不删除”的区别。对于 <code>Queue</code>来说，每次调用 <code>poll()</code>，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 从队列取出元素:</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列是空的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用 <code>peek()</code>，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 队首永远都是apple，因为peek()不会删除它:</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，我们还可以发现，<code>LinkedList</code>即实现了 <code>List接口</code>，又实现了 <code>Queue接口</code>，但是，在使用的时候，如果我们把它当作 <code>List</code>，就获取 <code>List</code>的引用，如果我们把它当作 <code>Queue</code>，就获取 <code>Queue</code>的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p>
<h2 id="使用PriorityQueue">使用PriorityQueue</h2>
<p>我们知道，<code>Queue</code>是一个先进先出（FIFO）的队列。</p>
<p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p>
<p>可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个 <code>Queue</code>。</p>
<p>如果这时来了一个VIP客户，他的号码是 <code>V1</code>，虽然当前排队的是 <code>A10</code>、<code>A11</code>、<code>A12</code>……但是柜台下一个呼叫的客户号码却是 <code>V1</code>。</p>
<p>这个时候，我们发现，要实现“VIP插队”的业务，用 <code>Queue</code>就不行了，因为 <code>Queue</code>会严格按 <code>FIFO</code>的原则取出队首元素。我们需要的是优先队列：<code>PriorityQueue</code>。</p>
<p><code>PriorityQueue</code>和 <code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对 <code>PriorityQueue</code>调用 <code>remove()</code>或 <code>poll()</code>方法，返回的总是优先级最高的元素。</p>
<p>要使用 <code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看 <code>PriorityQueue</code>的行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>们放入的顺序是 <code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是 <code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，&quot;apple&quot;排在最前面，&quot;pear&quot;排在最后面。</p>
<p>因此，放入 <code>PriorityQueue</code>的元素，必须实现 <code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>
<p>如果我们要放入的元素并没有实现 <code>Comparable</code>接口怎么办？<code>PriorityQueue</code>允许我们提供一个 <code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个 <code>PriorityQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">            <span class="comment">// return Integer.parseInt(u1.number.substring(1))-Integer.parseInt(u2.number.substring(1));</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现PriorityQueue的关键在于提供的 <code>UserComparator</code>对象，它负责比较两个元素的大小（较小的在前）。<code>UserComparator</code>总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p>
<p>上面的 <code>UserComparator</code>的比较逻辑其实还是有问题的，它会把 <code>A10</code>排在 <code>A2</code>的前面，请尝试修复该错误。</p>
<h2 id="使用Deque">使用Deque</h2>
<p>我们知道，Queue是队列，只能一头进，另一头出。</p>
<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫 <code>双端队列（Double Ended Queue）</code>，学名 <code>Deque</code>。</p>
<p>Java集合提供了接口 <code>Deque</code>来实现一个双端队列，它的功能是：</p>
<ul>
<li>既可以添加到队尾，也可以添加到队首；</li>
<li>既可以从队首获取，又可以从队尾获取。</li>
</ul>
<p>我们来比较一下Queue和Deque出队和入队的方法：</p>
<p>||Queue|Deque|<br>
||-----|-----|<br>
|添加元素到队尾|add(E e) / offer(E e)|addLast(E e) / offerLast(E e)|<br>
|取队首元素并删除|E remove() / E poll()|E removeFirst() / E pollFirst()|<br>
|取队首元素但不删除|E element() / E peek()|E getFirst() / E peekFirst()|<br>
|添加元素到队首|无|addFirst(E e) / offerFirst(E e)|<br>
|取队尾元素并删除|无|E removeLast() / E pollLast()|<br>
|取队尾元素但不删除|无|E getLast() / E peekLast()|</p>
<p>对于添加元素到队尾的操作，<code>Queue</code>提供了 <code>add()/offer()</code>方法，而 <code>Deque</code>提供了 <code>addLast()/offerLast()</code>方法。添加元素到对首、取队尾元素的操作在 <code>Queue</code>中不存在，在 <code>Deque</code>中由 <code>addFirst()/removeLast()</code>等方法提供。</p>
<p>注意到 <code>Deque</code>接口实际上扩展自 <code>Queue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>Queue</code>提供的 <code>add()/offer()</code>方法在Deque中也可以使用，但是，使用 <code>Deque</code>，最好不要调用 <code>offer()</code>，而是调用 <code>offerLast()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerLast(<span class="string">&quot;A&quot;</span>); <span class="comment">// A</span></span><br><span class="line">        deque.offerLast(<span class="string">&quot;B&quot;</span>); <span class="comment">// A &lt;- B</span></span><br><span class="line">        deque.offerFirst(<span class="string">&quot;C&quot;</span>); <span class="comment">// C &lt;- A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// C, 剩下A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollLast()); <span class="comment">// B, 剩下A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接写 <code>deque.offer()</code>，我们就需要思考，<code>offer()</code>实际上是 <code>offerLast()</code>，我们明确地写上 <code>offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p>
<p>因此，使用 <code>Deque</code>，推荐总是明确调用 <code>offerLast()/offerFirst()</code>或者 <code>pollFirst()/pollLast()</code>方法。</p>
<p><code>Deque</code>是一个接口，它的实现类有 <code>ArrayDeque和LinkedList</code>。</p>
<p>我们发现 <code>LinkedList</code>真是一个全能选手，它即是 <code>List</code>，又是 <code>Queue</code>，还是 <code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法:</span></span><br><span class="line">LinkedList&lt;String&gt; d1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d1.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="comment">// 推荐的写法：</span></span><br><span class="line">Deque&lt;String&gt; d2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d2.offerLast(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h2 id="使用Stack">使用Stack</h2>
<p><code>栈（Stack）</code>是一种后进先出（<code>LIFO：Last In First Out</code>）的数据结构。</p>
<p>什么是 <code>LIFO</code>呢？我们先回顾一下 <code>Queue</code>的特点 <code>FIFO</code>：<br>
────────────────────────<br>
((\      ((\    ((\    ((\      ((<br>
(=‘.’) ─&gt; (=‘.’)  (=‘.’)  (=‘.’) ─&gt; (=‘.’)<br>
O(<em>“)”)   O(</em>“)”) O(<em>“)”) O(</em>“)”)   O(<em>“)”)<br>
────────────────────────<br>
所谓 <code>FIFO</code>，是最先进队列的元素一定最早出队列，而 <code>LIFO</code>是最后进 <code>Stack</code>的元素一定最早出 <code>Stack</code>。如何做到这一点呢？只需要把队列的一端封死：<br>
───────────────────────────────┐<br>
((\       ((\    ((\    ((\    ((\ │<br>
(=‘.’) &lt;─&gt; (=‘.’)  (=‘.’)  (=‘.’)  (=‘.’)│<br>
O(</em>“)”)    O(<em>“)”) O(</em>“)”) O(<em>“)”) O(</em>“)”)│<br>
───────────────────────────────┘<br>
因此，<code>Stack</code>是这样一种数据结构：只能不断地往 <code>Stack</code>中压入（<code>push</code>）元素，最后进去的必须最早弹出（<code>pop</code>）来：</p>
<p><code>Stack</code>只有入栈和出栈的操作：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>。</li>
</ul>
<p>在Java中，我们用 <code>Deque</code>可以实现 <code>Stack</code>的功能：</p>
<ul>
<li>把元素压栈：<code>push(E)/addFirst(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()/removeFirst()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()/peekFirst()</code>。</li>
</ul>
<p>为什么Java的集合类没有单独的 <code>Stack</code>接口呢？因为有个遗留类名字就叫 <code>Stack</code>，出于兼容性考虑，所以没办法创建 <code>Stack</code>接口，只能用 <code>Deque接口</code>来“模拟”一个 <code>Stack</code>了。</p>
<p>当我们把 <code>Deque</code>作为 <code>Stack</code>使用时，注意只调用 <code>push()/pop()/peek()</code>方法，不要调用 <code>addFirst()/removeFirst()/peekFirst()</code>方法，这样代码更加清晰。</p>
<h3 id="Stack的作用">Stack的作用</h3>
<p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">foo</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;F-&quot;</span> + bar(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p>
<p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发 <code>StackOverflowError</code>：</p>
<p>我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。</p>
<p>例如，我们要把一个int整数12500转换为十六进制表示的字符串，如何实现这个功能？</p>
<p>首先我们准备一个空栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
└───┘<br>
然后计算12500÷16=781…4，余数是 <code>4</code>，把余数 <code>4</code>压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│ 4 │<br>
└───┘<br>
然后计算781÷16=48…13，余数是13，<code>13</code>的十六进制用字母 <code>D</code>表示，把余数 <code>D</code>压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│ D │<br>
│   │<br>
│ 4 │<br>
└───┘<br>
然后计算48÷16=3…0，余数是 <code>0</code>，把余数 <code>0</code>压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│ 0 │<br>
│   │<br>
│ D │<br>
│   │<br>
│ 4 │<br>
└───┘<br>
最后计算3÷16=0…3，余数是3，把余数3压栈：</p>
<p>│   │<br>
│ 3 │<br>
│   │<br>
│ 0 │<br>
│   │<br>
│ D │<br>
│   │<br>
│ 4 │<br>
└───┘<br>
当商是 <code>0</code>的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串 <code>30D4</code>，这就是十进制整数12500的十六进制表示的字符串。</p>
<h3 id="计算中缀表达式">计算中缀表达式</h3>
<p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：<code>1 + 2 * (9 - 5)</code>。</p>
<p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：<code>1 2 9 5 - * +</code>。</p>
<p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p>
<p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
└───┘<br>
然后我们依次扫描后缀表达式1 2 9 5 - * +，遇到数字1，就直接扔到栈里：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│ 1 │<br>
└───┘<br>
紧接着，遇到数字2，9，5，也扔到栈里：</p>
<p>│   │<br>
│ 5 │<br>
│   │<br>
│ 9 │<br>
│   │<br>
│ 2 │<br>
│   │<br>
│ 1 │<br>
└───┘<br>
接下来遇到减号时，弹出栈顶的两个元素，并计算9-5=4，把结果4压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│ 4 │<br>
│   │<br>
│ 2 │<br>
│   │<br>
│ 1 │<br>
└───┘<br>
接下来遇到 <code>*</code>号时，弹出栈顶的两个元素，并计算2*4=8，把结果8压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│ 8 │<br>
│   │<br>
│ 1 │<br>
└───┘<br>
接下来遇到+号时，弹出栈顶的两个元素，并计算1+8=9，把结果9压栈：</p>
<p>│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│   │<br>
│ 9 │<br>
└───┘<br>
扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果9。</p>
<h2 id="使用Iterator">使用Iterator</h2>
<p>Java的集合类都可以使用 <code>for each</code>循环，<code>List</code>、<code>Set</code>和 <code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个 <code>key</code>。以 <code>List</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，Java编译器并不知道如何遍历 <code>List</code>。上述代码能够编译通过，只是因为编译器把 <code>for each</code>循环通过 <code>Iterator</code>改写为了普通的 <code>for</code>循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     String s = it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这种通过 <code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>
<p>例如，我们虽然知道 <code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了 <code>get(int)</code>方法。虽然我们可以用for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    Object value = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把 <code>ArrayList</code>换成 <code>LinkedList</code>，<code>get(int)</code>方法耗时会随着 <code>index</code>的增加而增加。如果把 <code>ArrayList</code>换成 <code>Set</code>，上述代码就无法编译，因为Set内部没有索引。</p>
<p>用 <code>Iterator</code>遍历就没有上述问题，因为 <code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的 <code>for each</code>循环自动转换为 <code>Iterator</code>遍历。</p>
<p>如果我们自己编写了一个集合类，想要使用 <code>for each</code>循环，只需满足以下条件：</p>
<ul>
<li>集合类实现Iterable接口，该接口要求返回一个<code>Iterator</code>对象；</li>
<li>用<code>Iterator</code>对象迭代集合内部数据。</li>
</ul>
<p>这里的关键在于，集合类通过调用 <code>iterator()</code>方法，返回一个 <code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p>
<p>一个简单的 <code>Iterator</code>示例如下，它总是以倒序遍历集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>ReverseList</code>和 <code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按 <code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>
<p>在编写 <code>Iterator</code>的时候，我们通常可以用一个内部类来实现 <code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类 <code>ReverseIterator</code>可以用 <code>ReverseList.this</code>获得当前外部类的 <code>this</code>引用，然后，通过这个 <code>this</code>引用就可以访问 <code>ReverseList</code>的所有字段和方法。</p>
<h2 id="使用Collections">使用Collections</h2>
<p><code>Collections</code>是JDK提供的工具类，同样位于 <code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
<div class="note warning simple"><p>注意Collections结尾多了一个s，不是Collection！</p>
</div>
<p>我们一般看方法名和参数就可以确认 <code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>
<blockquote>
<p>public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) { … }</p>
</blockquote>
<p><code>addAll()</code>方法可以给一个 <code>Collection</code>类型的集合添加若干元素。因为方法签名是 <code>Collection</code>，所以我们可以传入 <code>List</code>，<code>Set</code>等各种集合类型。</p>
<h3 id="创建空集合">创建空集合</h3>
<p><code>Collections</code>提供了一系列方法来创建空集合：</p>
<ul>
<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>
<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>
<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>
</ul>
<p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的 <code>of(T...)</code>方法创建空集合。例如，以下创建空 <code>List</code>的两个方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of();</span><br><span class="line">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h3 id="创建单元素集合">创建单元素集合</h3>
<p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>
<ul>
<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>
<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>
<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>
</ul>
<p>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的 <code>of(T...)</code>方法创建单元素集合。例如，以下创建单元素 <code>List</code>的两个方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Collections.singletonList(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>实际上，使用 <code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(); <span class="comment">// empty list</span></span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 1 element</span></span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>); <span class="comment">// 2 elements</span></span><br><span class="line">List&lt;String&gt; list4 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 3 elements</span></span><br></pre></td></tr></table></figure>
<h3 id="排序-2">排序</h3>
<p><code>Collections</code>可以对 <code>List</code>进行排序。因为排序会直接修改List元素的位置，因此必须传入可变 <code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洗牌">洗牌</h3>
<p><code>Collections</code>提供了洗牌算法，即传入一个有序的 <code>List</code>，可以随机打乱 <code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 洗牌后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可变集合">不可变集合</h3>
<p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
<p>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        immutable.add(<span class="string">&quot;orange&quot;</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        mutable.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">        mutable = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全集合">线程安全集合</h3>
<p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
<li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>
<p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>
<h1>正则表达式</h1>
<p>正则表达式是一种用来匹配字符串的强有力的武器。Java内置了强大的正则表达式的支持。</p>
<h2 id="正则表达式简介">正则表达式简介</h2>
<p>在了解正则表达式之前，我们先看几个非常常见的问题：</p>
<ul>
<li>如何判断字符串是否是有效的电话号码？例如：<code>010-1234567</code>，<code>123ABC456</code>，<code>13510001000</code>等；</li>
<li>如何判断字符串是否是有效的电子邮件地址？例如：<code>test@example.com</code>，<code>test#example</code>等；</li>
<li>如何判断字符串是否是有效的时间？例如：<code>12:34</code>，<code>09:60</code>，<code>99:99</code>等。</li>
</ul>
<p>一种直观的想法是通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现。下面是判断手机号的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是11位？</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() != <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一位都是0~9：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码仅仅做了非常粗略的判断，并未考虑首位数字不能为0等更详细的情况。</p>
<p>除了判断手机号，我们还需要判断电子邮件地址、电话、邮编等等：</p>
<ul>
<li>boolean isValidMobileNumber(String s) { … }</li>
<li>boolean isValidEmail(String s) { … }</li>
<li>boolean isValidPhoneNumber(String s) { … }</li>
<li>boolean isValidZipCode(String s) { … }</li>
<li>…</li>
</ul>
<p>为每一种判断逻辑编写代码实在是太繁琐了。有没有更简单的方法？</p>
<p>有！用正则表达式！</p>
<p>正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式 <code>\d&#123;11&#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p>
<p>正则表达式是一套标准，它可以用于任何语言。Java标准库的 <code>java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p>
<p>举个例子：要判断用户输入的年份是否是20##年，我们先写出规则如下：</p>
<p>一共有4个字符，分别是：<code>2</code>，<code>0``，0~9任意数字</code>，<code>0~9任意数字</code>。</p>
<p>对应的正则表达式就是：<code>20\d\d</code>，其中 <code>\d</code>表示任意一个数字。</p>
<p>把正则表达式转换为Java字符串就变成了 <code>20\\d\\d</code>，注意Java字符串用 <code>\\</code>表示 <code>\</code>。</p>
<p>最后，用正则表达式匹配一个字符串的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2019&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2100&quot;</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配规则">匹配规则</h2>
<p>正则表达式的匹配规则是从左到右按规则匹配。我们首先来看如何使用正则表达式来做精确匹配。</p>
<p>对于正则表达式abc来说，它只能精确地匹配字符串 <code>&quot;abc&quot;</code>，不能匹配 <code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p>
<p>如果正则表达式有特殊字符，那就需要用 <code>\</code>转义。例如，正则表达式 <code>a\&amp;c</code>，其中 <code>\&amp;</code>是用来匹配特殊字符 <code>&amp;</code>的，它能精确匹配字符串 <code>&quot;a&amp;c&quot;</code>，但不能匹配 <code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p>
<p>要注意正则表达式在Java代码中也是一个字符串，所以，对于正则表达式 <code>a\&amp;c</code>来说，对应的Java字符串是 <code>&quot;a\\&amp;c&quot;</code>，因为 <code>\</code>也是Java字符串的转义字符，两个 <code>\\</code>实际上表示的是一个 <code>\</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String re1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;Abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(re1));</span><br><span class="line"></span><br><span class="line">        String re2 = <span class="string">&quot;a\\&amp;c&quot;</span>; <span class="comment">// 对应的正则是a\&amp;c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a-c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;&amp;c&quot;</span>.matches(re2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>如果想匹配非ASCII字符，例如中文，那就用 <code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串 <code>&quot;a和c&quot;</code>，中文字符和的Unicode编码是548c。</p>
<h3 id="匹配任意字符">匹配任意字符</h3>
<p>精确匹配实际上用处不大，因为我们直接用 <code>String.equals()</code>就可以做到。大多数情况下，我们想要的匹配规则更多的是模糊匹配。我们可以用.匹配一个任意字符。</p>
<p>例如，正则表达式 <code>a.c</code>中间的 <code>.</code>可以匹配一个任意字符，例如，下面的字符串都可以被匹配：</p>
<ul>
<li><code>&quot;abc&quot;</code>，因为.可以匹配字符b；</li>
<li><code>&quot;a&amp;c&quot;</code>，因为.可以匹配字符&amp;；</li>
<li><code>&quot;acc&quot;</code>，因为.可以匹配字符c。</li>
</ul>
<p>但它不能匹配 <code>&quot;ac&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>，因为 <code>.</code>匹配一个字符且仅限一个字符。</p>
<h3 id="匹配数字">匹配数字</h3>
<p>用 <code>.</code>可以匹配任意字符，这个口子开得有点大。如果我们只想匹配 <code>0~9</code>这样的数字，可以用 <code>\d</code>匹配。例如，正则表达式 <code>00\d</code>可以匹配：</p>
<ul>
<li><code>&quot;007&quot;</code>，因为<code>\d</code>可以匹配字符7；</li>
<li><code>&quot;008&quot;</code>，因为<code>\d</code>可以匹配字符8。</li>
</ul>
<p>它不能匹配 <code>&quot;00A&quot;</code>，<code>&quot;0077&quot;</code>，因为\d仅限单个数字字符。</p>
<h3 id="匹配常用字符">匹配常用字符</h3>
<p>用 <code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p>
<ul>
<li><code>&quot;javac&quot;</code>，因为<code>\w</code>可以匹配英文字符c；</li>
<li><code>&quot;java9&quot;</code>，因为<code>\w</code>可以匹配数字字符9；。</li>
<li><code>&quot;java_&quot;</code>，因为<code>\w</code>可以匹配下划线_。</li>
</ul>
<p>它不能匹配 <code>&quot;java#&quot;</code>，<code>&quot;java &quot;</code>，因为 <code>\w</code>不能匹配 <code>#</code>、空格等字符。</p>
<h3 id="匹配空格字符">匹配空格字符</h3>
<p>用 <code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格，还包括tab字符（在Java中用\t表示）。例如，a\sc可以匹配：</p>
<ul>
<li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配空格字符；</li>
<li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配<code>tab</code>字符<code>\t</code>。</li>
</ul>
<p>它不能匹配 <code>&quot;ac&quot;</code>，<code>&quot;abc&quot;</code>等。</p>
<h3 id="匹配非数字">匹配非数字</h3>
<p>用 <code>\d</code>可以匹配一个数字，而 <code>\D</code>则匹配一个非数字。例如，<code>00\D</code>可以匹配：</p>
<ul>
<li><code>&quot;00A&quot;</code>，因为<code>\D</code>可以匹配非数字字符A；</li>
<li><code>&quot;00#&quot;</code>，因为<code>\D</code>可以匹配非数字字符#。</li>
</ul>
<p><code>00\d</code>可以匹配的字符串 <code>&quot;007&quot;</code>，<code>&quot;008&quot;</code>等，<code>00\D</code>是不能匹配的。</p>
<p>类似的，<code>\W</code>可以匹配 <code>\w</code>不能匹配的字符，<code>\S</code>可以匹配 <code>\s</code>不能匹配的字符，这几个正好是反着来的。</p>
<h3 id="重复匹配">重复匹配</h3>
<p>我们用 <code>\d</code>可以匹配一个数字，例如，<code>A\d</code>可以匹配 <code>&quot;A0&quot;</code>，<code>&quot;A1&quot;</code>，如果要匹配多个数字，比如 <code>&quot;A380&quot;</code>，怎么办？</p>
<p>修饰符 <code>*</code>可以匹配任意个字符，包括0个字符。我们用 <code>A\d*</code>可以匹配：</p>
<ul>
<li>A：因为<code>\d*</code>可以匹配0个数字；</li>
<li>A0：因为<code>\d*</code>可以匹配1个数字0；</li>
<li>A380：因为<code>\d*</code>可以匹配多个数字380。</li>
</ul>
<p>修饰符 <code>+</code>可以匹配至少一个字符。我们用 <code>A\d+</code>可以匹配：</p>
<ul>
<li><code>A0</code>：因为\d+可以匹配1个数字<code>0</code>；</li>
<li><code>A380</code>：因为\d+可以匹配多个数字<code>380</code>。</li>
</ul>
<p>但它无法匹配 <code>&quot;A&quot;</code>，因为修饰符 <code>+</code>要求至少一个字符。</p>
<p>修饰符 <code>?</code>可以匹配 <code>0</code>个或一个字符。我们用 <code>A\d?</code>可以匹配：</p>
<ul>
<li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li>
<li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字0。</li>
</ul>
<p>但它无法匹配 <code>&quot;A33&quot;</code>，因为修饰符 <code>?</code>超过1个字符就不能匹配了。</p>
<p>如果我们想精确指定n个字符怎么办？用修饰符 <code>&#123;n&#125;</code>就可以。<code>A\d&#123;3&#125;</code>可以精确匹配：</p>
<ul>
<li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li>
</ul>
<p>如果我们想指定匹配 <code>n~m</code>个字符怎么办？用修饰符 <code>&#123;n,m&#125;</code>就可以。<code>A\d&#123;3,5&#125;</code>可以精确匹配：</p>
<p><code>A380</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>3</code>个数字 <code>380</code>；<br>
<code>A3800</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>4</code>个数字 <code>3800</code>；<br>
<code>A38000</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>5</code>个数字 <code>38000</code>。</p>
<p>如果没有上限，那么修饰符 <code>&#123;n,&#125;</code>就可以匹配至少n个字符</p>
<h2 id="复杂匹配规则">复杂匹配规则</h2>
<h3 id="匹配开头和结尾">匹配开头和结尾</h3>
<p>用正则表达式进行多行匹配时，我们用 <code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配 <code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p>
<h3 id="匹配指定范围">匹配指定范围</h3>
<p>如果我们规定一个7~8位数字的电话号码不能以 <code>0</code>开头，应该怎么写匹配规则呢？<code>\d&#123;7,8&#125;</code>是不行的，因为第一个 <code>\d</code>可以匹配到 <code>0</code>。</p>
<p>使用 <code>[...]</code>可以匹配范围内的字符，例如，<code>[123456789]</code>可以匹配 <code>1~9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p>
<p>把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写 <code>[1-9]</code>就可以。</p>
<p>要匹配大小写不限的十六进制数，比如 <code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p>
<ul>
<li><code>0-9</code>：字符<code>0~9</code>；</li>
<li><code>a-f</code>：字符<code>a~f</code>；</li>
<li><code>A-F</code>：字符<code>A~F</code>。</li>
</ul>
<p>如果要匹配6位十六进制数，前面讲过的{n}仍然可以继续配合使用：<code>[0-9a-fA-F]&#123;6&#125;</code>。</p>
<p><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写 <code>[^1-9]&#123;3&#125;</code>：</p>
<ul>
<li>可以匹配<code>&quot;ABC&quot;</code>，因为不包含字符<code>1~9</code>；</li>
<li>可以匹配<code>&quot;A00&quot;</code>，因为不包含字符<code>1~9</code>；</li>
<li>不能匹配<code>&quot;A01&quot;</code>，因为包含字符<code>1</code>；</li>
<li>不能匹配<code>&quot;A05&quot;</code>，因为包含字符<code>5</code>。</li>
</ul>
<h3 id="或规则匹配">或规则匹配</h3>
<p>用 <code>|</code>连接的两个正则规则是 <code>或</code>规则，例如，<code>AB|CD</code>表示可以匹配 <code>AB或CD</code>。</p>
<h3 id="使用括号">使用括号</h3>
<p>现在我们想要匹配字符串 <code>learn java</code>、<code>learn php</code>和 <code>learn go</code>怎么办？一个最简单的规则是 <code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用 <code>(...)</code>把子规则括起来表示成 <code>learn\\s(java|php|go)</code>。</p>
<h2 id="分组匹配">分组匹配</h2>
<p>我们前面讲到的 <code>(...)</code>可以用来把一个子规则括起来，这样写 <code>learn\s(java|php|go)</code>就可以更方便地匹配长字符串了。</p>
<p>实际上 <code>(...)</code>还有一个重要作用，就是分组匹配。</p>
<p>我们来看一下如何用正则匹配 <code>区号-电话号码</code>这个规则。利用前面讲到的匹配规则，写出来很容易：</p>
<blockquote>
<p>\d{3,4}-\d{6,8}</p>
</blockquote>
<p>虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：如何提取匹配的子串？</p>
<p>当然可以用 <code>String</code>提供的 <code>indexOf()</code>和 <code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取 <code>learn\s(java|php)</code>还得改代码。</p>
<p>正确的方法是用 <code>(...)</code>先把要提取的规则分组，把上述正则表达式变为 <code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。</p>
<p>现在问题又来了：匹配后，如何按括号提取子串？</p>
<p>现在我们没办法用 <code>String.matches()</code>这样简单的判断方法了，必须引入 <code>java.util.regex</code>包，用 <code>Pattern</code>对象匹配，匹配后获得一个 <code>Matcher</code>对象，如果匹配成功，就可以直接从 <code>Matcher.group(index)</code>返回子串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);</span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，会得到两个匹配上的子串 <code>010</code>和 <code>12345678</code>。</p>
<p>要特别注意，<code>Matcher.group(index)</code>方法的参数用 <code>1</code>表示第一个子串，<code>2</code>表示第二个子串。如果我们传入 <code>0</code>会得到什么呢？答案是 <code>010-12345678</code>，即整个正则匹配到的字符串。</p>
<h3 id="Pattern">Pattern</h3>
<p>我们在前面的代码中用到的正则表达式代码是 <code>String.matches()</code>方法，而我们在分组提取的代码中用的是 <code>java.util.regex</code>包里面的 <code>Pattern</code>类和 <code>Matcher</code>类。实际上这两种代码本质上是一样的，因为 <code>String.matches()</code>方法内部调用的就是 <code>Pattern</code>和 <code>Matcher</code>类的方法。</p>
<p>但是反复使用 <code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的 <code>Pattern</code>对象。完全可以先创建出一个 <code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            String whole = matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            String area = matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            String tel = matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Matcher</code>时，必须首先调用 <code>matches()</code>判断是否匹配成功，匹配成功后，才能调用 <code>group()</code>提取子串。</p>
<p>利用提取子串的功能，我们轻松获得了区号和号码两部分。</p>
<h2 id="非贪婪匹配">非贪婪匹配</h2>
<p>在介绍非贪婪匹配前，我们先看一个简单的问题：</p>
<p>给定一个字符串表示的数字，判断该数字末尾0的个数。例如：</p>
<ul>
<li><code>&quot;123000&quot;</code>：3个<code>0</code></li>
<li><code>&quot;10100&quot;</code>：2个<code>0</code></li>
<li><code>&quot;1001&quot;</code>：0个<code>0</code></li>
</ul>
<p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code>，Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而打印的第二个子串是空字符串 <code>&quot;&quot;</code>。</p>
<p>实际上，我们期望分组匹配结果是：</p>
<table>
<thead>
<tr>
<th>input</th>
<th>\d+</th>
<th>0*</th>
</tr>
</thead>
<tbody>
<tr>
<td>123000</td>
<td>“123”</td>
<td>“000”</td>
</tr>
<tr>
<td>10100</td>
<td>“101”</td>
<td>“00”</td>
</tr>
<tr>
<td>1001</td>
<td>“1001”</td>
<td>“”</td>
</tr>
</tbody>
</table>
<p>但实际的分组匹配结果是这样的：</p>
<table>
<thead>
<tr>
<th>input</th>
<th>\d+</th>
<th>0*</th>
</tr>
</thead>
<tbody>
<tr>
<td>123000</td>
<td>“123000”</td>
<td>“”</td>
</tr>
<tr>
<td>10100</td>
<td>“10100”</td>
<td>“”</td>
</tr>
<tr>
<td>1001</td>
<td>“1001”</td>
<td>“”</td>
</tr>
</tbody>
</table>
<p>仔细观察上述实际匹配结果，实际上它是完全合理的，因为 <code>\d+</code>确实可以匹配后面任意个 <code>0</code>。</p>
<p>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的0包含进来。</p>
<p>要让 <code>\d+</code>尽量少匹配，让 <code>0*</code>尽量多匹配，我们就必须让 <code>\d+</code>使用非贪婪匹配。在规则 <code>\d+</code>后面加个 <code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，给定一个匹配规则，加上 <code>?</code>后就变成了非贪婪匹配。</p>
<p>我们再来看这个正则表达式 <code>(\d??)(9*)</code>，注意 <code>\d?</code>表示匹配 <code>0</code>个或 <code>1</code>个数字，后面第二个 <code>?</code>表示非贪婪匹配，因此，给定字符串 <code>&quot;9999&quot;</code>，匹配到的两个子串分别是 <code>&quot;&quot;</code>和 <code>&quot;9999&quot;</code>，因为对于 <code>\d?</code>来说，可以匹配 <code>1</code>个 <code>9</code>，也可以匹配 <code>0</code>个 <code>9</code>，但是因为后面的 <code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了 <code>0</code>个 <code>9</code>。</p>
<h2 id="搜索和替换">搜索和替换</h2>
<h3 id="分割字符串-2">分割字符串</h3>
<p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合 <code>,</code>和 <code>;</code>这些不规范的输入，直接提取出规范的字符串。</p>
<h3 id="搜索字符串">搜索字符串</h3>
<p>使用正则表达式还可以搜索字符串，我们来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们获取到 <code>Matcher</code>对象后，不需要调用 <code>matches()</code>方法（因为匹配整个串肯定返回 <code>false</code>），而是反复调用 <code>find()</code>方法，在整个串中搜索能匹配上 <code>\\wo\\w</code>规则的子串，并打印出来。这种方式比 <code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是 <code>o</code>，前后两个必须是字符 <code>[A-Za-z0-9_]</code>。</p>
<h3 id="替换字符串">替换字符串</h3>
<p>使用正则表达式替换字符串可以直接调用 <code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p>
<h3 id="反向引用">反向引用</h3>
<p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个 <code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用 <code>replaceAll()</code>的时候，我们传入的第二个参数可以使用 <code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br></pre></td></tr></table></figure>
<p>它实际上把任何4字符单词的前后用 <code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于 <code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串 <code>([a-z]&#123;4&#125;)</code>替换了 <code>$1</code>。</p>
<h1>IO</h1>
<p>IO是指Input/Output，即输入和输出。以内存为中心：</p>
<ul>
<li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li>
<li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p>
<p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p>
<p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p>
<p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>
<p><strong>InputStream / OutputStream</strong><br>
IO流以byte（字节）为最小单位，因此也称为字节流。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p>
<p>╔════════════╗<br>
║   Memory   ║<br>
╚════════════╝<br>
▲<br>
│0x48<br>
│0x65<br>
│0x6c<br>
│0x6c<br>
│0x6f<br>
│0x21<br>
╔═══════════╗<br>
║ Hard Disk ║<br>
╚═══════════╝<br>
这6个字节是按顺序读入的，所以是输入字节流。</p>
<p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p>
<p>╔════════════╗<br>
║   Memory   ║<br>
╚════════════╝<br>
│0x21<br>
│0x6f<br>
│0x6c<br>
│0x6c<br>
│0x65<br>
│0x48<br>
▼<br>
╔═══════════╗<br>
║ Hard Disk ║<br>
╚═══════════╝<br>
在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流。</p>
<p><strong>Reader / Writer</strong><br>
如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照 <code>char</code>来读写显然更方便，这种流称为字符流。</p>
<p>Java提供了 <code>Reader</code>和 <code>Writer</code>表示字符流，字符流传输的最小数据单位是char。</p>
<p>例如，我们把 <code>char[]</code>数组 <code>Hi你好</code>这4个字符用 <code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符 <code>H</code>和 <code>i</code>各占一个字节，中文字符 <code>你好</code>各占3个字节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x48</span><br><span class="line">0x69</span><br><span class="line">0xe4bda0</span><br><span class="line">0xe5a5bd</span><br></pre></td></tr></table></figure>
<p>反过来，我们用 <code>Reader</code>读取以 <code>UTF-8</code>编码的这8个字节，会从 <code>Reader</code>中得到 <code>Hi你好</code>这4个字符。</p>
<p>因此，<code>Reader</code>和 <code>Writer</code>本质上是一个能自动编解码的 <code>InputStream</code>和 <code>OutputStream</code>。</p>
<p>使用 <code>Reader</code>，数据源虽然是字节，但我们读入的数据都是 <code>char</code>类型的字符，原因是 <code>Reader</code>内部把读入的 <code>byte</code>做了解码，转换成了 <code>char</code>。使用 <code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是 <code>byte[]</code>数组，但是我们可以自己把二进制 <code>byte[]</code>数组按照某种编码转换为字符串。究竟使用 <code>Reader</code>还是 <code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用 <code>InputStream</code>，如果数据源是文本，使用 <code>Reader</code>更方便一些。<code>Writer</code>和 <code>OutputStream</code>是类似的。</p>
<p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p>
<p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p>
<p><strong>同步和异步</strong><br>
Java标准库的包 <code>java.io</code>提供了同步IO，而 <code>java.nio</code>则是异步IO。上面我们讨论的 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和 <code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有 <code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和 <code>FileWriter</code>。</p>
<p>本节我们只讨论Java的同步IO，即输入/输出流的IO模型。</p>
<h2 id="File对象">File对象</h2>
<p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p>
<blockquote>
<p>File f = new File(“C:\Windows\notepad.exe”);</p>
</blockquote>
<p>注意Windows平台使用 <code>\</code>作为路径分隔符，在Java字符串中需要用 <code>\\</code>表示一个\。Linux平台使用/作为路径分隔符：</p>
<blockquote>
<p>File f = new File(“/usr/bin/javac”);</p>
</blockquote>
<p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">&quot;.\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">&quot;..\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>
<p>File对象有3种形式表示的路径，一种是 <code>getPath()</code>，返回构造方法传入的路径，一种是 <code>getAbsolutePath()</code>，返回绝对路径，一种是 <code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p>
<p>什么是规范路径？我们看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对路径可以表示成 <code>C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把 <code>.</code>和 <code>..</code>转换成标准的绝对路径后的路径：<code>C:\Windows\notepad.exe</code>。</p>
<p>因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(File.separator); <span class="comment">// 根据当前平台打印&quot;\&quot;或&quot;/&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="文件和目录">文件和目录</h3>
<p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个 <code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个 <code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用 <code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p>
<p>例如，调用 <code>isFile()</code>，判断该 <code>File</code>对象是否是一个已存在的文件，调用 <code>isDirectory()</code>，判断该 <code>File</code>对象是否是一个已存在的目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\nothing&quot;</span>);</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f2.isFile());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line">        System.out.println(f3.isFile());</span><br><span class="line">        System.out.println(f3.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>
<ul>
<li><code>boolean canRead()</code>：是否可读；</li>
<li><code>boolean canWrite()</code>：是否可写；</li>
<li><code>boolean canExecute()</code>：是否可执行；</li>
<li><code>long length()</code>：文件字节大小。</li>
</ul>
<p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p>
<h3 id="创建和删除文件">创建和删除文件</h3>
<p>当File对象表示一个文件时，可以通过 <code>createNewFile()</code>创建一个新文件，用 <code>delete()</code>删除该文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/path/to/file&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些时候，程序需要读写一些临时文件，File对象提供了 <code>createTempFile()</code>来创建一个临时文件，以及 <code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">&quot;tmp-&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// /tmp/tmp-10977568570339757949.txt</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历文件和目录">遍历文件和目录</h3>
<p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.exe&quot;</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>
<ul>
<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>
<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>
</ul>
<h3 id="Path">Path</h3>
<p>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;project&quot;</span>, <span class="string">&quot;study&quot;</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputStream">InputStream</h2>
<p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于 <code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p>
<p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p>
<blockquote>
<p>public abstract int read() throws IOException;</p>
</blockquote>
<p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。</p>
<p><code>FileInputStream</code>是 <code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个 <code>FileInputStream</code>的所有字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p>
<p><code>InputStream</code>和 <code>OutputStream</code>都是通过 <code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p>
<p>我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成 <code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理 <code>IOException</code>。</p>
<p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，<code>InputStream</code>就没法正确地关闭，资源也就没法及时释放。</p>
<p>因此，我们需要用 <code>try ... finally</code>来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的 <code>try(resource)</code>的语法，只需要编写 <code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，编译器并不会特别地为 <code>InputStream</code>加上自动关闭。编译器只看 <code>try(resource = ...)</code>中的对象是否实现了 <code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上 <code>finally</code>语句并调用 <code>close()</code>方法。<code>InputStream</code>和 <code>OutputStrea</code>m都实现了这个接口，因此，都可以用在 <code>try(resource)</code>中。</p>
<h3 id="缓冲">缓冲</h3>
<p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>
<ul>
<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>
<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>
</ul>
<p>利用上述方法一次读取多个字节时，需要先定义一个 <code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的 <code>int</code>值，而是返回实际读取了多少个字节。如果返回 <code>-1</code>，表示没有更多的数据了。</p>
<p>利用缓冲区一次读取多个字节的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞">阻塞</h3>
<p>在调用 <code>InputStream</code>的 <code>read()</code>方法读取数据时，我们说 <code>read()</code>方法是阻塞（<code>Blocking</code>）的。它的意思是，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="keyword">int</span> m = n;</span><br></pre></td></tr></table></figure>
<p>执行到第二行代码时，必须等 <code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定 <code>read()</code>方法调用到底要花费多长时间。</p>
<h3 id="InputStream实现类">InputStream实现类</h3>
<p>用FileInputStream可以从文件获取输入流，这是InputStream常用的一个实现类。此外，ByteArrayInputStream可以在内存中模拟一个InputStream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ByteArrayInputStream</code>实际上是把一个 <code>byte[]</code>数组在内存中变成一个 <code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个 <code>InputStream</code>。</p>
<p>举个栗子：我们想从文件中读取所有字节，并转换成char然后拼成一个字符串，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">            &#125;</span><br><span class="line">            s = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要测试上面的程序，就真的需要在本地硬盘上放一个真实的文本文件。如果我们把代码稍微改造一下，提取一个 <code>readAsString()</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            s = readAsString(input);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个 <code>String readAsString(InputStream input)</code>方法进行测试就相当简单，因为不一定要传入一个真的 <code>FileInputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            String s = readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是面向抽象编程原则的应用：接受 <code>InputStream</code>抽象类型，而不是具体的 <code>FileInputStream</code>类型，从而使得代码可以处理 <code>InputStream</code>的任意实现类。</p>
<h2 id="OutputStream">OutputStream</h2>
<p>和 <code>InputStream</code>相反 <code>，OutputStream</code>是Java标准库提供的最基本的输出流。</p>
<p>和 <code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是 <code>void write(int b)</code>，签名如下：</p>
<blockquote>
<p>public abstract void write(int b) throws IOException;</p>
</blockquote>
<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是 <code>int</code>参数，但只会写入一个字节，即只写入 <code>int最低8位</code>表示字节的部分（相当于 <code>b &amp; 0xff</code>）。</p>
<p>和 <code>InputStream</code>类似，<code>OutputStream</code>也提供了 <code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个 <code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
<p>为什么要有 <code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个 <code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以 <code>OutputStream</code>有个 <code>flush()</code>方法，能强制把缓冲区内容输出。</p>
<p>通常情况下，我们不需要调用这个 <code>flush()</code>方法，因为缓冲区写满了 <code>OutputStream</code>会自动调用它，并且，在调用 <code>close()</code>方法关闭 <code>OutputStream</code>之前，也会自动调用 <code>flush()</code>方法。</p>
<p>但是，在某些情况下，我们必须手动调用 <code>flush()</code>方法。举个栗子：</p>
<p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过 <code>OutputStream</code>的 <code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p>
<p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p>
<p>解决办法就是每输入一句话后，立刻调用 <code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p>
<p>实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。</p>
<h3 id="FileOutputStream">FileOutputStream</h3>
<p>我们以 <code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用 <code>OutputStream</code>提供的重载方法 <code>void write(byte[])</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用 <code>try(resource)</code>来保证 <code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞-2">阻塞</h3>
<p>和 <code>InputStream</code>一样，<code>OutputStream</code>的 <code>write()</code>方法也是阻塞的。</p>
<h3 id="OutputStream实现类">OutputStream实现类</h3>
<p>用 <code>FileOutputStream</code>可以从文件获取输出流，这是 <code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个 <code>OutputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code>实际上是把一个 <code>byte[]</code>数组在内存中变成一个 <code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个 <code>OutputStream</code>。</p>
<p>同时操作多个 <code>AutoCloseable</code>资源时，在 <code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用 <code>;</code>隔开。例如，同时读写两个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Filter模式">Filter模式</h2>
<p>Java的IO标准库提供的 <code>InputStream</code>根据来源可以包括：</p>
<ul>
<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>
<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>
<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>
<li>…</li>
</ul>
<p>如果我们要给 <code>FileInputStream</code>添加缓冲功能，则可以从 <code>FileInputStream</code>派生一个类：</p>
<blockquote>
<p>BufferedFileInputStream extends FileInputStream</p>
</blockquote>
<p>如果要给 <code>FileInputStream</code>添加计算签名的功能，类似的，也可以从 <code>FileInputStream</code>派生一个类：</p>
<blockquote>
<p>DigestFileInputStream extends FileInputStream</p>
</blockquote>
<p>如果要给 <code>FileInputStream</code>添加加密/解密功能，还是可以从 <code>FileInputStream</code>派生一个类：</p>
<blockquote>
<p>CipherFileInputStream extends FileInputStream</p>
</blockquote>
<p>如果要给 <code>FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生 <code>BufferedDigestFileInputStream</code>。如果要给 <code>FileInputStream</code>添加缓冲和加解密的功能，则需要派生 <code>BufferedCipherFileInputStream</code>。</p>
<p>我们发现，给 <code>FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：<br>
┌─────────────────┐<br>
│ FileInputStream │<br>
└─────────────────┘<br>
▲<br>
┌───────────┬─────────┼─────────┬───────────┐<br>
│           │         │         │           │<br>
┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐<br>
│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│<br>
└───────────────────────┘│└─────────────────┘│└─────────────────────┘<br>
│                   │<br>
┌─────────────────────────────┐ ┌─────────────────────────────┐<br>
│BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│<br>
└─────────────────────────────┘ └─────────────────────────────┘</p>
<p>这还只是针对 <code>FileInputStream</code>设计，如果针对另一种 <code>InputStream</code>设计，很快会出现子类爆炸的情况。</p>
<p>因此，直接使用继承，为各种 <code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p>
<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将 <code>InputStream</code>分为两大类：</p>
<p>一类是直接提供数据的基础 <code>InputStream</code>，例如：</p>
<ul>
<li>FileInputStream</li>
<li>ByteArrayInputStream</li>
<li>ServletInputStream</li>
<li>…</li>
</ul>
<p>一类是提供额外附加功能的 <code>InputStream</code>，例如：</p>
<ul>
<li>BufferedInputStream</li>
<li>DigestInputStream</li>
<li>CipherInputStream</li>
<li>…</li>
</ul>
<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的 <code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>
<blockquote>
<p>InputStream file = new FileInputStream(“test.gz”);</p>
</blockquote>
<p>紧接着，我们希望 <code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用 <code>BufferedInputStream</code>包装这个 <code>InputStream</code>，得到的包装类型是 <code>BufferedInputStream</code>，但它仍然被视为一个 <code>InputStream</code>：</p>
<blockquote>
<p>InputStream buffered = new BufferedInputStream(file);</p>
</blockquote>
<p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个 <code>GZIPInputStream</code>：</p>
<blockquote>
<p>InputStream gzip = new GZIPInputStream(buffered);</p>
</blockquote>
<p>无论我们包装多少次，得到的对象始终是 <code>InputStream</code>，我们直接用 <code>InputStream</code>来引用它，就可以正常读取：</p>
<p>┌─────────────────────────┐<br>
│GZIPInputStream          │<br>
│┌───────────────────────┐│<br>
││BufferedFileInputStream││<br>
││┌─────────────────────┐││<br>
│││   FileInputStream   │││<br>
││└─────────────────────┘││<br>
│└───────────────────────┘│<br>
└─────────────────────────┘</p>
<p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为 <code>Filter模式</code>（或者 <code>装饰器模式</code>：<code>Decorator</code>）。它可以让我们通过少量的类来实现各种功能的组合：<br>
┌─────────────┐<br>
│ InputStream │<br>
└─────────────┘<br>
▲ ▲<br>
┌────────────────────┐ │ │ ┌─────────────────┐<br>
│  FileInputStream   │─┤ └─│FilterInputStream│<br>
└────────────────────┘ │   └─────────────────┘<br>
┌────────────────────┐ │     ▲ ┌───────────────────┐<br>
│ByteArrayInputStream│─┤     ├─│BufferedInputStream│<br>
└────────────────────┘ │     │ └───────────────────┘<br>
┌────────────────────┐ │     │ ┌───────────────────┐<br>
│ ServletInputStream │─┘     ├─│  DataInputStream  │<br>
└────────────────────┘       │ └───────────────────┘<br>
│ ┌───────────────────┐<br>
└─│CheckedInputStream │<br>
└───────────────────┘<br>
类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：<br>
┌─────────────┐<br>
│OutputStream │<br>
└─────────────┘<br>
▲ ▲<br>
┌─────────────────────┐ │ │ ┌──────────────────┐<br>
│  FileOutputStream   │─┤ └─│FilterOutputStream│<br>
└─────────────────────┘ │   └──────────────────┘<br>
┌─────────────────────┐ │     ▲ ┌────────────────────┐<br>
│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│<br>
└─────────────────────┘ │     │ └────────────────────┘<br>
┌─────────────────────┐ │     │ ┌────────────────────┐<br>
│ ServletOutputStream │─┘     ├─│  DataOutputStream  │<br>
└─────────────────────┘       │ └────────────────────┘<br>
│ ┌────────────────────┐<br>
└─│CheckedOutputStream │<br>
└────────────────────┘</p>
<h3 id="编写FilterInputStream">编写FilterInputStream</h3>
<p>我们也可以自己编写 <code>FilterInputStream</code>，以便可以把自己的 <code>FilterInputStream</code>“叠加”到任何一个 <code>InputStream</code>中。</p>
<p>下面的例子演示了如何编写一个 <code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到在叠加多个 <code>FilterInputStream</code>，我们只需要持有最外层的 <code>InputStream</code>，并且，当最外层的 <code>InputStream</code>关闭时（在 <code>try(resource)</code>块的结束处自动关闭），内层的 <code>InputStream</code>的 <code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p>
<h2 id="操作Zip">操作Zip</h2>
<p><code>ZipInputStream</code>是一种 <code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>
<p>┌───────────────────┐<br>
│    InputStream    │<br>
└───────────────────┘<br>
▲<br>
│<br>
┌───────────────────┐<br>
│ FilterInputStream │<br>
└───────────────────┘<br>
▲<br>
│<br>
┌───────────────────┐<br>
│InflaterInputStream│<br>
└───────────────────┘<br>
▲<br>
│<br>
┌───────────────────┐<br>
│  ZipInputStream   │<br>
└───────────────────┘<br>
▲<br>
│<br>
┌───────────────────┐<br>
│  JarInputStream   │<br>
└───────────────────┘</p>
<p>另一个 <code>JarInputStream</code>是从 <code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的 <code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p>
<h3 id="读取zip包">读取zip包</h3>
<p>我们来看看 <code>ZipInputStream</code>的基本用法。</p>
<p>我们要创建一个 <code>ZipInputStream</code>，通常是传入一个 <code>FileInputStream</code>作为数据源，然后，循环调用 <code>getNextEntry()</code>，直到返回 <code>null</code>，表示zip流结束。</p>
<p>一个 <code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用 <code>read()</code>方法不断读取，直到返回 <code>-1</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入zip包">写入zip包</h3>
<p><code>ZipOutputStream</code>是一种 <code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个 <code>ZipOutputStream</code>，通常是包装一个 <code>FileOutputStream</code>，然后，每写入一个文件前，先调用 <code>putNextEntry()</code>，然后用 <code>write()</code>写入 <code>byte[]</code>数据，写入完毕后调用 <code>closeEntry()</code>结束这个文件的打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的 <code>name</code>要用相对路径。</p>
<h2 id="读取classpath资源">读取classpath资源</h2>
<p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个.properties文件中读取配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String conf = <span class="string">&quot;C:\\conf\\default.properties&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(conf)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码要正常执行，必须在C盘创建 <code>conf</code>目录，然后在目录里创建 <code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p>
<p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p>
<p>有没有路径无关的读取文件的方式呢？</p>
<p>我们知道，Java存放 <code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p>
<ul>
<li>配置文件，例如.properties；</li>
<li>图片文件，例如.jpg；</li>
<li>文本文件，例如.txt，.csv；</li>
<li>……</li>
</ul>
<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把 <code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>
<p>在classpath中的资源文件，路径总是以 <code>／</code>开头，我们先获取当前的 <code>Class</code>对象，然后调用 <code>getResourceAsStream()</code>就可以直接从 <code>classpath</code>读取任意的资源文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回 <code>null</code>。因此，我们需要检查返回的 <code>InputStream</code>是否为 <code>null</code>，如果为 <code>null</code>，表示资源文件在 <code>classpath</code>中没有找到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这样读取配置文件，应用程序启动就更加灵活。</p>
<h2 id="序列化">序列化</h2>
<p>序列化是指把一个Java对象变成二进制内容，本质上就是一个 <code>byte[]</code>数组。</p>
<p>为什么要把Java对象序列化呢？因为序列化后可以把 <code>byte[]</code>保存到文件中，或者把 <code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p>
<p>有序列化，就有反序列化，即把一个二进制内容（也就是 <code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的 <code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取 <code>byte[]</code>并把它“变回”Java对象。</p>
<p>我们来看看如何把一个Java对象序列化。</p>
<p>一个Java对象要能序列化，必须实现一个特殊的 <code>java.io.Serializable</code>接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为 <code>“标记接口”（Marker Interface）</code>，实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p>
<h3 id="序列化-2">序列化</h3>
<p>把一个Java对象变为 <code>byte[]</code>数组，需要使用 <code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObjectOutputStream</code>既可以写入基本类型，如 <code>int</code>，<code>boolean</code>，也可以写入 <code>String</code>（以UTF-8编码），还可以写入实现了 <code>Serializable</code>接口的 <code>Object</code>。</p>
<p>因为写入 <code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p>
<h3 id="反序列化-2">反序列化</h3>
<p>和 <code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了能读取基本类型和 <code>String</code>类型外，调用 <code>readObject()</code>可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。</p>
<p><code>readObject()</code>可能抛出的异常有：</p>
<ul>
<li><code>ClassNotFoundException</code>：没有找到对应的Class；</li>
<li><code>InvalidClassException</code>：Class不匹配。</li>
</ul>
<p>对于 <code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义 <code>Person</code>类，所以无法反序列化。</p>
<p>对于 <code>InvalidClassException</code>，这种情况常见于序列化的 <code>Person</code>对象定义了一个 <code>int</code>类型的 <code>age</code>字段，但是反序列化时，<code>Person</code>类定义的 <code>age</code>字段被改成了 <code>long</code>类型，所以导致 <code>class</code>不兼容。</p>
<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的 <code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变 <code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>
<p>要特别注意反序列化的几个重要特点：</p>
<p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p>
<h3 id="安全性">安全性</h3>
<p>因为Java的序列化机制可以导致一个实例能直接从 <code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 <code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p>
<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
<h2 id="Reader">Reader</h2>
<p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和 <code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以 <code>byte</code>为单位读取，而 <code>Reader</code>是一个字符流，即以 <code>char</code>为单位读取：</p>
<table>
<thead>
<tr>
<th>InputStream</th>
<th>Reader</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节流，以byte为单位</td>
<td>字符流，以char为单位</td>
</tr>
<tr>
<td>读取字节（-1，<code>0~255</code>）：int read()</td>
<td>读取字符（-1，0~65535）：int read()</td>
</tr>
<tr>
<td>读到字节数组：int read(byte[] b)</td>
<td>读到字符数组：int read(char[] c)</td>
</tr>
</tbody>
</table>
<p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p>
<blockquote>
<p>public int read() throws IOException;</p>
</blockquote>
<p>这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。</p>
<h3 id="FileReader">FileReader</h3>
<p><code>FileReader</code>是 <code>Reader</code>的一个子类，它可以打开文件并获取 <code>Reader</code>。下面的代码演示了如何完整地读取一个 <code>FileReader</code>的所有字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为 <code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。</p>
<p>要避免乱码问题，我们需要在创建 <code>FileReader</code>时指定编码：</p>
<blockquote>
<p>Reader reader = new FileReader(“src/readme.txt”, StandardCharsets.UTF_8);</p>
</blockquote>
<p>和 <code>InputStream</code>类似 <code>，Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用 <code>try (resource)</code>来保证Reader在无论有没有IO错误的时候都能够正确地关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reader</code>还提供了一次性读取若干字符并填充到 <code>char[]</code>数组的方法：</p>
<blockquote>
<p>public int read(char[] c) throws IOException</p>
</blockquote>
<p>它返回实际读入的字符个数，最大不超过 <code>char[]</code>数组的长度。返回-1表示流结束。</p>
<p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayReader">CharArrayReader</h3>
<p><code>CharArrayReader</code>可以在内存中模拟一个 <code>Reader</code>，它的作用实际上是把一个 <code>char[]</code>数组变成一个 <code>Reader</code>，这和 <code>ByteArrayInputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringReader">StringReader</h3>
<p><code>StringReader</code>可以直接把 <code>String</code>作为数据源，它和 <code>CharArrayReader</code>几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> StringReader(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InputStreamReader">InputStreamReader</h3>
<p><code>Reader</code>和 <code>InputStream</code>有什么关系？</p>
<p>除了特殊的 <code>CharArrayReader</code>和 <code>StringReader</code>，普通的 <code>Reader</code>实际上是基于 <code>InputStream</code>构造的，因为 <code>Reader</code>需要从 <code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看 <code>FileReader</code>的源码，它在内部实际上持有一个 <code>FileInputStream</code>。</p>
<p>既然 <code>Reader</code>本质上是一个基于 <code>InputStream</code>的 <code>byte</code>到 <code>char</code>的转换器，那么，如果我们已经有一个 <code>InputStream</code>，想把它转换为Reader，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何 <code>InputStream</code>转换为 <code>Reader</code>。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>构造 <code>InputStreamReader</code>时，我们需要传入 <code>InputStream</code>，还需要指定编码，就可以得到一个 <code>Reader</code>对象。上述代码可以通过 <code>try (resource)</code>更简洁地改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实际上就是 <code>FileReader</code>的一种实现方式。</p>
<p>使用 <code>try (resource)</code>结构时，当我们关闭 <code>Reader</code>时，它会在内部自动调用 <code>InputStream</code>的 <code>close()</code>方法，所以，只需要关闭最外层的 <code>Reader</code>对象即可。</p>
<div class="note info sample simple"><p>使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p>
</div>
<h2 id="Writer">Writer</h2>
<p><code>Reader</code>是带编码转换器的 <code>InputStream</code>，它把 <code>byte</code>转换为 <code>char</code>，而 <code>Writer</code>就是带编码转换器的 <code>OutputStream</code>，它把 <code>char</code>转换为 <code>byte</code>并输出。</p>
<p><code>Writer</code>和 <code>OutputStream</code>的区别如下：</p>
<table>
<thead>
<tr>
<th>OutputStream</th>
<th>Writer</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节流，以byte为单位</td>
<td>字符流，以char为单位</td>
</tr>
<tr>
<td>写入字节（<code>0~255</code>）：void write(int b)</td>
<td>写入字符（<code>0~65535</code>）：void write(int c)</td>
</tr>
<tr>
<td>写入字节数组：void write(byte[] b)</td>
<td>写入字符数组：void write(char[] c)</td>
</tr>
<tr>
<td>无对应方法</td>
<td>写入String：void write(String s)</td>
</tr>
</tbody>
</table>
<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>
<ul>
<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>
<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>
<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>
</ul>
<h3 id="FileWriter">FileWriter</h3>
<p><code>FileWriter</code>就是向文件中写入字符流的 <code>Writer</code>。它的使用方法和 <code>FileReader</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharArrayWriter">CharArrayWriter</h3>
<p><code>CharArrayWriter</code>可以在内存中创建一个 <code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入 <code>char</code>，最后得到写入的 <code>char[]</code>数组，这和 <code>ByteArrayOutputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="keyword">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringWriter">StringWriter</h3>
<p><code>StringWriter</code>也是一个基于内存的 <code>Writer</code>，它和 <code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个 <code>StringBuffer</code>，并对外提供了 <code>Writer</code>接口。</p>
<h3 id="OutputStreamWriter">OutputStreamWriter</h3>
<p>除了 <code>CharArrayWriter</code>和 <code>StringWriter</code>外，普通的 <code>Writer</code>实际上是基于 <code>OutputStream</code>构造的，它接收 <code>char</code>，然后在内部自动转换成一个或多个 <code>byte</code>，并写入 <code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的 <code>OutputStream</code>转换为 <code>Writer</code>的转换器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实际上就是 <code>FileWriter</code>的一种实现方式。这和上一节的 <code>InputStreamReader</code>是一样的。</p>
<h2 id="PrintStream和PrintWriter">PrintStream和PrintWriter</h2>
<p><code>PrintStream</code>是一种 <code>FilterOutputStream</code>，它在 <code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p>
<ul>
<li>写入<code>int</code>：<code>print(int)</code></li>
<li>写入<code>boolean</code>：<code>print(boolean)</code></li>
<li>写入<code>String</code>：<code>print(String)</code></li>
<li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li>
<li>…</li>
</ul>
<p>以及对应的一组 <code>println()</code>方法，它会自动加上换行符。</p>
<p>我们经常使用的 <code>System.out.println()</code>实际上就是使用 <code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的 <code>PrintStream</code>，表示标准输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="number">12345</span>); <span class="comment">// 输出12345</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> Object()); <span class="comment">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure>
<p><code>System.err</code>是系统默认提供的标准错误输出。</p>
<p><code>PrintStream</code>和 <code>OutputStream</code>相比，除了添加了一组 <code>print()/println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出 <code>IOException</code>，这样我们在编写代码的时候，就不必捕获IOException。</p>
<h3 id="PrintWriter">PrintWriter</h3>
<p><code>PrintStream</code>最终输出的总是 <code>byte</code>数据，而 <code>PrintWriter</code>则是扩展了 <code>Writer</code>接口，它的 <code>print()/println()</code>方法最终输出的是 <code>char</code>数据。两者的使用方法几乎是一模一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterTset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Files">使用Files</h2>
<p>从Java 7开始，提供了 <code>Files</code>和 <code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p>
<p>虽然 <code>Files</code>和 <code>Paths</code>是 <code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个byte[]，可以这么写：</p>
<blockquote>
<p>byte[] data = Files.readAllBytes(Paths.get(“/path/to/file.txt”));</p>
</blockquote>
<p>如果是文本文件，可以把一个文件的全部内容读取为 <code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line">String content1 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line">String content2 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>写入文件也非常方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>
<p>此外，<code>Files</code>工具类还有 <code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>
<p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p>
<h1>日期与时间</h1>
<h2 id="基本概念">基本概念</h2>
<p>在计算机中，我们经常需要处理日期和时间。</p>
<p>这是日期：</p>
<ul>
<li>2019-11-20</li>
<li>2020-1-1</li>
</ul>
<p>这是时间：</p>
<ul>
<li>12:30:59</li>
<li>2020-1-1 20:21:59</li>
</ul>
<p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>
<p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p>
<h3 id="本地时间">本地时间</h3>
<p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1298615433691201/l" alt="localtime"></p>
<p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>
<h3 id="时区">时区</h3>
<p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p>
<p>一种是以 <code>GMT</code>或者 <code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者 <code>UTC+08:00</code>表示东八区。</p>
<p><code>GMT</code>和 <code>UTC</code>可以认为基本是等价的，只是 <code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>
<p>另一种是缩写，例如，<code>CST</code>表示 <code>China Standard Time</code>，也就是中国标准时间。但是 <code>CST</code>也可以表示美国中部时间 <code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>
<p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>
<p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1298616075419714/l" alt="timezone"></p>
<p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p>
<h3 id="夏令时">夏令时</h3>
<p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1298616301912130/l" alt="daynight-saving"></p>
<p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>
<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>
<ul>
<li>如果以 <code>GMT</code>或者 <code>UTC</code>作为时区，无论日期是多少，时间都是 <code>19:00</code>；</li>
<li>如果以国家／城市表示，例如 <code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，GMT时间和纽约时间可能是不一样的：</li>
</ul>
<table>
<thead>
<tr>
<th>时区</th>
<th>2019-11-20</th>
<th>2019-6-20</th>
</tr>
</thead>
<tbody>
<tr>
<td>GMT-05:00</td>
<td>19:00</td>
<td>19:00</td>
</tr>
<tr>
<td>UTC-05:00</td>
<td>19:00</td>
<td>19:00</td>
</tr>
<tr>
<td>America/New_York</td>
<td>19:00</td>
<td>20:00</td>
</tr>
</tbody>
</table>
<p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
<div class="note warning sample simple"><p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>
</div>
<h3 id="本地化">本地化</h3>
<p>在计算机中，通常使用 <code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由 <code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<p>计算机用 <code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的 <code>Locale</code>对用户显示如下：</p>
<p>||中国用户|美国用户|<br>
||--------|-------|<br>
|购买价格|12000.00|12,000.00|<br>
|购买日期|2016-11-30|11/30/2016|</p>
<h2 id="Date和Calendar">Date和Calendar</h2>
<p>在计算机中，应该如何表示日期和时间呢？</p>
<p>我们经常看到的日期和时间表示方式如下：</p>
<ul>
<li>2019-11-20 0:15:00 GMT+00:00</li>
<li>2019年11月20日8:15:00</li>
<li>11/19/2019 19:15:00 America/New_York</li>
</ul>
<p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p>
<p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p>
<p>当我们定义一个整型变量并赋值时：</p>
<blockquote>
<p>int n = 123400;</p>
</blockquote>
<p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量 <code>n</code>指向的内存实际上是一个4字节区域：</p>
<p>┌──┬──┬──┬──┐<br>
│00│01│e2│08│<br>
└──┴──┴──┴──┘<br>
注意到计算机内存除了二进制的 <code>0/1</code>外没有其他任何格式。上述十六机制是为了简化表示。</p>
<p>当我们用 <code>System.out.println(n)</code>打印这个整数的时候，实际上 <code>println()</code>这个方法在内部把 <code>int</code>类型转换成 <code>String</code>类型，然后打印出字符串 <code>123400</code>。</p>
<p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果n表示一个价格，我们就以 <code>$123,400.00</code>的形式来打印它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">123400</span>;</span><br><span class="line">        <span class="comment">// 123400</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="comment">// 1e208</span></span><br><span class="line">        System.out.println(Integer.toHexString(n));</span><br><span class="line">        <span class="comment">// $123,400.00</span></span><br><span class="line">        System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，整数 <code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p>
<blockquote>
<p>String toDisplay(int n) { … }</p>
</blockquote>
<p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p>
<ul>
<li>2019-11-20 0:15:01 GMT+00:00</li>
<li>2019年11月20日8:15:01</li>
<li>11/19/2019 19:15:01 America/New_York</li>
</ul>
<p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为 <code>Epoch Time</code>。</p>
<p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p>
<p><code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1574208900 = 北京时间2019-11-20 8:15:00</span><br><span class="line">           = 伦敦时间2019-11-20 0:15:00</span><br><span class="line">           = 纽约时间2019-11-19 19:15:00</span><br></pre></td></tr></table></figure>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1298615433691201/l" alt="localtime"></p>
<p>因此，在计算机中，只需要存储一个整数 <code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p>
<blockquote>
<p>String displayDateTime(int n, String timezone) { … }</p>
</blockquote>
<p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p>它们之间转换非常简单。而在Java程序中，时间戳通常是用 <code>long</code>表示的毫秒数，即：</p>
<blockquote>
<p>long t = 1574208900123L;</p>
</blockquote>
<p>转换成北京时间就是 <code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用 <code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>
<h3 id="标准库API">标准库API</h3>
<p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
<p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p>
<p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p>
<p>本节我们快速讲解旧API的常用类型和方法。</p>
<h4 id="Date">Date</h4>
<p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与 <code>java.sql.Date</code>区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看Date的基本用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>getYear()</code>返回的年份必须加上 <code>1900</code>，<code>getMonth()</code>返回的月份是 <code>0~11</code>分别表示 <code>1~12</code>月，所以要加1，而 <code>getDate()</code>返回的日期范围是 <code>1~31</code>，又不能加1。</p>
<p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用 <code>SimpleDateFormat</code>对一个 <code>Date</code>进行转换。它用预定义的字符串表示格式化：</p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
</ul>
<p>我们来看如何以自定义的格式输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的格式化预定义了许多不同的格式，我们以 <code>MMM</code>和 <code>E</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在不同的语言环境会打印出类似 <code>Sun Sep 15, 2019</code>这样的日期。可以从<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/text/SimpleDateFormat.html">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以 <code>M</code>为例，假设当前月份是9月：</p>
<ul>
<li><code>M</code>：输出<code>9</code></li>
<li><code>MM</code>：输出<code>09</code></li>
<li><code>MMM</code>：输出<code>Sep</code></li>
<li><code>MMMM</code>：输出<code>September</code></li>
</ul>
<p><code>Date</code>对象有几个严重的问题：它不能转换时区，除了 <code>toGMTString()</code>可以按 <code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>
<h4 id="Calendar">Calendar</h4>
<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和 <code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<p>我们来看 <code>Calendar</code>的基本用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> y = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> ss = c.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">&quot;-&quot;</span> + m + <span class="string">&quot;-&quot;</span> + d + <span class="string">&quot; &quot;</span> + w + <span class="string">&quot; &quot;</span> + hh + <span class="string">&quot;:&quot;</span> + mm + <span class="string">&quot;:&quot;</span> + ss + <span class="string">&quot;.&quot;</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>Calendar</code>获取年月日这些信息变成了 <code>get(int field)</code>，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~<code>7</code>分别表示周日，周一，……，周六。</p>
<p><code>Calendar</code>只有一种方式获取，即 <code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置2019年:</span></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">// 设置9月:注意8表示9月:</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置2日:</span></span><br><span class="line">        c.set(Calendar.DATE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置时间:</span></span><br><span class="line">        c.set(Calendar.HOUR_OF_DAY, <span class="number">21</span>);</span><br><span class="line">        c.set(Calendar.MINUTE, <span class="number">22</span>);</span><br><span class="line">        c.set(Calendar.SECOND, <span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-09-02 21:22:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 <code>Calendar.getTime()</code>可以将一个 <code>Calendar</code>对象转换成 <code>Date</code>对象，然后就可以用 <code>SimpleDateFormat</code>进行格式化了。</p>
<h4 id="TimeZone">TimeZone</h4>
<p><code>Calendar</code>和 <code>Date</code>相比，它提供了时区转换的功能。时区用 <code>TimeZone</code>对象表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeZone tzDefault = TimeZone.getDefault(); <span class="comment">// 当前时区</span></span><br><span class="line">        TimeZone tzGMT9 = TimeZone.getTimeZone(<span class="string">&quot;GMT+09:00&quot;</span>); <span class="comment">// GMT+9:00时区</span></span><br><span class="line">        TimeZone tzNY = TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>); <span class="comment">// 纽约时区</span></span><br><span class="line">        System.out.println(tzDefault.getID()); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">        System.out.println(tzGMT9.getID()); <span class="comment">// GMT+09:00</span></span><br><span class="line">        System.out.println(tzNY.getID()); <span class="comment">// America/New_York</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时区的唯一标识是以字符串表示的ID，我们获取指定 <code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用 <code>TimeZone.getAvailableIDs()</code>。</p>
<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间 <code>2019-11-20 8:15:00</code>转换为纽约时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置为北京时区:</span></span><br><span class="line">        c.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(sdf.format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-11-19 19:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，利用 <code>Calendar</code>进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>
<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>
</ol>
<p>因此，本质上时区转换只能通过 <code>SimpleDateFormat</code>在显示的时候完成。</p>
<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date d = c.getTime();</span><br><span class="line">        System.out.println(sdf.format(d));</span><br><span class="line">        <span class="comment">// 2019-11-25 6:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime">LocalDateTime</h2>
<p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>
<li>时刻：<code>Instant</code>；</li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>
<li>时间间隔：<code>Duration</code>。</li>
</ul>
<p>以及一套新的用于取代 <code>SimpleDateFormat</code>的格式化类型 <code>DateTimeFormatter</code>。</p>
<p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p>
<p>此外，新API修正了旧API不合理的常量设计：</p>
<ul>
<li>Month的范围用1~12表示1月到12月；</li>
<li>Week的范围用1~7表示周一到周日。</li>
</ul>
<p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>
<h3 id="LocalDateTime-2">LocalDateTime</h3>
<p>我们首先来看最常用的 <code>LocalDateTime</code>，它表示一个本地日期和时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate d = LocalDate.now(); <span class="comment">// 当前日期</span></span><br><span class="line">        LocalTime t = LocalTime.now(); <span class="comment">// 当前时间</span></span><br><span class="line">        LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">        System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和 <code>LocalTime</code>默认严格按照<a target="_blank" rel="noopener" href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>规定的日期和时间格式进行打印。</p>
<p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">LocalDate d = dt.toLocalDate(); <span class="comment">// 转换到当前日期</span></span><br><span class="line">LocalTime t = dt.toLocalTime(); <span class="comment">// 转换到当前时间</span></span><br></pre></td></tr></table></figure>
<p>反过来，通过指定的日期和时间创建 <code>LocalDateTime</code>可以通过 <code>of()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定日期和时间:</span></span><br><span class="line">LocalDate d2 = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>); <span class="comment">// 2019-11-30, 注意11=11月</span></span><br><span class="line">LocalTime t2 = LocalTime.of(<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 15:16:17</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure>
<p>因为严格按照ISO 8601的格式，因此，将字符串转换为LocalDateTime就可以传入标准格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.parse(<span class="string">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class="line">LocalDate d = LocalDate.parse(<span class="string">&quot;2019-11-19&quot;</span>);</span><br><span class="line">LocalTime t = LocalTime.parse(<span class="string">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意ISO 8601规定的日期和时间分隔符是 <code>T</code>。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li>
</ul>
<h3 id="DateTimeFormatter">DateTimeFormatter</h3>
<p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成 <code>LocalDateTime</code>，可以使用新的 <code>DateTimeFormatter</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义格式化:</span></span><br><span class="line">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用自定义格式解析:</span></span><br><span class="line">        LocalDateTime dt2 = LocalDateTime.parse(<span class="string">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class="line">        System.out.println(dt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 加5天减3小时:</span></span><br><span class="line">        LocalDateTime dt2 = dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T17:30:59</span></span><br><span class="line">        <span class="comment">// 减1月:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.minusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T17:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到月份加减会自动调整日期，例如从 <code>2019-10-31</code>减去1个月得到的结果是 <code>2019-09-30</code>，因为9月没有31日。</p>
<p>对日期和时间进行调整则使用 <code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把 <code>10:11:12</code>变为 <code>15:11:12</code>：</p>
<ul>
<li>调整年：withYear()</li>
<li>调整月：withMonth()</li>
<li>调整日：withDayOfMonth()</li>
<li>调整时：withHour()</li>
<li>调整分：withMinute()</li>
<li>调整秒：withSecond()</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 日期变为31日:</span></span><br><span class="line">        LocalDateTime dt2 = dt.withDayOfMonth(<span class="number">31</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T20:30:59</span></span><br><span class="line">        <span class="comment">// 月份变为9:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.withMonth(<span class="number">9</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T20:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样注意到调整月份时，会相应地调整日期，即把 <code>2019-10-31</code>的月份调整为 <code>9</code>时，日期也自动变为 <code>30</code>。</p>
<p>实际上，<code>LocalDateTime</code>还有一个通用的 <code>with()</code>方法允许我们做更复杂的运算。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line">        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line">        System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月最后1天:</span></span><br><span class="line">        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下月第1天:</span></span><br><span class="line">        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">        System.out.println(nextMonthFirstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月第1个周一:</span></span><br><span class="line">        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">        System.out.println(firstWeekday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p>
<p>要判断两个 <code>LocalDateTime</code>的先后，可以使用 <code>isBefore()</code>、<code>isAfter()</code>方法，对于 <code>LocalDate</code>和 <code>LocalTime</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        LocalDateTime target = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(now.isBefore(target));</span><br><span class="line">        System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">        System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">&quot;08:15:00&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>LocalDateTime</code>无法与时间戳进行转换，因为 <code>LocalDateTime</code>没有时区，无法确定某一时刻。后面我们要介绍的 <code>ZonedDateTime</code>相当于 <code>LocalDateTime</code>加时区的组合，它具有时区，可以与 <code>long</code>表示的时间戳进行转换。</p>
<h3 id="Duration和Period">Duration和Period</h3>
<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的 <code>Period</code>表示两个日期之间的天数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime start = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        LocalDateTime end = LocalDateTime.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>);</span><br><span class="line">        Duration d = Duration.between(start, end);</span><br><span class="line">        System.out.println(d); <span class="comment">// PT1235H10M30S</span></span><br><span class="line"></span><br><span class="line">        Period p = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>).until(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">        System.out.println(p); <span class="comment">// P1M21D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到两个 <code>LocalDateTime</code>之间的差值使用 <code>Duration</code>表示，类似 <code>PT1235H10M30S</code>，表示1235小时10分钟30秒。而两个 <code>LocalDate</code>之间的差值用 <code>Period</code>表示，类似 <code>P1M21D</code>，表示1个月21天。</p>
<p><code>Duration</code>和 <code>Period</code>的表示方法也符合ISO 8601的格式，它以 <code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是 <code>PT...</code>的格式表示仅有时间间隔。利用 <code>ofXxx()</code>或者 <code>parse()</code>方法也可以直接创建 <code>Duration</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = Duration.ofHours(<span class="number">10</span>); <span class="comment">// 10 hours</span></span><br><span class="line">Duration d2 = Duration.parse(<span class="string">&quot;P1DT2H3M&quot;</span>); <span class="comment">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure>
<p>有的童鞋可能发现Java 8引入的 <code>java.time</code>API。怎么和一个开源的<a target="_blank" rel="noopener" href="https://www.joda.org/">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了 <code>java.time</code>API。</p>
<h2 id="ZonedDateTime">ZonedDateTime</h2>
<p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。</p>
<p>可以简单地把 <code>ZonedDateTime</code>理解成 <code>LocalDateTime</code>加 <code>ZoneId</code>。<code>ZoneId</code>是 <code>java.time</code>引入的新的时区类，注意和旧的 <code>java.util.TimeZone</code>区别。</p>
<p>要创建一个 <code>ZonedDateTime</code>对象，有以下几种方法，一种是通过 <code>now()</code>方法返回当前时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>)); <span class="comment">// 用指定时区获取当前时间</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察打印的两个 <code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T20:<span class="number">58</span>:<span class="number">18.786182</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T08:<span class="number">58</span>:<span class="number">18.788860</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>
<p>另一种方式是通过给一个 <code>LocalDateTime</code>附加一个 <code>ZoneId</code>，就可以变成 <code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime ldt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class="line">        ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以这种方式创建的 <code>ZonedDateTime</code>，它的日期和时间与 <code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T15:<span class="number">16</span>:<span class="number">17</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T15:<span class="number">16</span>:<span class="number">17</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>
<h3 id="时区转换">时区转换</h3>
<p>要转换时区，首先我们需要有一个 <code>ZonedDateTime</code>对象，然后，通过 <code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>
<p>下面的代码演示了如何将北京时间转换为纽约时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 转换为纽约时间:</span></span><br><span class="line">        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T21:<span class="number">05</span>:<span class="number">50.187697</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T09:<span class="number">05</span>:<span class="number">50.187697</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>
<p>这是北京时间11月15日的转换结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-15T21:<span class="number">05</span>:<span class="number">50.187697</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-15T08:<span class="number">05</span>:<span class="number">50.187697</span>-<span class="number">05</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>
<p>两次转换后的纽约时间有1小时的夏令时时差。</p>
<div class="note warning sample simple"><p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p>
</div>
<p>有了 <code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZonedDateTime zdt = ...</span><br><span class="line">LocalDateTime ldt = zdt.toLocalDateTime();</span><br></pre></td></tr></table></figure>
<p>转换为 <code>LocalDateTime</code>时，直接丢弃了时区信息。</p>
<h2 id="DateTimeFormatter-2">DateTimeFormatter</h2>
<p>使用旧的 <code>Date</code>对象时，我们用 <code>SimpleDateFormat</code>进行格式化显示。使用新的 <code>LocalDateTime</code>或 <code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用 <code>DateTimeFormatter</code>。</p>
<p>和 <code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为 <code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而 <code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p>
<p>创建 <code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>
<blockquote>
<p>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm”);</p>
</blockquote>
<p>格式化字符串的使用方式与 <code>SimpleDateFormat</code>完全一致。</p>
<p>另一种创建 <code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定 <code>Locale</code>：</p>
<blockquote>
<p>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(“E, yyyy-MMMM-dd HH:mm”, <a target="_blank" rel="noopener" href="http://Locale.US">Locale.US</a>);</p>
</blockquote>
<p>这种方式可以按照 <code>Locale</code>默认习惯格式化。我们来看实际效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">        <span class="keyword">var</span> formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class="line">        System.out.println(formatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> zhFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(zhFormatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> usFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(usFormatter.format(zdt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在格式化字符串中，如果需要输出固定字符，可以用 <code>'xxx'</code>表示。</p>
<p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T23:<span class="number">16</span> GMT+08:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span> <span class="number">9</span>月 <span class="number">15</span> 周日 <span class="number">23</span>:<span class="number">16</span></span><br><span class="line">Sun, September/<span class="number">15</span>/<span class="number">2019</span> <span class="number">23</span>:<span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>当我们直接调用 <code>System.out.println()</code>对一个 <code>ZonedDateTime</code>或者 <code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的 <code>toString()</code>方法，默认的 <code>toString()</code>方法显示的字符串就是按照 <code>ISO 8601</code>格式显示的，我们可以通过 <code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br></pre></td></tr></table></figure>
<p>得到的输出和toString()类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-09-15</span><br><span class="line">2019-09-15T23:16:51.56217</span><br></pre></td></tr></table></figure>
<h2 id="Instant">Instant</h2>
<p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的 <code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p>
<p>这个当前时间戳在 <code>java.time</code>中以 <code>Instant</code>类型表示，我们用 <code>Instant.now()</code>获取当前时间戳，效果和 <code>System.currentTimeMillis()</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now.getEpochSecond()); <span class="comment">// 秒</span></span><br><span class="line">        System.out.println(now.toEpochMilli()); <span class="comment">// 毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1568568760</span><br><span class="line">1568568760316</span><br></pre></td></tr></table></figure>
<p>实际上，<code>Instant</code>内部只有两个核心字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Instant</span> <span class="keyword">implements</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和 <code>System.currentTimeMillis()</code>返回的 <code>long</code>相比，只是多了更高精度的纳秒。</p>
<p>既然 <code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出 <code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以指定时间戳创建Instant:</span></span><br><span class="line">Instant ins = Instant.ofEpochSecond(<span class="number">1568568760</span>);</span><br><span class="line">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zdt); <span class="comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<p>可见，对于某一个时间戳，给它关联上指定的 <code>ZoneId</code>，就得到了 <code>ZonedDateTime</code>，继而可以获得了对应时区的 <code>LocalDateTime</code>。</p>
<p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和 <code>long</code>都可以互相转换：</p>
<p>┌─────────────┐<br>
│LocalDateTime│────┐<br>
└─────────────┘    │    ┌─────────────┐<br>
├───&gt;│ZonedDateTime│<br>
┌─────────────┐    │    └─────────────┘<br>
│   ZoneId    │────┘           ▲<br>
└─────────────┘      ┌─────────┴─────────┐<br>
│                   │<br>
▼                   ▼<br>
┌─────────────┐     ┌─────────────┐<br>
│   Instant   │&lt;───&gt;│    long     │<br>
└─────────────┘     └─────────────┘<br>
转换的时候，只需要留意 <code>long</code>类型以毫秒还是秒为单位即可。</p>
<h2 id="最佳实践">最佳实践</h2>
<p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p>
<p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p>
<h3 id="旧API转新API">旧API转新API</h3>
<p>如果要把旧式的 <code>Date</code>或 <code>Calendar</code>转换为新API对象，可以通过 <code>toInstant()</code>方法转换为 <code>Instant</code>对象，再继续转换为 <code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; Instant:</span></span><br><span class="line">Instant ins1 = <span class="keyword">new</span> Date().toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Instant ins2 = calendar.toInstant();</span><br><span class="line">ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure>
<p>从上面的代码还可以看到，旧的 <code>TimeZone</code>提供了一个 <code>toZoneId()</code>，可以把自己变成新的 <code>ZoneId</code>。</p>
<h3 id="新API转旧API">新API转旧API</h3>
<p>如果要把新的 <code>ZonedDateTime</code>转换为旧的API对象，只能借助 <code>long</code>型时间戳做一个“中转”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZonedDateTime -&gt; long:</span></span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line"><span class="keyword">long</span> ts = zdt.toEpochSecond() * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Date:</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Calendar:</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.clear();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));</span><br><span class="line">calendar.setTimeInMillis(zdt.toEpochSecond() * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的代码还可以看到，新的 <code>ZoneId</code>转换为旧的 <code>TimeZone</code>，需要借助 <code>ZoneId.getId()</code>返回的 <code>String</code>完成。</p>
<h3 id="在数据库中存储日期和时间">在数据库中存储日期和时间</h3>
<p>除了旧式的 <code>java.util.Date</code>，我们还可以找到另一个 <code>java.sql.Date</code>，它继承自 <code>java.util.Date</code>，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p>
<p>在数据库中，也存在几种日期和时间类型：</p>
<ul>
<li><code>DATETIME</code>：表示日期和时间；</li>
<li><code>DATE</code>：仅表示日期；</li>
<li><code>TIME</code>：仅表示时间；</li>
<li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li>
</ul>
<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>对应Java类（旧）</th>
<th>对应Java类（新）</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATETIME</td>
<td>java.util.Date</td>
<td>LocalDateTime</td>
</tr>
<tr>
<td>DATE</td>
<td>java.sql.Date</td>
<td>LocalDate</td>
</tr>
<tr>
<td>TIME</td>
<td>java.sql.Time</td>
<td>LocalTime</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
<td>LocalDateTime</td>
</tr>
</tbody>
</table>
<p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数 <code>long</code>表示，在数据库中存储为 <code>BIGINT</code>类型。</p>
<p>通过存储一个 <code>long</code>型时间戳，我们可以编写一个 <code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ts = <span class="number">1574208900000L</span>;</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.CHINA, <span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.US, <span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">timestampToString</span><span class="params">(<span class="keyword">long</span> epochMilli, Locale lo, String zoneId)</span> </span>&#123;</span><br><span class="line">        Instant ins = Instant.ofEpochMilli(epochMilli);</span><br><span class="line">        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class="line">        <span class="keyword">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述方法进行调用，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019年11月20日 上午8:15</span><br><span class="line">Nov 19, 2019, 7:15 PM</span><br></pre></td></tr></table></figure>
<h1>单元测试</h1>
<h2 id="编写JUnit测试">编写JUnit测试</h2>
<p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p>
<p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p>
<p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：<br>
编写接口<br>
│<br>
▼<br>
编写测试<br>
│<br>
▼<br>
┌─&gt; 编写实现<br>
│    │<br>
│ N  ▼<br>
└── 运行测试<br>
│ Y<br>
▼<br>
任务完成</p>
<p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p>
<p>我们先通过一个示例来看如何编写测试。假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p>
<p>n!=1×2×3×…×n</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要测试这个方法，一个很自然的想法是编写一个 <code>main()</code>方法，然后运行一些测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fact(<span class="number">10</span>) == <span class="number">3628800</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过运行 <code>main()</code>方法来运行测试代码。</p>
<p>不过，使用 <code>main()</code>方法测试有很多缺点：</p>
<p>一是只能有一个 <code>main()</code>方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，<code>expected: 3628800, but actual: 123456</code>，三是很难编写一组通用的测试代码。</p>
<p>因此，我们需要一种测试框架，帮助我们编写测试。</p>
<h3 id="JUnit">JUnit</h3>
<p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p>
<p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p>
<p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p>
<p>以Eclipse为例，当我们已经编写了一个 <code>Factorial.java</code>文件后，我们想对其进行测试，需要编写一个对应的 <code>FactorialTest.java</code>文件，以 <code>Test</code>为后缀是一个惯例，并分别将其放入 <code>src</code>和 <code>test</code>目录中。最后，在 <code>Project</code> - <code>Properties</code> - <code>Java Build Path</code> - <code>Libraries</code>中添加 <code>JUnit 5</code>的库：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1304076771917890/l" alt=""></p>
<p>整个项目结构如下</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1304076140675137/l" alt=""></p>
<p>我们来看一下 <code>FactorialTest.java</code>的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心测试方法 <code>testFact()</code>加上了 <code>@Test</code>注解，这是 <code>JUnit</code>要求的，它会把带有 <code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用 <code>assertEquals(1, Factorial.fact(1))</code>表示，期望 <code>Factorial.fact(1)</code>返回 <code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在Assertion类中定义。Assertion还定义了其他断言方法，例如：</p>
<ul>
<li><code>assertTrue()</code>: 期待结果为<code>true</code></li>
<li><code>assertFalse()</code>: 期待结果为<code>false</code></li>
<li><code>assertNotNull()</code>: 期待结果为<code>非null</code></li>
<li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li>
<li>…</li>
</ul>
<p>运行单元测试非常简单。选中 <code>FactorialTest.java</code>文件，点击 <code>Run</code> - <code>Run As</code> - <code>JUnit Test</code>，Eclipse会自动运行这个 <code>JUnit</code>测试，并显示结果：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1304081469538370/l" alt=""></p>
<p>如果测试结果与预期不符，<code>assertEquals()</code>会抛出异常，我们就会得到一个测试失败的结果：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1304081566007362/l" alt=""></p>
<p>在Failure Trace中，JUnit会告诉我们详细的错误结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: expected: &lt;<span class="number">3628800</span>&gt; but was: &lt;<span class="number">362880</span>&gt;</span><br><span class="line">	at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:<span class="number">55</span>)</span><br><span class="line">	at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:<span class="number">195</span>)</span><br><span class="line">	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:<span class="number">168</span>)</span><br><span class="line">	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:<span class="number">163</span>)</span><br><span class="line">	at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:<span class="number">611</span>)</span><br><span class="line">	at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:<span class="number">14</span>)</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at ...</span><br></pre></td></tr></table></figure>
<p>第一行的失败信息的意思是期待结果 <code>3628800</code>但是实际返回是 <code>362880</code>，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止。</p>
<p>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用 <code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p>
<blockquote>
<p>assertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.0000001);</p>
</blockquote>
<h3 id="单元测试的好处">单元测试的好处</h3>
<p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p>
<p>使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p>
<p>在编写单元测试的时候，我们要遵循一定的规范：</p>
<p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>
<p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p>
<p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为 <code>0</code>，<code>null</code>，空字符串 <code>&quot;&quot;</code>等情况。</p>
<h2 id="使用Fixture">使用Fixture</h2>
<p>在一个单元测试中，我们经常编写多个 <code>@Test</code>方法，来分组、分类对目标代码进行测试。</p>
<p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个 <code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p>
<p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>
<p>我们来看一个具体的 <code>Calculator</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n + x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sub</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n - x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过 <code>@BeforeEach</code>来初始化，通过 <code>@AfterEach</code>来清理资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="keyword">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="keyword">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="keyword">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="keyword">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>CalculatorTest</code>测试中，有两个标记为 <code>@BeforeEach</code>和 <code>@AfterEach</code>的方法，它们会在运行每个 <code>@Test</code>方法前后自动运行。</p>
<p>上面的测试代码在JUnit中运行顺序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="keyword">new</span> CalculatorTest(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>@BeforeEach</code>和 <code>@AfterEach</code>会“环绕”在每个 <code>@Test</code>方法前后。</p>
<p>还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了 <code>@BeforeAll</code>和 <code>@AfterAll</code>，它们在运行所有 <code>@Test</code>前后运行，顺序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeforeAll(CalculatorTest.class);</span><br><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="keyword">new</span> CalculatorTest(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br><span class="line">invokeAfterAll(CalculatorTest.class);</span><br></pre></td></tr></table></figure>
<p>因为 <code>@BeforeAll</code>和 <code>@AfterAll</code>在所有 <code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Database db;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db = createDb(...);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dropDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>@BeforeAll</code>和 <code>@AfterAll</code>也只能标注在静态方法上。</p>
<p>因此，我们总结出编写Fixture的套路如下：</p>
<ol>
<li>对于实例变量，在 <code>@BeforeEach</code>中初始化，在 <code>@AfterEach</code>中清理，它们在 个 <code>@Test</code>方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量，在 <code>@BeforeAll</code>中初始化，在 <code>@AfterAll</code>中清理，它们在各个 <code>@Test</code>方法中均是唯一实例，会影响各个 <code>@Test</code>方法。</li>
</ol>
<p>大多数情况下，使用 <code>@BeforeEach</code>和 <code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到 <code>@BeforeAll</code>和 <code>@AfterAll</code>。</p>
<p>最后，注意到每次运行一个 <code>@Test</code>方法前，JUnit首先创建一个 <code>XxxTest</code>实例，因此，每个 <code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个 <code>@Test</code>方法带到另一个 <code>@Test</code>方法。</p>
<h2 id="异常测试">异常测试</h2>
<p>在Java程序中，异常处理是非常重要的。</p>
<p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p>
<p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p>
<p>我们仍然用 <code>Factorial</code>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法入口，我们增加了对参数 <code>n</code>的检查，如果为负数，则直接抛出 <code>IllegalArgumentException</code>。</p>
<p>现在，我们希望对异常进行测试。在JUnit测试中，我们可以编写一个 <code>@Test</code>方法专门测试异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> Executable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JUnit提供 <code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数 <code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行 <code>Factorial.fact(-1)</code>时，必定抛出 <code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>
<p>有些童鞋会觉得编写一个 <code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述奇怪的 <code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p>
<h2 id="条件测试">条件测试</h2>
<p>在运行测试的时候，有些时候，我们需要排出某些 <code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个 <code>@Disabled</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBug101</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么我们不直接注释掉 <code>@Test</code>，而是要加一个 <code>@Disabled</code>？这是因为注释掉 <code>@Test</code>，JUnit就不知道这是个测试方法，而加上 <code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p>
<blockquote>
<p>Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</p>
</blockquote>
<p>类似 <code>@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的 <code>@Test</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigFile</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        String os = System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;C:\\&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;mac&quot;</span>) || os.contains(<span class="string">&quot;linux&quot;</span>) || os.contains(<span class="string">&quot;unix&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/usr/local/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要测试 <code>getConfigFile()</code>这个方法，但是在Windows上跑，和在Linux上跑的代码路径不同，因此，针对两个系统的测试方法，其中一个只能在Windows上跑，另一个只能在Mac/Linux上跑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们给上述两个测试方法分别加上条件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableOnOs</code>就是一个条件测试判断。</p>
<p>我们来看一些常用的条件测试：</p>
<p>不在Windows平台执行的测试，可以加上 <code>@DisabledOnOs(OS.WINDOWS)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnNonWindowsOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on windows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能在Java 9或更高版本执行的测试，可以加上 <code>@DisabledOnJre(JRE.JAVA_8)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnJre(JRE.JAVA_8)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnJava9OrAbove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on java 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能在64位操作系统上执行的测试，可以用 <code>@EnabledIfSystemProperty</code>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOn64bitSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on 64 bit system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要传入环境变量 <code>DEBUG=true</code>才能执行的测试，可以用 <code>@EnabledIfEnvironmentVariable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOnDebugMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在JUnit中运行所有测试的时候，JUnit会给出执行的结果。在IDE中，我们能很容易地看到没有执行的测试：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1304094455103553/l" alt="junit-conditional-test"></p>
<p>带有⊘标记的测试方法表示没有执行。</p>
<h2 id="参数化测试">参数化测试</h2>
<p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p>
<p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p>
<p>JUnit提供了一个 <code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>
<p>假设我们想对 <code>Math.abs()</code>进行测试，先用一组正数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再用一组负数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbsNegative</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到参数化测试的注解是 <code>@ParameterizedTest</code>，而不是普通的 <code>@Test</code>。</p>
<p>实际的测试场景往往没有这么简单。假设我们自己编写了一个 <code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">capitalize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：参数如何传入？</p>
<p>最简单的方法是通过 <code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很容易理解：静态方法 <code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个 <code>String</code>，正好作为测试方法的两个参数传入。</p>
<div class="note info sample simple"><p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p>
</div>
<p>另一种传入测试参数的方法是使用 <code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用,分隔，因此，上述测试又可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有成百上千的测试输入，那么，直接写 <code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上 <code>@CsvFileSource</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JUnit只在 <code>classpath</code>中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到 <code>test</code>目录下，内容如下：</p>
<p>apple, Apple<br>
HELLO, Hello<br>
JUnit, Junit<br>
reSource, Resource</p>
<h1>加密与安全</h1>
<h2 id="编码算法">编码算法</h2>
<p>要学习编码算法，我们先来看一看什么是编码。</p>
<p>ASCII码就是一种编码，字母 <code>A</code>的编码是十六进制的 <code>0x41</code>，字母 <code>B</code>是 <code>0x42</code>，以此类推：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>ASCII编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0x41</td>
</tr>
<tr>
<td>B</td>
<td>0x42</td>
</tr>
<tr>
<td>C</td>
<td>0x43</td>
</tr>
<tr>
<td>D</td>
<td>0x44</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用 <code>Unicode</code>。而中文的中使用 <code>Unicode</code>编码就是 <code>0x4e2d</code>，使用 <code>UTF-8</code>则需要3个字节编码：</p>
<table>
<thead>
<tr>
<th>汉字</th>
<th>Unicode编码</th>
<th>UTF-8编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>中</td>
<td>0x4e2d</td>
<td>0xe4b8ad</td>
</tr>
<tr>
<td>文</td>
<td>0x6587</td>
<td>0xe69687</td>
</tr>
<tr>
<td>编</td>
<td>0x7f16</td>
<td>0xe7bc96</td>
</tr>
<tr>
<td>码</td>
<td>0x7801</td>
<td>0xe7a081</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p>
<p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p>
<h3 id="URL编码">URL编码</h3>
<p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p>
<p>[<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87">https://www.baidu.com/s?wd=中文</a>]</p>
<p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p>
<ul>
<li>如果字符是<code>A~Z</code>，<code>a~z</code>，<code>0~9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li>
<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li>
</ul>
<p>例如：字符中的UTF-8编码是 <code>0xe4b8ad</code>，因此，它的URL编码是 <code>%E4%B8%AD</code>。URL编码总是大写。</p>
<p>Java标准库提供了一个 <code>URLEncoder</code>类来对任意字符串进行URL编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String encoded = URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的运行结果是 <code>%E4%B8%AD%E6%96%87%21</code>，中的URL编码是 <code>%E4%B8%AD</code>，文的URL编码是 <code>%E6%96%87</code>，<code>!</code>虽然是ASCII字符，也要对其编码为 <code>%21</code>。</p>
<p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成 <code>+</code>，而现在的URL编码标准要求空格被编码为 <code>%20</code>，不过，服务器都可以处理这两种情况。</p>
<p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的 <code>URLDecoder</code>就可以解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String decoded = URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为 <code>%</code>前缀表示的文本，编码后的文本仅包含 <code>A~Z</code>，<code>a~z</code>，<code>0~9</code>，<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>和 <code>%</code>，便于浏览器和服务器处理</p>
<h3 id="Base64编码">Base64编码</h3>
<p>URL编码是对字符进行编码，表示成 <code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p>
<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含 <code>A~Z</code>、<code>a~z</code>、<code>0~9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>
<p>举个例子：3个byte数据分别是 <code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到 <code>39</code>、<code>0b</code>、<code>22</code>和 <code>2d</code>：</p>
<p>┌───────────────┬───────────────┬───────────────┐<br>
│      e4       │      b8       │      ad       │<br>
└───────────────┴───────────────┴───────────────┘<br>
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>
│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│<br>
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>
┌───────────┬───────────┬───────────┬───────────┐<br>
│    39     │    0b     │    22     │    2d     │<br>
└───────────┴───────────┴───────────┴───────────┘<br>
因为6位整数的范围总是 <code>0~63</code>，所以，能用64个字符表示：字符 <code>A~Z</code>对应索引 <code>0~25</code>，字符 <code>a~z</code>对应索引 <code>26~51</code>，字符 <code>0~9</code>对应索引 <code>52~61</code>，最后两个索引 <code>62</code>、<code>63</code>分别用字符 <code>+</code>和 <code>/</code>表示。</p>
<p>在Java中，二进制数据就是 <code>byte[]</code>数组。Java标准库提供了 <code>Base64</code>来对 <code>byte[]</code>数组进行编解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码后得到 <code>5Lit</code>4个字符。要对 <code>Base64</code>解码，仍然用 <code>Base64</code>这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的童鞋会问：如果输入的 <code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个 <code>0x00</code>，编码后，在结尾加一个 <code>=</code>表示补充了1个 <code>0x00</code>，加两个 <code>=</code>表示补充了2个 <code>0x00</code>，解码的时候，去掉末尾补充的一个或两个 <code>0x00</code>即可。</p>
<p>实际上，因为编码后的长度加上 <code>=</code>总是4的倍数，所以即使不加 <code>=</code>也可以计算出原始输入的 <code>byte[]</code>。Base64编码的时候可以用 <code>withoutPadding()</code>去掉 <code>=</code>，解码出来的结果是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span>, <span class="number">0x21</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        System.out.println(b64encoded2);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为标准的Base64编码会出现 <code>+</code>、<code>/</code>和 <code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把 <code>+</code>变成 <code>-</code>，<code>/</code>变成 <code>_</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getUrlEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getUrlDecoder().decode(b64encoded);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p>
<p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p>
<p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。</p>
<p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p>
<h2 id="哈希算法">哈希算法</h2>
<p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p>
<p>哈希算法最重要的特点就是：</p>
<ul>
<li>同的输入一定得到相同的输出；</li>
<li>不同的输入大概率得到不同的输出。</li>
</ul>
<p>哈希算法的目的就是为了验证原始数据是否被篡改。</p>
<p>Java字符串的 <code>hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节 <code>int</code>整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.hashCode(); <span class="comment">// 0x5e918d2</span></span><br><span class="line"><span class="string">&quot;hello, java&quot;</span>.hashCode(); <span class="comment">// 0x7a9d88e8</span></span><br><span class="line"><span class="string">&quot;hello, bob&quot;</span>.hashCode(); <span class="comment">// 0xa0dbae2f</span></span><br></pre></td></tr></table></figure>
<p>两个相同的字符串永远会计算出相同的 <code>hashCode</code>，否则基于 <code>hashCode</code>定位的 <code>HashMap</code>就无法正常工作。这也是为什么当我们自定义一个class时，覆写 <code>equals()</code>方法时我们必须正确覆写 <code>hashCode()</code>方法。</p>
<h3 id="哈希碰撞">哈希碰撞</h3>
<p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;AaAaAa&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br><span class="line"><span class="string">&quot;BBAaBB&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br></pre></td></tr></table></figure>
<p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code>的 <code>hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p>
<p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p>
<ul>
<li>碰撞概率低；</li>
<li>不能猜测输出。</li>
</ul>
<p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashA(<span class="string">&quot;java001&quot;</span>) = <span class="string">&quot;123456&quot;</span></span><br><span class="line">hashA(<span class="string">&quot;java002&quot;</span>) = <span class="string">&quot;123457&quot;</span></span><br><span class="line">hashA(<span class="string">&quot;java003&quot;</span>) = <span class="string">&quot;123458&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么很容易从输出 <code>123459</code>反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashB(<span class="string">&quot;java001&quot;</span>) = <span class="string">&quot;123456&quot;</span></span><br><span class="line">hashB(<span class="string">&quot;java002&quot;</span>) = <span class="string">&quot;580271&quot;</span></span><br><span class="line">hashB(<span class="string">&quot;java003&quot;</span>) = ???</span><br></pre></td></tr></table></figure>
<p>常用的哈希算法有：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>输出长度（位）</th>
<th>输出长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>MD5</td>
<td>128 bits</td>
<td>16 bytes</td>
</tr>
<tr>
<td>SHA-1</td>
<td>160 bits</td>
<td>20 bytes</td>
</tr>
<tr>
<td>RipeMD-160</td>
<td>160 bits</td>
<td>20 bytes</td>
</tr>
<tr>
<td>SHA-256</td>
<td>256 bits</td>
<td>32 bytes</td>
</tr>
<tr>
<td>SHA-512</td>
<td>512 bits</td>
<td>64 bytes</td>
</tr>
</tbody>
</table>
<p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p>
<p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>MessageDigest</code>时，我们首先根据哈希算法获取一个 <code>MessageDigest</code>实例，然后，反复调用 <code>update(byte[])</code>输入数据。当输入结束后，调用 <code>digest()</code>方法获得 <code>byte[]</code>数组表示的摘要，最后，把它转换为十六进制的字符串。</p>
<p>运行上述代码，可以得到输入 <code>HelloWorld</code>的MD5是 <code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p>
<p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p>
<p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1305351978745921/l" alt="file-md5"></p>
<p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p>
<p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p>
<ul>
<li>数据库管理员能够看到用户明文口令；</li>
<li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li>
</ul>
<p>不存储用户的原始口令，那么如何对用户进行认证？</p>
<p>方法是存储用户口令的哈希，例如，MD5。</p>
<p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>
<p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p>
<table>
<thead>
<tr>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>bob</td>
<td>f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td>alice</td>
<td>25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td>tim</td>
<td>bed128365216c019988915ed3add75fb</td>
</tr>
</tbody>
</table>
<p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p>
<p>使用哈希口令时，还要注意防止彩虹表攻击。</p>
<p>什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p>
<p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p>
<table>
<thead>
<tr>
<th>常用口令</th>
<th>MD5</th>
</tr>
</thead>
<tbody>
<tr>
<td>hello123</td>
<td>f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td>12345678</td>
<td>25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td>passw0rd</td>
<td>bed128365216c019988915ed3add75fb</td>
</tr>
<tr>
<td>19700101</td>
<td>570da6d5277a646f6552b8832012f5dc</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>20201231</td>
<td>6879c0ae9117b50074ce0a0d4c843060</td>
</tr>
</tbody>
</table>
<p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p>
<p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p>
<p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p>
<p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p>
<p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p>
<p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p>
<p>digest = md5(salt+inputPassword)<br>
经过加盐处理的数据库表，内容如下：</p>
<table>
<thead>
<tr>
<th>username</th>
<th>salt</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>bob</td>
<td>H1r0a</td>
<td>a5022319ff4c56955e22a74abcc2c210</td>
</tr>
<tr>
<td>alice</td>
<td>7$p2w</td>
<td>e5de688c99e961ed6e560b972dab8b6a</td>
</tr>
<tr>
<td>tim</td>
<td>z5Sk9</td>
<td>1eee304b92dc0d105904e7ab58fd2f64</td>
</tr>
</tbody>
</table>
<p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p>
<h3 id="SHA-1">SHA-1</h3>
<p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p>
<p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为 <code>&quot;SHA-1&quot;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，计算SHA-256，我们需要传入名称 <code>&quot;SHA-256&quot;</code>，计算SHA-512，我们需要传入名称 <code>&quot;SHA-512&quot;</code>。Java标准库支持的所有哈希算法可以在<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms">这里</a>查到。</p>
<div class="note info sample simple"><p>注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。</p>
</div>
<h2 id="BouncyCastle">BouncyCastle</h2>
<p>我们知道，Java标准库提供了一系列常用的哈希算法。</p>
<p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p>
<p>方法一：自己写一个，难度很大；</p>
<p>方法二：找一个现成的第三方库，直接使用。</p>
<p><a target="_blank" rel="noopener" href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p>
<p>我们来看一下如何使用BouncyCastle这个第三方提供的算法。</p>
<p>首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是 <code>bcprov-jdk15on-xxx.jar</code>，可以从<a target="_blank" rel="noopener" href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p>
<p>Java标准库的 <code>java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注册BouncyCastle:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 按名称正常调用:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;RipeMD160&quot;</span>);</span><br><span class="line">        md.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，注册BouncyCastle是通过下面的语句实现的：</p>
<blockquote>
<p>Security.addProvider(new BouncyCastleProvider());</p>
</blockquote>
<p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p>
<h2 id="Hmac算法">Hmac算法</h2>
<p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p>
<p>我们回顾一下哈希算法：</p>
<blockquote>
<p>digest = hash(input)</p>
</blockquote>
<p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p>
<blockquote>
<p>digest = hash(salt + input)</p>
</blockquote>
<p>这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p>
<p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>
<p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p>
<blockquote>
<p>HmacMD5 ≈ md5(secure_random_key, input)</p>
</blockquote>
<p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p>
<ul>
<li>HmacMD5使用的key长度是64字节，更安全；</li>
<li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>
<li>Hmac输出和原有的哈希算法长度一致。</li>
</ul>
<p>可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p>
<p>为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        SecretKey key = keyGen.generateKey();</span><br><span class="line">        <span class="comment">// 打印随机生成的key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] skey = key.getEncoded();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, skey).toString(<span class="number">16</span>));</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和MD5相比，使用HmacMD5的步骤是：</p>
<ol>
<li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li>
<li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li>
<li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li>
<li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li>
<li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li>
<li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li>
</ol>
<p>我们可以用 <code>Hmac</code>算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p>
<table>
<thead>
<tr>
<th>username</th>
<th>secret_key (64 bytes)</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>bob</td>
<td>a8c06e05f92e…5e16</td>
<td>7e0387872a57c85ef6dddbaa12f376de</td>
</tr>
<tr>
<td>alice</td>
<td>e6a343693985…f4be</td>
<td>c1f929ac2552642b302e739bc0cdbaac</td>
</tr>
<tr>
<td>tim</td>
<td>f27a973dfdc0…6003</td>
<td>af57651c3a8a73303515804d4af43790</td>
</tr>
</tbody>
</table>
<p>有了Hmac计算的哈希和 <code>SecretKey</code>，我们想要验证怎么办？这时，<code>SecretKey</code>不能从 <code>KeyGenerator</code>生成，而是从一个 <code>byte[]</code>数组恢复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hkey = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">106</span>, <span class="number">70</span>, -<span class="number">110</span>, <span class="number">125</span>, <span class="number">39</span>, -<span class="number">20</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">9</span>, -<span class="number">19</span>, -<span class="number">72</span>, <span class="number">52</span>, -<span class="number">53</span>, <span class="number">52</span>, -<span class="number">45</span>, -<span class="number">6</span>, <span class="number">119</span>, -<span class="number">63</span>,</span><br><span class="line">                <span class="number">30</span>, <span class="number">20</span>, -<span class="number">83</span>, -<span class="number">28</span>, <span class="number">77</span>, <span class="number">98</span>, <span class="number">109</span>, -<span class="number">32</span>, -<span class="number">76</span>, <span class="number">121</span>, -<span class="number">106</span>, <span class="number">0</span>, -<span class="number">74</span>, -<span class="number">107</span>, -<span class="number">114</span>, -<span class="number">45</span>, <span class="number">104</span>, -<span class="number">104</span>, -<span class="number">8</span>, <span class="number">2</span>, <span class="number">121</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">97</span>, -<span class="number">18</span>, -<span class="number">13</span>, -<span class="number">63</span>, -<span class="number">30</span>, -<span class="number">125</span>, -<span class="number">103</span>, -<span class="number">80</span>, -<span class="number">46</span>, <span class="number">113</span>, -<span class="number">14</span>, <span class="number">68</span>, <span class="number">32</span>, -<span class="number">46</span>, <span class="number">101</span>, -<span class="number">116</span>, -<span class="number">104</span>, -<span class="number">81</span>, -<span class="number">108</span>, <span class="number">122</span>,</span><br><span class="line">                <span class="number">89</span>, -<span class="number">106</span>, -<span class="number">109</span> &#125;;</span><br><span class="line"></span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(hkey, <span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        <span class="comment">// [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恢复 <code>SecretKey</code>的语句就是 <code>new SecretKeySpec(hkey, &quot;HmacMD5&quot;)</code>。</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p>对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1306480187801666/l" alt="winrar"></p>
<p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p>
<blockquote>
<p>secret = encrypt(key, message);</p>
</blockquote>
<p>而解密则相反，它接收密码和密文，然后输出明文：</p>
<blockquote>
<p>plain = decrypt(key, secret);</p>
</blockquote>
<p>在软件开发中，常用的对称加密算法有：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>密钥长度</th>
<th>工作模式</th>
<th>填充模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>DES</td>
<td>56/64</td>
<td>ECB/CBC/PCBC/CTR/…</td>
<td>NoPadding/PKCS5Padding/…</td>
</tr>
<tr>
<td>AES</td>
<td>128/192/256</td>
<td>ECB/CBC/PCBC/CTR/…</td>
<td>NoPadding/PKCS5Padding/PKCS7Padding/…</td>
</tr>
<tr>
<td>IDEA</td>
<td>128</td>
<td>ECB</td>
<td>PKCS5Padding/PKCS7Padding/…</td>
</tr>
</tbody>
</table>
<p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p>
<p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p>
<h3 id="使用AES加密">使用AES加密</h3>
<p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p>
<ol>
<li>根据算法名称/工作模式/填充模式获取Cipher实例；</li>
<li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li>
<li>使用SerectKey初始化Cipher实例，并设置加密或解密模式；</li>
<li>传入明文或密文，获得密文或明文。</li>
</ol>
<p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        SecureRandom sr = SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="keyword">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] iv = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] join(<span class="keyword">byte</span>[] bs1, <span class="keyword">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] r = <span class="keyword">new</span> <span class="keyword">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CBC模式下，需要一个随机生成的16字节IV参数，必须使用 <code>SecureRandom</code>生成。因为多了一个 <code>IvParameterSpec</code>实例，因此，初始化方法需要调用 <code>Cipher</code>的一个重载方法并传入 <code>IvParameterSpec</code>。</p>
<p>观察输出，可以发现每次生成的IV不同，密文也不同。</p>
<h2 id="口令加密算法">口令加密算法</h2>
<p>上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。</p>
<p>这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p>
<p>但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？</p>
<p>实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p>
<p>PBE就是Password Based Encryption的缩写，它的作用如下：</p>
<blockquote>
<p>key = generate(userPassword, secureRandomPassword);</p>
</blockquote>
<p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密口令:</span></span><br><span class="line">        String password = <span class="string">&quot;hello12345&quot;</span>;</span><br><span class="line">        <span class="comment">// 16 bytes随机Salt:</span></span><br><span class="line">        <span class="keyword">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="number">16</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;salt: %032x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, salt));</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(password, salt, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(password, salt, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是 <code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用 <code>Cipher</code>的 <code>init()</code>方法时同时传入 <code>SecretKey</code>和 <code>PBEParameterSpec</code>实现的。在创建 <code>PBEParameterSpec</code>的时候，我们还指定了循环次数 <code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>
<p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>
<h2 id="密钥交换算法">密钥交换算法</h2>
<p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p>
<p>现在问题来了：如何传递密钥？</p>
<p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p>
<p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p>
<p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p>
<p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p>
<ol>
<li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数a，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li>
<li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li>
<li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li>
</ol>
<p>所以最终双方协商出的密钥 <code>s</code>是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的 <code>p</code>，<code>g</code>，<code>A</code>和 <code>B</code>是无法推算出s的，因为实际算法选择的素数是非常大的。</p>
<p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>
<p>如果我们把 <code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥 <code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的 <code>secretKey</code>是相同的。</p>
<p>使用Java实现DH算法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyAgreement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bob和Alice:</span></span><br><span class="line">        Person bob = <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自生成KeyPair:</span></span><br><span class="line">        bob.generateKeyPair();</span><br><span class="line">        alice.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双方交换各自的PublicKey:</span></span><br><span class="line">        <span class="comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        bob.generateSecretKey(alice.publicKey.getEncoded());</span><br><span class="line">        <span class="comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        alice.generateSecretKey(bob.publicKey.getEncoded());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查双方的本地密钥是否相同:</span></span><br><span class="line">        bob.printKeys();</span><br><span class="line">        alice.printKeys();</span><br><span class="line">        <span class="comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地KeyPair:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            kpGen.initialize(<span class="number">512</span>);</span><br><span class="line">            KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">            <span class="keyword">this</span>.privateKey = kp.getPrivate();</span><br><span class="line">            <span class="keyword">this</span>.publicKey = kp.getPublic();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSecretKey</span><span class="params">(<span class="keyword">byte</span>[] receivedPubKeyBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从byte[]恢复PublicKey:</span></span><br><span class="line">            X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(receivedPubKeyBytes);</span><br><span class="line">            KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            PublicKey receivedPublicKey = kf.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 生成本地密钥:</span></span><br><span class="line">            KeyAgreement keyAgreement = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            keyAgreement.init(<span class="keyword">this</span>.privateKey); <span class="comment">// 自己的PrivateKey</span></span><br><span class="line">            keyAgreement.doPhase(receivedPublicKey, <span class="keyword">true</span>); <span class="comment">// 对方的PublicKey</span></span><br><span class="line">            <span class="comment">// 生成SecretKey密钥:</span></span><br><span class="line">            <span class="keyword">this</span>.secretKey = keyAgreement.generateSecret();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Name: %s\n&quot;</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Private key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.privateKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Public key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.publicKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secret key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.secretKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p>
<h2 id="非对称加密算法">非对称加密算法</h2>
<p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p>
<p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p>
<p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p>
<p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p>
<p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要 <code>N*(N-1)/2</code>个密钥，因此每个人需要管理 <code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p>
<p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p>
<ol>
<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>
<li>小红用自己的RSA私钥解密得到AES口令；</li>
<li>双方使用这个共享的AES口令用AES加密通信。</li>
</ol>
<p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p>
<p>Java标准库提供了RSA算法的实现，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 明文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] plain = <span class="string">&quot;Hello, encrypt use RSA&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建公钥／私钥对:</span></span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 用Alice的公钥加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] pk = alice.getPublicKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;public key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, pk)));</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = alice.encrypt(plain);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 用Alice的私钥解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sk = alice.getPrivateKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;private key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sk)));</span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = alice.decrypt(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 私钥:</span></span><br><span class="line">    PrivateKey sk;</span><br><span class="line">    <span class="comment">// 公钥:</span></span><br><span class="line">    PublicKey pk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 生成公钥／私钥对:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        <span class="keyword">this</span>.sk = kp.getPrivate();</span><br><span class="line">        <span class="keyword">this</span>.pk = kp.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把私钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPrivateKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把公钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPublicKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">this</span>.pk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">this</span>.sk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RSA的公钥和私钥都可以通过 <code>getEncoded()</code>方法获得以 <code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从 <code>byte[]</code>数组恢复公钥或私钥，可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] pkData = ...</span><br><span class="line"><span class="keyword">byte</span>[] skData = ...</span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="comment">// 恢复公钥:</span></span><br><span class="line">X509EncodedKeySpec pkSpec = <span class="keyword">new</span> X509EncodedKeySpec(pkData);</span><br><span class="line">PublicKey pk = kf.generatePublic(pkSpec);</span><br><span class="line"><span class="comment">// 恢复私钥:</span></span><br><span class="line">PKCS8EncodedKeySpec skSpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(skData);</span><br><span class="line">PrivateKey sk = kf.generatePrivate(skSpec);</span><br></pre></td></tr></table></figure>
<p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>
<p>如果修改待加密的 <code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p>
<p>此外，只使用非对称加密算法不能防止中间人攻击。</p>
<h2 id="签名算法">签名算法</h2>
<p>我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p>
<p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p>
<p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p>
<p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如 <code>小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认 <code>小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p>
<p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p>
<p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>
<blockquote>
<p>signature = encrypt(privateKey, sha256(message))</p>
</blockquote>
<p>对签名进行验证实际上就是用公钥解密：</p>
<blockquote>
<p>hash = decrypt(publicKey, signature)</p>
</blockquote>
<p>然后把解密后的哈希与原始消息的哈希进行对比。</p>
<p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p>
<p>常用数字签名算法有：</p>
<ul>
<li>MD5withRSA</li>
<li>SHA1withRSA</li>
<li>SHA256withRSA</li>
</ul>
<p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        PrivateKey sk = kp.getPrivate();</span><br><span class="line">        PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待签名的消息:</span></span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, I am Bob!&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用私钥签名:</span></span><br><span class="line">        Signature s = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        s.initSign(sk);</span><br><span class="line">        s.update(message);</span><br><span class="line">        <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用公钥验证:</span></span><br><span class="line">        Signature v = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        v.initVerify(pk);</span><br><span class="line">        v.update(message);</span><br><span class="line">        <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">        System.out.println(<span class="string">&quot;valid? &quot;</span> + valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p>
<h3 id="DSA签名">DSA签名</h3>
<p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>
<p>DSA只能配合SHA使用，常用的算法有：</p>
<ul>
<li>SHA1withDSA</li>
<li>SHA256withDSA</li>
<li>SHA512withDSA</li>
</ul>
<p>和RSA数字签名相比，DSA的优点是更快。</p>
<h3 id="ECDSA签名">ECDSA签名</h3>
<p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>
<h2 id="数字证书">数字证书</h2>
<p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>
<p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>
<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p>
<p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1311504758472770/l" alt="cert"></p>
<p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p>
<p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keytool -storepass <span class="number">123456</span> -genkeypair -keyalg RSA -keysize <span class="number">1024</span> -sigalg SHA1withRSA -validity <span class="number">3650</span> -alias mycert -keystore my.keystore -dname <span class="string">&quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot;</span></span><br></pre></td></tr></table></figure>
<p>几个主要的参数是：</p>
<ul>
<li>keyalg：指定RSA加密算法；</li>
<li>sigalg：指定SHA1withRSA签名算法；</li>
<li>validity：指定证书有效期3650天；</li>
<li>alias：指定证书在程序中引用的名称；</li>
<li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>
</ul>
<p>执行上述命令，JDK会在当前目录创建一个 <code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是 <code>mycert</code>。</p>
<p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, use X.509 cert!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取KeyStore:</span></span><br><span class="line">        KeyStore ks = loadKeyStore(<span class="string">&quot;/my.keystore&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取私钥:</span></span><br><span class="line">        PrivateKey privateKey = (PrivateKey) ks.getKey(<span class="string">&quot;mycert&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">        <span class="comment">// 读取证书:</span></span><br><span class="line">        X509Certificate certificate = (X509Certificate) ks.getCertificate(<span class="string">&quot;mycert&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 签名:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sign)));</span><br><span class="line">        <span class="comment">// 验证签名:</span></span><br><span class="line">        <span class="keyword">boolean</span> verified = verify(certificate, message, sign);</span><br><span class="line">        System.out.println(<span class="string">&quot;verify: &quot;</span> + verified);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">loadKeyStore</span><span class="params">(String keyStoreFile, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;file not found in classpath: &quot;</span> + keyStoreFile);</span><br><span class="line">            &#125;</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            ks.load(input, password.toCharArray());</span><br><span class="line">            <span class="keyword">return</span> ks;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(X509Certificate certificate, <span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(PrivateKey privateKey, <span class="keyword">byte</span>[] data) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class="keyword">byte</span>[] message)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(X509Certificate certificate, <span class="keyword">byte</span>[] message, <span class="keyword">byte</span>[] sig)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initVerify(certificate);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.verify(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以 <code>PrivateKey</code>实例表示，公钥以 <code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p>
<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>
<ol>
<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>
<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>
<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商 <code>DigiNotar</code>就发生过私钥泄漏导致公司破产的事故。</p>
<h1>多线程</h1>
<p>多线程是Java最基本的一种并发模型，本章我们将详细介绍Java多线程编程。</p>
<h2 id="多线程基础">多线程基础</h2>
<h3 id="进程">进程</h3>
<p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。<br>
┌──────────┐<br>
│Process   │<br>
│┌────────┐│<br>
┌──────────┐││ Thread ││┌──────────┐<br>
│Process   ││└────────┘││Process   │<br>
│┌────────┐││┌────────┐││┌────────┐│<br>
┌──────────┐││ Thread ││││ Thread ││││ Thread ││<br>
│Process   ││└────────┘││└────────┘││└────────┘│<br>
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│<br>
││ Thread ││││ Thread ││││ Thread ││││ Thread ││<br>
│└────────┘││└────────┘││└────────┘││└────────┘│<br>
└──────────┘└──────────┘└──────────┘└──────────┘<br>
┌──────────────────────────────────────────────┐<br>
│               Operating System               │<br>
└──────────────────────────────────────────────┘<br>
操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>
<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>
<p>多进程模式（每个进程只有一个线程）：</p>
<p>┌──────────┐ ┌──────────┐ ┌──────────┐<br>
│Process   │ │Process   │ │Process   │<br>
│┌────────┐│ │┌────────┐│ │┌────────┐│<br>
││ Thread ││ ││ Thread ││ ││ Thread ││<br>
│└────────┘│ │└────────┘│ │└────────┘│<br>
└──────────┘ └──────────┘ └──────────┘<br>
多线程模式（一个进程有多个线程）：</p>
<p>┌────────────────────┐<br>
│Process             │<br>
│┌────────┐┌────────┐│<br>
││ Thread ││ Thread ││<br>
│└────────┘└────────┘│<br>
│┌────────┐┌────────┐│<br>
││ Thread ││ Thread ││<br>
│└────────┘└────────┘│<br>
└────────────────────┘<br>
多进程＋多线程模式（复杂度最高）：</p>
<p>┌──────────┐┌──────────┐┌──────────┐<br>
│Process   ││Process   ││Process   │<br>
│┌────────┐││┌────────┐││┌────────┐│<br>
││ Thread ││││ Thread ││││ Thread ││<br>
│└────────┘││└────────┘││└────────┘│<br>
│┌────────┐││┌────────┐││┌────────┐│<br>
││ Thread ││││ Thread ││││ Thread ││<br>
│└────────┘││└────────┘││└────────┘│<br>
└──────────┘└──────────┘└──────────┘</p>
<h3 id="进程-vs-线程">进程 vs 线程</h3>
<p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。<br>
而多进程的优点在于：</li>
</ul>
<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
<h3 id="多线程">多线程</h3>
<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行 <code>main()</code>方法，在 <code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p>
<h2 id="创建新线程">创建新线程</h2>
<p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行 <code>main()</code>方法。在 <code>main()</code>方法中，我们又可以启动其他线程。</p>
<p>要创建一个新线程非常容易，我们需要实例化一个 <code>Thread</code>实例，然后调用它的 <code>start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p>
<p>方法一：从 <code>Thread</code>派生一个自定义类，然后覆写 <code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，注意到 <code>start()</code>方法会在内部自动调用实例的 <code>run()</code>方法。</p>
<p>方法二：创建 <code>Thread</code>实例时，传入一个 <code>Runnable</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用Java8引入的 <code>lambda</code>语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用线程执行的打印语句，和直接在main()方法执行有区别吗？</p>
<p>区别大了去了。我们看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>线程执行的代码有4行，首先打印 <code>main start</code>，然后创建 <code>Thread</code>对象，紧接着调用 <code>start()</code>启动新线程。当 <code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量t来表示这个新线程对象，并开始执行。</p>
<p>接着，<code>main</code>线程继续执行打印 <code>main end</code>语句，而t线程在 <code>main</code>线程执行的同时会并发执行，打印 <code>thread run</code>和 <code>thread end</code>语句。</p>
<p>当 <code>run()</code>方法结束时，新线程就结束了。而 <code>main()</code>方法结束时，主线程也结束了。</p>
<p>我们再来看线程的执行顺序：</p>
<ol>
<li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；<br>
2.<code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li>
</ol>
<p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在 <code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从 <code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p>
<p>要模拟并发执行的效果，我们可以在线程中调用 <code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到 <code>main</code>线程和 <code>t</code>线程执行的先后顺序。</p>
<p>要特别注意：直接调用 <code>Thread</code>实例的 <code>run()</code>方法是无效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>直接调用 <code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在 <code>main()</code>方法内部又调用了 <code>run()</code>方法，打印 <code>hello</code>语句是在 <code>main</code>线程中执行的，没有任何新线程被创建。</p>
<p>必须调用 <code>Thread</code>实例的 <code>start()</code>方法才能启动新线程，如果我们查看 <code>Thread</code>类的源代码，会看到 <code>start()</code>方法内部调用了一个 <code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>
<h3 id="线程的优先级">线程的优先级</h3>
<p>可以对线程设定优先级，设定优先级的方法是：</p>
<blockquote>
<p>Thread.setPriority(int n) // 1~10, 默认值5</p>
</blockquote>
<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
<p><code>n</code>越大，优先级越高</p>
<h2 id="线程状态">线程状态</h2>
<p>在Java程序中，一个线程对象只能调用一次 <code>start()</code>方法启动新线程，并在新线程中执行 <code>run()</code>方法。一旦 <code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>
<ul>
<li><code>New</code>：新创建的线程，尚未执行；</li>
<li><code>Runnable</code>：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li><code>Blocked</code>：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li><code>Waiting</code>：运行中的线程，因为某些操作在等待中；</li>
<li><code>Timed Waiting</code>：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li><code>Terminated</code>：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p>用一个状态转移图表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│     New     │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br></pre></td></tr></table></figure>
<p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>
┌─────────────┐ ┌─────────────┐<br>
││  Runnable   │ │   Blocked   ││<br>
└─────────────┘ └─────────────┘<br>
│┌─────────────┐ ┌─────────────┐│<br>
│   Waiting   │ │Timed Waiting│<br>
│└─────────────┘ └─────────────┘│<br>
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─<br>
│<br>
▼<br>
┌─────────────┐<br>
│ Terminated  │<br>
└─────────────┘<br>
当线程启动后，它可以在 <code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和 <code>Timed Waiting</code>这几个状态之间切换，直到最后变成 <code>Terminated</code>状态，线程终止。</p>
<p>线程终止的原因有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到return语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动 <code>t</code>线程后，可以通过 <code>t.join()</code>等待t线程结束后再继续运行：</p>
<p>当 <code>main</code>线程对线程对象 <code>t</code>调用 <code>join()</code>方法时，主线程将等待变量t表示的线程运行结束，即 <code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是 <code>main</code>线程先打印 <code>start</code>，<code>t</code>线程再打印 <code>hello</code>，<code>main</code>线程最后再打印 <code>end</code>。</p>
<p>如果t线程已经结束，对实例t调用 <code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>
<h2 id="中断线程">中断线程</h2>
<p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行 <code>run()</code>方法，使得自身线程能立刻结束运行。</p>
<p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>
<p>中断一个线程非常简单，只需要在其他线程中对目标线程调用 <code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<p>我们还是看示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure>
<p>仔细看上述代码，<code>main</code>线程通过调用 <code>t.interrupt()</code>方法中断t线程，但是要注意，<code>interrupt()</code>方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而t线程的 <code>while</code>循环会检测 <code>isInterrupted()</code>，所以上述代码能正确响应 <code>interrupt()</code>请求，使得自身立刻结束运行 <code>run()</code>方法。</p>
<p>如果线程处于等待状态，例如，<code>t.join()</code>会让 <code>main</code>线程进入等待状态，此时，如果对 <code>main</code>线程调用 <code>interrupt()</code>，<code>join()</code>方法会立刻抛出 <code>InterruptedException</code>，因此，目标线程只要捕获到 <code>join()</code>方法抛出的 <code>InterruptedException</code>，就说明有其他线程对其调用了 <code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>
<p>我们来看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// 2 hello!</span></span><br><span class="line"><span class="comment">// 3 hello!</span></span><br><span class="line"><span class="comment">// 4 hello!</span></span><br><span class="line"><span class="comment">// 5 hello!</span></span><br><span class="line"><span class="comment">// 6 hello!</span></span><br><span class="line"><span class="comment">// 7 hello!</span></span><br><span class="line"><span class="comment">// 8 hello!</span></span><br><span class="line"><span class="comment">// 9 hello!</span></span><br><span class="line"><span class="comment">// 10 hello!</span></span><br><span class="line"><span class="comment">// interrupted!</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure>
<p><code>main</code>线程通过调用 <code>t.interrupt()</code>从而通知t线程中断，而此时 <code>t</code>线程正位于 <code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出 <code>InterruptedException</code>。由于我们在t线程中捕获了 <code>InterruptedException</code>，因此，就可以准备结束该线程。在t线程结束前，对 <code>hello</code>线程也进行了 <code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现 <code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>
<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个 <code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把 <code>HelloThread.running</code>置为 <code>false</code>，就可以让线程结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// end!</span></span><br></pre></td></tr></table></figure>
<p>注意到 <code>HelloThread</code>的标志位 <code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用 <code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p>为什么要对线程间共享的变量用关键字 <code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p>
<p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>
Main Memory<br>
│                               │<br>
┌───────┐┌───────┐┌───────┐<br>
│  │ var A ││ var B ││ var C │  │<br>
└───────┘└───────┘└───────┘<br>
│     │ ▲               │ ▲     │<br>
─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─<br>
│ │               │ │<br>
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐<br>
▼ │               ▼ │<br>
│  ┌───────┐  │   │  ┌───────┐  │<br>
│ var A │         │ var C │<br>
│  └───────┘  │   │  └───────┘  │<br>
Thread 1          Thread 2<br>
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘<br>
这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量 <code>a = true</code>，线程1执行 <code>a = false</code>时，它在此刻仅仅是把变量a的副本变成了 <code>false</code>，主内存的变量 <code>a</code>还是 <code>true</code>，在JVM把修改后的a回写到主内存之前，其他线程读取到的 <code>a</code>的值仍然是 <code>true</code>，这就造成了多线程之间共享的变量不一致。</p>
<p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<p>如果我们去掉 <code>volatile</code>关键字，运行上述程序，发现效果和带 <code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>
<h2 id="守护线程">守护线程</h2>
<p>Java程序入口就是由JVM启动 <code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p>
<p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p>
<p>答案是使用 <code>守护线程（Daemon Thread）</code>。</p>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用 <code>start()</code>方法前，调用 <code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<h2 id="线程同步">线程同步</h2>
<p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很简单，两个线程同时对一个 <code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>
<p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>
<p>例如，对于语句：</p>
<blockquote>
<p>n = n + 1;<br>
看上去是一行语句，实际上对应了3条指令：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>
<p>我们假设n的值是100，如果两个线程同时执行 <code>n = n + 1</code>，得到的结果很可能不是102，而是101，原因在于：</p>
<p>┌───────┐    ┌───────┐<br>
│Thread1│    │Thread2│<br>
└───┬───┘    └───┬───┘<br>
│            │<br>
│ILOAD (100) │<br>
│            │ILOAD (100)<br>
│            │IADD<br>
│            │ISTORE (101)<br>
│IADD        │<br>
│ISTORE (101)│<br>
▼            ▼<br>
如果线程1在执行 <code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行 <code>ILOAD</code>后获取的值仍然是 <code>100</code>，最终结果被两个线程的 <code>ISTORE</code>写入后变成了 <code>101</code>，而不是期待的 <code>102</code>。</p>
<p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>
<p>┌───────┐     ┌───────┐<br>
│Thread1│     │Thread2│<br>
└───┬───┘     └───┬───┘<br>
│             │<br>
│-- lock –   │<br>
│ILOAD (100)  │<br>
│IADD         │<br>
│ISTORE (101) │<br>
│-- unlock – │<br>
│             │-- lock –<br>
│             │ILOAD (101)<br>
│             │IADD<br>
│             │ISTORE (102)<br>
│             │-- unlock –<br>
▼             ▼</p>
<p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 <code>临界区（Critical Section）</code>，任何时候临界区最多只有一个线程能执行。</p>
<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用 <code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用 <code>synchronized</code>改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>
<p>它表示用 <code>Counter.lock</code>实例作为锁，两个线程在执行各自的 <code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在 <code>synchronized</code>语句块结束会自动释放锁。这样一来，对 <code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p>
<p>使用 <code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为 <code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p>
<p>我们来概括一下如何使用 <code>synchronized</code>：</p>
<ol>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li>
</ol>
<p>在使用 <code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在 <code>synchronized</code>结束处正确释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看一个错误使用 <code>synchronized</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock1) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock2) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果并不是0，这是因为两个线程各自的 <code>synchronized</code>锁住的不是同一个对象！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p>
<p>因此，使用 <code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p>
<p>我们再看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> Thread[] &#123; <span class="keyword">new</span> AddStudentThread(), <span class="keyword">new</span> DecStudentThread(), <span class="keyword">new</span> AddTeacherThread(), <span class="keyword">new</span> DecTeacherThread() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> studentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> teacherCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是 <code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的 <code>Counter.studentCount += 1</code>和 <code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和 <code>DecStudentThread</code>，<code>AddTeacherThread</code>和 <code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p>
<p><code>AddStudentThread</code>和 <code>DecStudentThread</code>使用 <code>lockStudent</code>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AddTeacherThread</code>和 <code>DecTeacherThread</code>使用 <code>lockTeacher</code>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样才能最大化地提高执行效率。</p>
<h3 id="不需要synchronized的操作">不需要synchronized的操作</h3>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p><code>long</code>和 <code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在 <code>x64</code>平台的JVM是把 <code>long</code>和 <code>double</code>的赋值作为原子操作实现的。</p>
<p>单条原子操作的语句不需要同步。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就不需要同步。</p>
<p>对引用也是类似。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述赋值语句并不需要同步。</p>
<p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.last = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pair;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; first, last &#125;;</span><br><span class="line">        <span class="keyword">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就不再需要同步，因为 <code>this.pair = ps</code>是引用赋值的原子操作。而语句：</p>
<blockquote>
<p>int[] ps = new int[] { first, last };</p>
</blockquote>
<p>这里的 <code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p>
<h2 id="同步方法">同步方法</h2>
<p>我们知道Java程序依靠 <code>synchronized</code>对线程进行同步，使用 <code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把 <code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，线程调用 <code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为 <code>synchronized</code>代码块在 <code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是 <code>this</code>，即当前实例，这又使得创建多个 <code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = Counter();</span><br><span class="line"><span class="keyword">var</span> c2 = Counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c1进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.dec();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c2进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.dec();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>现在，对于 <code>Counter</code>类，多线程可以正确调用。</p>
<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是 <code>“线程安全”</code>的（<code>thread-safe</code>），上面的 <code>Counter</code>类就是线程安全的。Java标准库的 <code>java.lang.StringBuffer</code>也是线程安全的。</p>
<p>还有一些不变类，例如 <code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是 <code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>除了上述几种少数情况，大部分类，例如 <code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么 <code>ArrayList</code>是可以安全地在线程间共享的。</p>
<div class="note info simple"><p>没有特殊说明时，一个类默认是非线程安全的。</p>
</div>
<p>我们再观察 <code>Counter</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们锁住的是 <code>this</code>实例时，实际上可以用 <code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
<p>因此，用 <code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用this实例加锁。</p>
<p>我们再思考一下，如果对一个静态方法添加 <code>synchronized</code>修饰符，它锁住的是哪个对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>static</code>方法，是没有 <code>this</code>实例的，因为 <code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的 <code>Class</code>实例，因此，对 <code>static</code>方法添加 <code>synchronized</code>，锁住的是该类的Class实例。上述 <code>synchronized static</code>方法实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再考察 <code>Counter</code>的 <code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它没有同步，因为读一个 <code>int</code>变量不需要同步。</p>
<p>然而，如果我们把代码稍微改一下，返回一个包含两个 <code>int</code>的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pair p = <span class="keyword">new</span> Pair();</span><br><span class="line">        p.first = first;</span><br><span class="line">        p.last = last;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就必须要同步了。</p>
<h2 id="死锁">死锁</h2>
<p>Java的线程锁是可重入的锁。</p>
<p>什么是可重入的锁？我们还是来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 <code>synchronized</code>修饰的 <code>add()</code>方法，一旦线程执行到 <code>add()</code>方法内部，说明它已经获取了当前实例的 <code>this</code>锁。如果传入的 <code>n &lt; 0</code>，将在 <code>add()</code>方法内部调用 <code>dec()</code>方法。由于 <code>dec()</code>方法也需要获取 <code>this</code>锁，现在问题来了：</p>
<p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>
<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p>
<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录 <code>+1</code>，每退出 <code>synchronized</code>块，记录 <code>-1</code>，减到 <code>0</code>的时候，才会真正释放锁。</p>
<h3 id="死锁-2">死锁</h3>
<p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="keyword">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="keyword">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行 <code>add()</code>和 <code>dec()</code>方法时：</p>
<ul>
<li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li>
<li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>
<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>
<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取lockA，再获取 <code>lockB</code>的顺序，改写 <code>dec()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用wait和notify">使用wait和notify</h2>
<p>在Java程序中，synchronized解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用synchronized加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 <code>synchronized</code>并没有解决多线程协调的问题。</p>
<p>仍然以上面的 <code>TaskQueue</code>为例，我们再编写一个 <code>getTask()</code>方法取出队列的第一个任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>
<p>但实际上 <code>while()</code>循环永远不会退出。因为线程在执行 <code>while()</code>循环时，已经在 <code>getTask()</code>入口获取了 <code>this</code>锁，其他线程根本无法调用 <code>addTask()</code>，因为 <code>addTask()</code>执行条件也是获取 <code>this</code>锁。</p>
<p>因此，执行上述代码，线程会在 <code>getTask()</code>中因为死循环而100%占用CPU资源。</p>
<p>如果深入思考一下，我们想要的执行效果是：</p>
<ul>
<li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li>
<li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li>
</ul>
<p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<p>对于上述 <code>TaskQueue</code>，我们先改造 <code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个线程执行到 <code>getTask()</code>方法内部的 <code>while</code>循环时，它必定已经获取到了 <code>this</code>锁，此时，线程执行 <code>while</code>条件判断，如果条件成立（队列为空），线程将执行 <code>this.wait()</code>，进入等待状态。</p>
<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是 <code>this</code>锁，因此调用 <code>this.wait()</code>。</p>
<p>调用 <code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p>
<p>有些仔细的童鞋会指出：即使线程在 <code>getTask()</code>内部等待，其他线程如果拿不到 <code>this</code>锁，照样无法执行 <code>addTask()</code>，肿么办？</p>
<p>这个问题的关键就在于 <code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在 <code>Object</code>类的一个 <code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在 <code>synchronized</code>块中才能调用 <code>wait()</code>方法，因为 <code>wait()</code>方法调用时，会释放线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>
<p>因此，只能在锁对象上调用 <code>wait()</code>方法。因为在 <code>getTask()</code>中，我们获得了 <code>this</code>锁，因此，只能在 <code>this</code>对象上调用 <code>wait()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个线程在 <code>this.wait()</code>等待时，它就会释放 <code>this</code>锁，从而使得其他线程能够在 <code>addTask()</code>方法获得 <code>this</code>锁。</p>
<p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从 <code>wait()</code>方法返回？答案是在相同的锁对象上调用 <code>notify()</code>方法。我们修改 <code>addTask()</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到在往队列中添加了任务后，线程立刻对 <code>this</code>锁对象调用 <code>notify()</code>方法，这个方法会唤醒一个正在 <code>this</code>锁等待的线程（就是在 <code>getTask()</code>中位于 <code>this.wait()</code>的线程），从而使得等待线程从 <code>this.wait()</code>方法返回。</p>
<p>我们来看一个完整的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> q = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                String s = <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们重点关注 <code>addTask()</code>方法，内部调用了 <code>this.notifyAll()</code>而不是 <code>this.notify()</code>，使用 <code>notifyAll()</code>将唤醒所有当前正在this锁等待的线程，而 <code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在 <code>getTask()</code>方法内部的 <code>wait()</code>中等待，使用 <code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用 <code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p>但是，注意到 <code>wait()</code>方法返回时需要重新获得 <code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行 <code>addTask()</code>的线程结束此方法后，才能释放 <code>this</code>锁，随后，这3个线程中只能有一个获取到 <code>this</code>锁，剩下两个将继续等待。</p>
<p>再注意到我们在 <code>while()</code>循环中调用 <code>wait()</code>，而不是if语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取 <code>this</code>锁。多个线程被唤醒后，只有一个线程能获取 <code>this</code>锁，此刻，该线程执行 <code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取 <code>this</code>锁后执行 <code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在 <code>while</code>循环中 <code>wait()</code>，并且每次被唤醒后拿到 <code>this</code>锁就必须再次判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p>
<h2 id="使用ReentrantLock">使用ReentrantLock</h2>
<p>从Java 5开始，引入了一个高级的处理并发的 <code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>我们知道Java语言直接提供了 <code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>
<p><code>java.util.concurrent.locks</code>包提供的 <code>ReentrantLock</code>用于替代 <code>synchronized</code>加锁，我们来看一下传统的 <code>synchronized</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用 <code>ReentrantLock</code>替代，可以把代码改造为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而 <code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在 <code>finally</code>中正确释放锁。</p>
<p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和 <code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p>
<p>和 <code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回 <code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用 <code>ReentrantLock</code>比直接使用 <code>synchronized</code>更安全，线程在 <code>tryLock()</code>失败的时候不会导致死锁。</p>
<h2 id="使用Condition">使用Condition</h2>
<p>使用 <code>ReentrantLock</code>比直接使用 <code>synchronized</code>更安全，可以替代 <code>synchronized</code>进行线程同步。</p>
<p>但是，<code>synchronized</code>可以配合 <code>wait</code>和 <code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用 <code>ReentrantLock</code>我们怎么编写 <code>wait</code>和 <code>notify</code>的功能呢？</p>
<p>答案是使用 <code>Condition</code>对象来实现 <code>wait</code>和 <code>notify</code>的功能。</p>
<p>我们仍然以 <code>TaskQueue</code>为例，把前面用 <code>synchronized</code>实现的功能通过 <code>ReentrantLock</code>和 <code>Condition</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，使用 <code>Condition</code>时，引用的 <code>Condition</code>对象必须从 <code>Lock</code>实例的 <code>newCondition()</code>返回，这样才能获得一个绑定了 <code>Lock</code>实例的 <code>Condition</code>实例。</p>
<p><code>Condition</code>提供的 <code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和 <code>synchronized</code>锁对象的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
</ul>
<p>唤醒线程从 <code>await()</code>返回后需要重新获得锁。</p>
<p>此外，和 <code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过 <code>signal()</code>或 <code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，使用 <code>Condition</code>配合 <code>Lock</code>，我们可以实现更灵活的线程同步。</p>
<h2 id="使用ReadWriteLock">使用ReadWriteLock</h2>
<p>前面讲到的 <code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用 <code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<p>||读|写|<br>
||–|–|<br>
|读|允许|不允许|<br>
|写|不允许|不允许|</p>
<p>使用 <code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<p>只允许一个线程写入（其他线程既不能写入也不能读取）；<br>
没有写入时，多个线程允许同时读（提高性能）。<br>
用 <code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个 <code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>
<p>使用 <code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用 <code>ReadWriteLock</code>。</p>
<h2 id="使用StampedLock">使用StampedLock</h2>
<p>前面介绍的 <code>ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p>
<p>如果我们深入分析 <code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code>。</p>
<p><code>StampedLock</code>和 <code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>
<p>我们来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过 <code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过 <code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>
<p>可见，<code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是 <code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁。</p>
<p><code>StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在 <code>if-then-update</code>的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
<h2 id="使用Concurrent集合">使用Concurrent集合</h2>
<p>我们在前面已经通过 <code>ReentrantLock</code>和 <code>Condition</code>实现了一个 <code>BlockingQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个 <code>TaskQueue</code>的 <code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>
<p>因为 <code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用Java标准库的 <code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code>。</p>
<p>除了 <code>BlockingQueue</code>外，针对 <code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>
<p>|interface|non-thread-safe|thread-safe|<br>
|List|ArrayList|CopyOnWriteArrayList|<br>
|Map|HashMap|ConcurrentHashMap|<br>
|Set|HashSet / TreeSet|CopyOnWriteArraySet|<br>
|Queue|ArrayDeque / LinkedList|ArrayBlockingQueue / LinkedBlockingQueue|<br>
|Deque|ArrayDeque / LinkedList|LinkedBlockingDeque|</p>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以 <code>ConcurrentHashMap</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 在不同的线程读写:</span></span><br><span class="line">map.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.get(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>
<blockquote>
<p>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</p>
</blockquote>
<p>改为：</p>
<blockquote>
<p>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</p>
</blockquote>
<p>就可以了。</p>
<p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>
<p>但是它实际上是用一个包装类包装了非线程安全的 <code>Map</code>，然后对所有读写方法都用 <code>synchronized</code>加锁，这样获得的线程安全集合的性能比 <code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>
<p>使用 <code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p>
<p>多线程同时读写并发集合是安全的；</p>
<p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p>
<h2 id="使用Atomic">使用Atomic</h2>
<p>Java的 <code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于 <code>java.util.concurrent.atomic</code>包。</p>
<p>我们以 <code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p><code>Atomic</code>类是通过无锁 <code>（lock-free）</code>的方式实现的线程安全 <code>（thread-safe）</code>访问。它的主要原理是利用了 <code>CAS：Compare and Set</code>。</p>
<p>如果我们自己通过CAS编写 <code>incrementAndGet()</code>，它大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS是指，在这个操作中，如果 <code>AtomicInteger</code>的当前值是 <code>prev</code>，那么就更新为 <code>next</code>，返回 <code>true</code>。如果 <code>AtomicInteger</code>的当前值不是 <code>prev</code>，就什么也不干，返回 <code>false</code>。通过CAS操作并配合do … while循环，即使其他线程修改了 <code>AtomicInteger</code>的值，最终的结果也是正确的。</p>
<p>我们利用 <code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    AtomicLong <span class="keyword">var</span> = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，我们并不需要直接用 <code>do ... while</code>循环调用 <code>compareAndSet</code>实现复杂的并发操作，而是用 <code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p>
<p>在高度竞争的情况下，还可以使用Java 8提供的 <code>LongAdder</code>和 <code>LongAccumulator</code>。</p>
<h2 id="使用线程池">使用线程池</h2>
<p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>
<p>如果可以复用一组线程：</p>
<p>┌─────┐ execute  ┌──────────────────┐<br>
│Task1│─────────&gt;│ThreadPool        │<br>
├─────┤          │┌───────┐┌───────┐│<br>
│Task2│          ││Thread1││Thread2││<br>
├─────┤          │└───────┘└───────┘│<br>
│Task3│          │┌───────┐┌───────┐│<br>
├─────┤          ││Thread3││Thread4││<br>
│Task4│          │└───────┘└───────┘│<br>
├─────┤          └──────────────────┘<br>
│Task5│<br>
├─────┤<br>
│Task6│<br>
└─────┘<br>
…<br>
那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p>
<p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>Java标准库提供了 <code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure>
<p>因为 <code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li><code>FixedThreadPool</code>：线程数固定的线程池；</li>
<li><code>CachedThreadPool</code>：线程数根据任务动态调整的线程池；</li>
<li><code>SingleThreadExecutor</code>：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到 <code>Executors</code>这个类中。我们以 <code>FixedThreadPool</code>为例，看看线程池的执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start task 0</span></span><br><span class="line"><span class="comment">// start task 1</span></span><br><span class="line"><span class="comment">// start task 2</span></span><br><span class="line"><span class="comment">// start task 3</span></span><br><span class="line"><span class="comment">// end task 0</span></span><br><span class="line"><span class="comment">// end task 2</span></span><br><span class="line"><span class="comment">// end task 1</span></span><br><span class="line"><span class="comment">// start task 4</span></span><br><span class="line"><span class="comment">// start task 5</span></span><br><span class="line"><span class="comment">// end task 3</span></span><br><span class="line"><span class="comment">// end task 4</span></span><br><span class="line"><span class="comment">// end task 5</span></span><br></pre></td></tr></table></figure>
<p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p>
<p>线程池在程序结束的时候要关闭。使用 <code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p>
<p>如果我们把线程池改为 <code>CachedThreadPool</code>，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p>
<p>如果我们想把线程池的大小限制在 <code>4～10</code>个之间动态调整怎么办？我们查看 <code>Executors.newCachedThreadPool()</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，想创建指定动态范围的线程池，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="ScheduledThreadPool">ScheduledThreadPool</h3>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用 <code>ScheduledThreadPool</code>。放入 <code>ScheduledThreadPool</code>的任务可以定期反复执行。</p>
<p>创建一个 <code>ScheduledThreadPool</code>仍然是通过Executors类：</p>
<blockquote>
<p>ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</p>
</blockquote>
<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>注意 <code>FixedRate</code>和 <code>FixedDelay</code>的区别。<code>FixedRate</code>是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p>
<p>│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░<br>
├───────┼───────┼───────┼───────┼────&gt;<br>
│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│<br>
而 <code>FixedDelay</code>是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>
<p>│░░░│       │░░░░░│       │░░│       │░<br>
└───┼───────┼─────┼───────┼──┼───────┼──&gt;<br>
│&lt;─────&gt;│     │&lt;─────&gt;│  │&lt;─────&gt;│<br>
因此，使用 <code>ScheduledThreadPool</code>时，我们要根据需要选择执行一次、<code>FixedRate</code>执行还是 <code>FixedDelay</code>执行。</p>
<p>细心的童鞋还可以思考下面的问题：</p>
<p>在 <code>FixedRate</code>模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p>
<p>如果任务抛出了异常，后续任务是否继续执行？</p>
<p>Java标准库还提供了一个 <code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个 <code>Timer</code>会对应一个 <code>Thread</code>，所以，一个 <code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个 <code>Timer</code>，而一个 <code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用 <code>ScheduledThreadPool</code>取代旧的 <code>Timer</code>。</p>
<h2 id="使用Future">使用Future</h2>
<p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现 <code>Runnable</code>接口，就可以让线程池去执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个 <code>Callable</code>接口，和 <code>Runnable</code>接口比，它多了一个返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且 <code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<p>现在的问题是，如何获得异步执行的结果？</p>
<p>如果仔细看 <code>ExecutorService.submit()</code>方法，可以看到，它返回了一个 <code>Future</code>类型，一个 <code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>
<p>当我们提交一个 <code>Callable</code>任务后，我们会同时获得一个 <code>Future</code>对象，然后，我们在主线程某个时刻调用 <code>Future</code>对象的 <code>get()</code>方法，就可以获得异步执行的结果。在调用 <code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么 <code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>一个 <code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h2 id="使用CompletableFuture">使用CompletableFuture</h2>
<p>使用 <code>Future</code>获得异步执行结果时，要么调用阻塞方法 <code>get()</code>，要么轮询看 <code>isDone()</code>是否为 <code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p>
<p>从Java 8开始引入了 <code>CompletableFuture</code>，它针对 <code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p>我们以获取股票价格为例，看看如何使用 <code>CompletableFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了串行执行外，多个 <code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑实现的异步查询规则实际上是：</p>
<p>┌─────────────┐ ┌─────────────┐<br>
│ Query Code  │ │ Query Code  │<br>
│  from sina  │ │  from 163   │<br>
└─────────────┘ └─────────────┘<br>
│               │<br>
└───────┬───────┘<br>
▼<br>
┌─────────────┐<br>
│    anyOf    │<br>
└─────────────┘<br>
│<br>
┌───────┴────────┐<br>
▼                ▼<br>
┌─────────────┐  ┌─────────────┐<br>
│ Query Price │  │ Query Price │<br>
│  from sina  │  │  from 163   │<br>
└─────────────┘  └─────────────┘<br>
│                │<br>
└────────┬───────┘<br>
▼<br>
┌─────────────┐<br>
│    anyOf    │<br>
└─────────────┘<br>
│<br>
▼<br>
┌─────────────┐<br>
│Display Price│<br>
└─────────────┘<br>
除了 <code>anyOf()</code>可以实现“任意个 <code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有 <code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意 <code>CompletableFuture</code>的命名规则：</p>
<ul>
<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>
<li><code>xxxAsync()</code>：表示将异步在线程池中执行</li>
</ul>
<h2 id="使用ForkJoin">使用ForkJoin</h2>
<p>Java 7开始引入了一种新的 <code>Fork/Join</code>线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>
<p>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>
还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>
<p>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>
如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p>
<p>┌─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┘<br>
┌─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┘<br>
┌─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┘<br>
┌─┬─┬─┬─┬─┬─┐<br>
└─┴─┴─┴─┴─┴─┘<br>
这就是 <code>Fork/Join</code>任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>
<p>我们来看如何使用 <code>Fork/Join</code>对大数据进行并行求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码的执行过程，一个大的计算任务 <code>0~2000</code>首先分裂为两个小任务 <code>0~1000</code>和 <code>1000~2000</code>，这两个小任务仍然太大，继续分裂为更小的 <code>0~500</code>，<code>500~1000</code>，<code>1000~1500</code>，<code>1500~2000</code>，最后，计算结果被依次合并，得到最终结果。</p>
<p>因此，核心代码 <code>SumTask</code>继承自 <code>RecursiveTask</code>，在 <code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p>
<p>因此，核心代码 <code>SumTask</code>继承自 <code>RecursiveTask</code>，在 <code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Fork/Join</code>线程池在Java标准库中就有应用。Java标准库提供的 <code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过 <code>Fork/Join</code>对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度</p>
<h2 id="使用ThreadLocal">使用ThreadLocal</h2>
<p>多线程是Java实现多任务的基础，<code>Thread</code>对象代表一个线程，我们可以在代码中调用 <code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;start main...&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;run task...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;print...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log(<span class="string">&quot;end main.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    doWork();</span><br><span class="line">    saveStatus();</span><br><span class="line">    sendResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过线程池去执行这些任务。</p>
<p>观察 <code>process()</code>方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p>
<p><code>process()</code>方法需要传递的状态就是 <code>User</code>实例。有的童鞋会想，简单地传入 <code>User</code>就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    checkPermission(user);</span><br><span class="line">    doWork(user);</span><br><span class="line">    saveStatus(user);</span><br><span class="line">    sendResponse(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是往往一个方法又会调用其他很多方法，这样会导致 <code>User</code>传递到所有地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    queryStatus(user);</span><br><span class="line">    checkStatus();</span><br><span class="line">    setNewStatus(user);</span><br><span class="line">    log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为 <code>上下文（Context）</code>，它是一种状态，可以是用户身份、任务信息等。</p>
<p>给每个方法增加一个 <code>context</code>参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，<code>User</code>对象就传不进去了。</p>
<p>Java标准库提供了一个特殊的 <code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p>
<p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p>
<blockquote>
<p>static ThreadLocal<code>&lt;User&gt;</code> threadLocalUser = new ThreadLocal&lt;&gt;();</p>
</blockquote>
<p>它的典型使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过设置一个 <code>User</code>实例关联到 <code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该 <code>User</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到普通的方法调用一定是同一个线程执行的，所以，<code>step1()</code>、<code>step2()</code>以及 <code>log()</code>方法内，<code>threadLocalUser.get()</code>获取的User对象是同一个实例。</p>
<p>实际上，可以把 <code>ThreadLocal</code>看成一个全局 <code>Map&lt;Thread, Object&gt;</code>：每个线程获取 <code>ThreadLocal</code>变量时，总是使用 <code>Thread</code>自身作为key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object threadLocalValue = threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure>
<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的 <code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意 <code>ThreadLocal</code>一定要在 <code>finally</code>中清除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果 <code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<p>为了保证能释放 <code>ThreadLocal</code>关联的实例，我们可以通过 <code>AutoCloseable</code>接口配合 <code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的 <code>ThreadLocal</code>可以封装为一个 <code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，我们借助 <code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>
<p>这样就在 <code>UserContext</code>中完全封装了 <code>ThreadLocal</code>，外部代码在 <code>try (resour) &#123;...&#125;</code>内部可以随时调用 <code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">木雁之间</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://winfredliu.github.io/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/">https://winfredliu.github.io/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://winfredliu.github.io" target="_blank">木雁之间的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/cover5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/19/blog%E6%90%AD%E5%BB%BA/"><img class="prev-cover" src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">blog搭建教程</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/25/butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E7%BE%8E%E5%8C%96/"><img class="next-cover" src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">butterfly主题的额外美化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/17/java%E5%B9%B6%E5%8F%91/" title="java并发"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-03-18</div><div class="title">java并发</div></div></a></div><div><a href="/2022/03/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="java虚拟机"><img class="cover" src="/img/cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-03-18</div><div class="title">java虚拟机</div></div></a></div><div><a href="/2022/02/21/java%E5%85%A5%E9%97%A8(%E4%BA%8C)/" title="java入门（二）"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2022-03-18</div><div class="title">java入门（二）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木雁之间</div><div class="author-info__description">博客</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/winfredliu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/winfredliu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3194769362@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">java基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">Java程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">Java程序基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">变量和数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#var%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">var关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">整数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E4%B8%8E%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">类型自动提升与强制转型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">浮点数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">布尔运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.6.</span> <span class="toc-text">字符和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">空值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">数组类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.2.</span> <span class="toc-text">if判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">switch多重选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">yield</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">do while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.6.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E5%92%8Ccontinue"><span class="toc-number">1.3.7.</span> <span class="toc-text">break和continue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">命令行参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">private方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">this变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">多构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">2.1.3.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">阻止继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.1.4.5.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88"><span class="toc-number">2.1.4.6.</span> <span class="toc-text">区分继承和组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.1.5.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-2"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E5%86%99Object%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">覆写Object方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8super"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">调用super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.1.6.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.7.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">default方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.8.</span> <span class="toc-text">静态字段和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">抽象的静态字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">2.1.9.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">包作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.10.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final-2"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.1.11.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Inner-Class"><span class="toc-number">2.1.11.1.</span> <span class="toc-text">Inner Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Anonymous-Class-%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">2.1.11.2.</span> <span class="toc-text">Anonymous Class(匿名类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Static-Nested-Class"><span class="toc-number">2.1.11.3.</span> <span class="toc-text">Static Nested Class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classpath%E5%92%8Cjar"><span class="toc-number">2.1.12.</span> <span class="toc-text">classpath和jar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#classpath"><span class="toc-number">2.1.12.1.</span> <span class="toc-text">classpath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jar%E5%8C%85"><span class="toc-number">2.1.12.2.</span> <span class="toc-text">jar包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.12.3.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.12.4.</span> <span class="toc-text">编写模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.12.5.</span> <span class="toc-text">运行模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8C%85JRE"><span class="toc-number">2.1.12.6.</span> <span class="toc-text">打包JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.1.12.7.</span> <span class="toc-text">访问权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Java核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">字符串和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">去除首尾空白字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">替换子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">拼接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.1.8.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BAchar"><span class="toc-number">2.2.1.9.</span> <span class="toc-text">转换为char[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.1.10.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="toc-number">2.2.1.11.</span> <span class="toc-text">延伸阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">2.2.2.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner"><span class="toc-number">2.2.3.</span> <span class="toc-text">StringJoiner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-join"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">String.join()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Auto-Boxing"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">Auto Boxing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%98%E7%B1%BB"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">不变类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">处理无符号整型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean"><span class="toc-number">2.2.5.</span> <span class="toc-text">JavaBean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaBean%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">JavaBean的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEJavaBean%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">枚举JavaBean属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">2.2.6.</span> <span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enum"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">enum的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">enum类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#name"><span class="toc-number">2.2.6.3.1.</span> <span class="toc-text">name()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ordinal"><span class="toc-number">2.2.6.3.2.</span> <span class="toc-text">ordinal()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB"><span class="toc-number">2.2.7.</span> <span class="toc-text">记录类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#record"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">record</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger"><span class="toc-number">2.2.8.</span> <span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-number">2.2.9.</span> <span class="toc-text">BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83BigDecimal"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">比较BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.2.10.</span> <span class="toc-text">常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-number">2.2.10.1.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random"><span class="toc-number">2.2.10.2.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SecureRandom"><span class="toc-number">2.2.10.3.</span> <span class="toc-text">SecureRandom</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text">Java的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">捕获异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8-2"><span class="toc-number">3.2.</span> <span class="toc-text">捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Acatch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">多catch语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">finally语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%A4%9A%E7%A7%8D%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">捕获多种异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.</span> <span class="toc-text">抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">3.3.1.</span> <span class="toc-text">异常的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%B1%8F%E8%94%BD"><span class="toc-number">3.3.3.</span> <span class="toc-text">异常屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NullPointerException"><span class="toc-number">3.5.</span> <span class="toc-text">NullPointerException</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86NullPointerException"><span class="toc-number">3.5.1.</span> <span class="toc-text">处理NullPointerException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8DNullPointerException"><span class="toc-number">3.5.2.</span> <span class="toc-text">定位NullPointerException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="toc-number">3.6.</span> <span class="toc-text">使用断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JDK-Logging"><span class="toc-number">3.7.</span> <span class="toc-text">使用JDK Logging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Commons-Logging"><span class="toc-number">3.8.</span> <span class="toc-text">使用Commons Logging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Log4j"><span class="toc-number">3.9.</span> <span class="toc-text">使用Log4j</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SLF4J%E5%92%8CLogback"><span class="toc-number">3.10.</span> <span class="toc-text">使用SLF4J和Logback</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.1.1.</span> <span class="toc-text">动态加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">4.2.</span> <span class="toc-text">访问字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">4.2.1.</span> <span class="toc-text">获取字段值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">4.2.2.</span> <span class="toc-text">设置字段值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">调用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">调用静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%9D%9Epublic%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">调用非public方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-3"><span class="toc-number">4.3.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">调用构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">4.5.</span> <span class="toc-text">获取继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84Class"><span class="toc-number">4.5.1.</span> <span class="toc-text">获取父类的Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96interface"><span class="toc-number">4.5.2.</span> <span class="toc-text">获取interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">继承关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%84%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">动态处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">使用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">注解的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.2.1.</span> <span class="toc-text">元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Target"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">@Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Retention"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">@Retention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Repeatable"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">@Repeatable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inherited"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">@Inherited</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89Annotation"><span class="toc-number">5.2.2.</span> <span class="toc-text">如何定义Annotation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">处理注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">使用注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">什么是泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-2"><span class="toc-number">6.1.1.</span> <span class="toc-text">向上转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.1.</span> <span class="toc-text">泛型接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">编写泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">多个泛型类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%A6%E6%8B%AD%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">擦拭法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%81%B0%E5%BD%93%E7%9A%84%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">不恰当的覆写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">6.4.2.</span> <span class="toc-text">泛型继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extends%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">extends通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.5.1.</span> <span class="toc-text">extends通配符的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8extends%E9%99%90%E5%AE%9AT%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.2.</span> <span class="toc-text">使用extends限定T类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">Java集合简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">7.1.1.</span> <span class="toc-text">Collection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List"><span class="toc-number">7.2.</span> <span class="toc-text">使用List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.2.1.</span> <span class="toc-text">List的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAList"><span class="toc-number">7.2.2.</span> <span class="toc-text">创建List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86List"><span class="toc-number">7.2.3.</span> <span class="toc-text">遍历List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%92%8CArray%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.4.</span> <span class="toc-text">List和Array转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99equals%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">编写equals方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99equals"><span class="toc-number">7.3.1.</span> <span class="toc-text">编写equals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Map"><span class="toc-number">7.4.</span> <span class="toc-text">使用Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86Map"><span class="toc-number">7.4.1.</span> <span class="toc-text">遍历Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99equals%E5%92%8ChashCode"><span class="toc-number">7.5.</span> <span class="toc-text">编写equals和hashCode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB-2"><span class="toc-number">7.5.1.</span> <span class="toc-text">延伸阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-number">7.6.</span> <span class="toc-text">使用EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TreeMap"><span class="toc-number">7.7.</span> <span class="toc-text">使用TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Properties"><span class="toc-number">7.8.</span> <span class="toc-text">使用Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.8.1.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.8.2.</span> <span class="toc-text">写入配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">7.8.3.</span> <span class="toc-text">编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Set"><span class="toc-number">7.9.</span> <span class="toc-text">使用Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Queue"><span class="toc-number">7.10.</span> <span class="toc-text">使用Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PriorityQueue"><span class="toc-number">7.11.</span> <span class="toc-text">使用PriorityQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Deque"><span class="toc-number">7.12.</span> <span class="toc-text">使用Deque</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Stack"><span class="toc-number">7.13.</span> <span class="toc-text">使用Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.13.1.</span> <span class="toc-text">Stack的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.13.2.</span> <span class="toc-text">计算中缀表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Iterator"><span class="toc-number">7.14.</span> <span class="toc-text">使用Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Collections"><span class="toc-number">7.15.</span> <span class="toc-text">使用Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%9B%86%E5%90%88"><span class="toc-number">7.15.1.</span> <span class="toc-text">创建空集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88"><span class="toc-number">7.15.2.</span> <span class="toc-text">创建单元素集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-2"><span class="toc-number">7.15.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%97%E7%89%8C"><span class="toc-number">7.15.4.</span> <span class="toc-text">洗牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">7.15.5.</span> <span class="toc-text">不可变集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-number">7.15.6.</span> <span class="toc-text">线程安全集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">正则表达式简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">8.2.</span> <span class="toc-text">匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6"><span class="toc-number">8.2.1.</span> <span class="toc-text">匹配任意字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%95%B0%E5%AD%97"><span class="toc-number">8.2.2.</span> <span class="toc-text">匹配数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6"><span class="toc-number">8.2.3.</span> <span class="toc-text">匹配常用字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%A9%BA%E6%A0%BC%E5%AD%97%E7%AC%A6"><span class="toc-number">8.2.4.</span> <span class="toc-text">匹配空格字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E9%9D%9E%E6%95%B0%E5%AD%97"><span class="toc-number">8.2.5.</span> <span class="toc-text">匹配非数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">8.2.6.</span> <span class="toc-text">重复匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">8.3.</span> <span class="toc-text">复杂匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%BC%80%E5%A4%B4%E5%92%8C%E7%BB%93%E5%B0%BE"><span class="toc-number">8.3.1.</span> <span class="toc-text">匹配开头和结尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4"><span class="toc-number">8.3.2.</span> <span class="toc-text">匹配指定范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%96%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">8.3.3.</span> <span class="toc-text">或规则匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7"><span class="toc-number">8.3.4.</span> <span class="toc-text">使用括号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="toc-number">8.4.</span> <span class="toc-text">分组匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern"><span class="toc-number">8.4.1.</span> <span class="toc-text">Pattern</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D"><span class="toc-number">8.5.</span> <span class="toc-text">非贪婪匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">8.6.</span> <span class="toc-text">搜索和替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2-2"><span class="toc-number">8.6.1.</span> <span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.6.2.</span> <span class="toc-text">搜索字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.6.3.</span> <span class="toc-text">替换字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">8.6.4.</span> <span class="toc-text">反向引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.</span> <span class="toc-text">File对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">9.1.1.</span> <span class="toc-text">文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.2.</span> <span class="toc-text">创建和删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">9.1.3.</span> <span class="toc-text">遍历文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path"><span class="toc-number">9.1.4.</span> <span class="toc-text">Path</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream"><span class="toc-number">9.2.</span> <span class="toc-text">InputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2"><span class="toc-number">9.2.1.</span> <span class="toc-text">缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">9.2.2.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">9.2.3.</span> <span class="toc-text">InputStream实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputStream"><span class="toc-number">9.3.</span> <span class="toc-text">OutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">9.3.1.</span> <span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-2"><span class="toc-number">9.3.2.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStream%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">9.3.3.</span> <span class="toc-text">OutputStream实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">Filter模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99FilterInputStream"><span class="toc-number">9.4.1.</span> <span class="toc-text">编写FilterInputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9CZip"><span class="toc-number">9.5.</span> <span class="toc-text">操作Zip</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96zip%E5%8C%85"><span class="toc-number">9.5.1.</span> <span class="toc-text">读取zip包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5zip%E5%8C%85"><span class="toc-number">9.5.2.</span> <span class="toc-text">写入zip包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96classpath%E8%B5%84%E6%BA%90"><span class="toc-number">9.6.</span> <span class="toc-text">读取classpath资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">9.7.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-2"><span class="toc-number">9.7.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-2"><span class="toc-number">9.7.2.</span> <span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">9.7.3.</span> <span class="toc-text">安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader"><span class="toc-number">9.8.</span> <span class="toc-text">Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader"><span class="toc-number">9.8.1.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CharArrayReader"><span class="toc-number">9.8.2.</span> <span class="toc-text">CharArrayReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringReader"><span class="toc-number">9.8.3.</span> <span class="toc-text">StringReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-number">9.8.4.</span> <span class="toc-text">InputStreamReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writer"><span class="toc-number">9.9.</span> <span class="toc-text">Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter"><span class="toc-number">9.9.1.</span> <span class="toc-text">FileWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CharArrayWriter"><span class="toc-number">9.9.2.</span> <span class="toc-text">CharArrayWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringWriter"><span class="toc-number">9.9.3.</span> <span class="toc-text">StringWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter"><span class="toc-number">9.9.4.</span> <span class="toc-text">OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PrintStream%E5%92%8CPrintWriter"><span class="toc-number">9.10.</span> <span class="toc-text">PrintStream和PrintWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintWriter"><span class="toc-number">9.10.1.</span> <span class="toc-text">PrintWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Files"><span class="toc-number">9.11.</span> <span class="toc-text">使用Files</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">日期与时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4"><span class="toc-number">10.1.1.</span> <span class="toc-text">本地时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">10.1.2.</span> <span class="toc-text">时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8F%E4%BB%A4%E6%97%B6"><span class="toc-number">10.1.3.</span> <span class="toc-text">夏令时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">10.1.4.</span> <span class="toc-text">本地化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date%E5%92%8CCalendar"><span class="toc-number">10.2.</span> <span class="toc-text">Date和Calendar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93API"><span class="toc-number">10.2.1.</span> <span class="toc-text">标准库API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TimeZone"><span class="toc-number">10.2.1.3.</span> <span class="toc-text">TimeZone</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalDateTime"><span class="toc-number">10.3.</span> <span class="toc-text">LocalDateTime</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDateTime-2"><span class="toc-number">10.3.1.</span> <span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTimeFormatter"><span class="toc-number">10.3.2.</span> <span class="toc-text">DateTimeFormatter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duration%E5%92%8CPeriod"><span class="toc-number">10.3.3.</span> <span class="toc-text">Duration和Period</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZonedDateTime"><span class="toc-number">10.4.</span> <span class="toc-text">ZonedDateTime</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.4.1.</span> <span class="toc-text">时区转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DateTimeFormatter-2"><span class="toc-number">10.5.</span> <span class="toc-text">DateTimeFormatter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instant"><span class="toc-number">10.6.</span> <span class="toc-text">Instant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.7.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7API%E8%BD%AC%E6%96%B0API"><span class="toc-number">10.7.1.</span> <span class="toc-text">旧API转新API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0API%E8%BD%AC%E6%97%A7API"><span class="toc-number">10.7.2.</span> <span class="toc-text">新API转旧API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">10.7.3.</span> <span class="toc-text">在数据库中存储日期和时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99JUnit%E6%B5%8B%E8%AF%95"><span class="toc-number">11.1.</span> <span class="toc-text">编写JUnit测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JUnit"><span class="toc-number">11.1.1.</span> <span class="toc-text">JUnit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">11.1.2.</span> <span class="toc-text">单元测试的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Fixture"><span class="toc-number">11.2.</span> <span class="toc-text">使用Fixture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95"><span class="toc-number">11.3.</span> <span class="toc-text">异常测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">11.4.</span> <span class="toc-text">条件测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">11.5.</span> <span class="toc-text">参数化测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">加密与安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">编码算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E7%BC%96%E7%A0%81"><span class="toc-number">12.1.1.</span> <span class="toc-text">URL编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base64%E7%BC%96%E7%A0%81"><span class="toc-number">12.1.2.</span> <span class="toc-text">Base64编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">12.2.1.</span> <span class="toc-text">哈希碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA-1"><span class="toc-number">12.2.2.</span> <span class="toc-text">SHA-1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BouncyCastle"><span class="toc-number">12.3.</span> <span class="toc-text">BouncyCastle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hmac%E7%AE%97%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">Hmac算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.5.</span> <span class="toc-text">对称加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AES%E5%8A%A0%E5%AF%86"><span class="toc-number">12.5.1.</span> <span class="toc-text">使用AES加密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.6.</span> <span class="toc-text">口令加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">12.7.</span> <span class="toc-text">密钥交换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">12.8.</span> <span class="toc-text">非对称加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="toc-number">12.9.</span> <span class="toc-text">签名算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DSA%E7%AD%BE%E5%90%8D"><span class="toc-number">12.9.1.</span> <span class="toc-text">DSA签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECDSA%E7%AD%BE%E5%90%8D"><span class="toc-number">12.9.2.</span> <span class="toc-text">ECDSA签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">12.10.</span> <span class="toc-text">数字证书</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">13.1.</span> <span class="toc-text">多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">13.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-vs-%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.1.2.</span> <span class="toc-text">进程 vs 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.1.3.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.2.</span> <span class="toc-text">创建新线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">13.2.1.</span> <span class="toc-text">线程的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">13.3.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.4.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.5.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">13.6.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81synchronized%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">13.6.1.</span> <span class="toc-text">不需要synchronized的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">13.7.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">13.8.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-2"><span class="toc-number">13.8.1.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify"><span class="toc-number">13.9.</span> <span class="toc-text">使用wait和notify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ReentrantLock"><span class="toc-number">13.10.</span> <span class="toc-text">使用ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Condition"><span class="toc-number">13.11.</span> <span class="toc-text">使用Condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ReadWriteLock"><span class="toc-number">13.12.</span> <span class="toc-text">使用ReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8StampedLock"><span class="toc-number">13.13.</span> <span class="toc-text">使用StampedLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Concurrent%E9%9B%86%E5%90%88"><span class="toc-number">13.14.</span> <span class="toc-text">使用Concurrent集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Atomic"><span class="toc-number">13.15.</span> <span class="toc-text">使用Atomic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.16.</span> <span class="toc-text">使用线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPool"><span class="toc-number">13.16.1.</span> <span class="toc-text">ScheduledThreadPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Future"><span class="toc-number">13.17.</span> <span class="toc-text">使用Future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CompletableFuture"><span class="toc-number">13.18.</span> <span class="toc-text">使用CompletableFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ForkJoin"><span class="toc-number">13.19.</span> <span class="toc-text">使用ForkJoin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadLocal"><span class="toc-number">13.20.</span> <span class="toc-text">使用ThreadLocal</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/java%E5%B9%B6%E5%8F%91/" title="java并发"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java并发"/></a><div class="content"><a class="title" href="/2022/03/17/java%E5%B9%B6%E5%8F%91/" title="java并发">java并发</a><time datetime="2022-03-18T02:40:25.448Z" title="发表于 2022-03-17 18:40:25">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="java虚拟机"><img src="/img/cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java虚拟机"/></a><div class="content"><a class="title" href="/2022/03/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="java虚拟机">java虚拟机</a><time datetime="2022-03-17T14:33:27.881Z" title="发表于 2022-03-17 06:33:27">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/SQL%E7%BB%83%E4%B9%A0/" title="SQL练习"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL练习"/></a><div class="content"><a class="title" href="/2022/03/10/SQL%E7%BB%83%E4%B9%A0/" title="SQL练习">SQL练习</a><time datetime="2022-03-11T03:37:36.804Z" title="发表于 2022-03-10 19:37:36">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/MySQL%E5%9F%BA%E7%A1%80/" title="MySQL基础"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL基础"/></a><div class="content"><a class="title" href="/2022/03/10/MySQL%E5%9F%BA%E7%A1%80/" title="MySQL基础">MySQL基础</a><time datetime="2022-03-11T03:18:20.468Z" title="发表于 2022-03-10 19:18:20">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="数据库系统原理"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库系统原理"/></a><div class="content"><a class="title" href="/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="数据库系统原理">数据库系统原理</a><time datetime="2022-03-09T09:28:45.207Z" title="发表于 2022-03-09 01:28:45">2022-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 木雁之间</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'test1-2gktnr4k00ee729f',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'test1-2gktnr4k00ee729f',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://winfredliu.github.io/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/'
    this.page.identifier = '2022/01/24/java入门(一)/'
    this.page.title = 'java入门（一）'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://winfredliu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Twikoo' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'test1-2gktnr4k00ee729f',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/104fe729.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: '104fe729',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/no-pjax/"]):not([href="/movie/"]):not([href="/artitalk/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'UA-217798011-2', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>