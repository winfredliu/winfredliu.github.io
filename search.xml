<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/03/17/java%E5%B9%B6%E5%8F%91/"/>
      <url>/2022/03/17/java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1>Java 并发</h1><!-- GFM-TOC --><ul><li><a href="#java-%E5%B9%B6%E5%8F%91">Java 并发</a><ul><li><a href="#%E4%B8%80%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B">一、使用线程</a><ul><li><a href="#%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3">实现 Runnable 接口</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3">实现 Callable 接口</a></li><li><a href="#%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB">继承 Thread 类</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BF-thread">实现接口 VS 继承 Thread</a></li></ul></li><li><a href="#%E4%BA%8C%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6">二、基础线程机制</a><ul><li><a href="#executor">Executor</a></li><li><a href="#daemon">Daemon</a></li><li><a href="#sleep">sleep()</a></li><li><a href="#yield">yield()</a></li></ul></li><li><a href="#%E4%B8%89%E4%B8%AD%E6%96%AD">三、中断</a><ul><li><a href="#interruptedexception">InterruptedException</a></li><li><a href="#interrupted">interrupted()</a></li><li><a href="#executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C">Executor 的中断操作</a></li></ul></li><li><a href="#%E5%9B%9B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">四、互斥同步</a><ul><li><a href="#synchronized">synchronized</a></li><li><a href="#reentrantlock">ReentrantLock</a></li><li><a href="#%E6%AF%94%E8%BE%83">比较</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9">使用选择</a></li></ul></li><li><a href="#%E4%BA%94%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C">五、线程之间的协作</a><ul><li><a href="#join">join()</a></li><li><a href="#wait-notify-notifyall">wait() notify() notifyAll()</a></li><li><a href="#await-signal-signalall">await() signal() signalAll()</a></li></ul></li><li><a href="#%E5%85%AD%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81">六、线程状态</a><ul><li><a href="#%E6%96%B0%E5%BB%BAnew">新建（NEW）</a></li><li><a href="#%E5%8F%AF%E8%BF%90%E8%A1%8Crunable">可运行（RUNABLE）</a></li><li><a href="#%E9%98%BB%E5%A1%9Eblocked">阻塞（BLOCKED）</a></li><li><a href="#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85waiting">无限期等待（WAITING）</a></li><li><a href="#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85timed_waiting">限期等待（TIMED_WAITING）</a></li><li><a href="#%E6%AD%BB%E4%BA%A1terminated">死亡（TERMINATED）</a></li></ul></li><li><a href="#%E4%B8%83juc---aqs">七、J.U.C - AQS</a><ul><li><a href="#countdownlatch">CountDownLatch</a></li><li><a href="#cyclicbarrier">CyclicBarrier</a></li><li><a href="#semaphore">Semaphore</a></li></ul></li><li><a href="#%E5%85%ABjuc---%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6">八、J.U.C - 其它组件</a><ul><li><a href="#futuretask">FutureTask</a></li><li><a href="#blockingqueue">BlockingQueue</a></li><li><a href="#forkjoin">ForkJoin</a></li></ul></li><li><a href="#%E4%B9%9D%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B">九、线程不安全示例</a></li><li><a href="#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">十、Java 内存模型</a><ul><li><a href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98">主内存与工作内存</a></li><li><a href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C">内存间交互操作</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">内存模型三大特性</a><ul><li><a href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7">1. 原子性</a></li><li><a href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7">2. 可见性</a></li><li><a href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7">3. 有序性</a></li></ul></li><li><a href="#%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99">先行发生原则</a><ul><li><a href="#1-%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%88%99">1. 单一线程原则</a></li><li><a href="#2-%E7%AE%A1%E7%A8%8B%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99">2. 管程锁定规则</a></li><li><a href="#3-volatile-%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99">3. volatile 变量规则</a></li><li><a href="#4-%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99">4. 线程启动规则</a></li><li><a href="#5-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99">5. 线程加入规则</a></li><li><a href="#6-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99">6. 线程中断规则</a></li><li><a href="#7-%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99">7. 对象终结规则</a></li><li><a href="#8-%E4%BC%A0%E9%80%92%E6%80%A7">8. 传递性</a></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">十一、线程安全</a><ul><li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98">不可变</a></li><li><a href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">互斥同步</a></li><li><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5">非阻塞同步</a><ul><li><a href="#1-cas">1. CAS</a></li><li><a href="#2-atomicinteger">2. AtomicInteger</a></li><li><a href="#3-aba">3. ABA</a></li></ul></li><li><a href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88">无同步方案</a><ul><li><a href="#1-%E6%A0%88%E5%B0%81%E9%97%AD">1. 栈封闭</a></li><li><a href="#2-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8thread-local-storage">2. 线程本地存储（Thread Local Storage）</a></li><li><a href="#3-%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81reentrant-code">3. 可重入代码（Reentrant Code）</a></li></ul></li></ul></li><li><a href="#%E5%8D%81%E4%BA%8C%E9%94%81%E4%BC%98%E5%8C%96">十二、锁优化</a><ul><li><a href="#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></li><li><a href="#%E9%94%81%E6%B6%88%E9%99%A4">锁消除</a></li><li><a href="#%E9%94%81%E7%B2%97%E5%8C%96">锁粗化</a></li><li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li><li><a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li></ul></li><li><a href="#%E5%8D%81%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E8%89%AF%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5">十三、多线程开发良好的实践</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="一、使用线程">一、使用线程</h2><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h3 id="实现-Runnable-接口">实现 Runnable 接口</h3><p>需要实现接口中的 run() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Callable-接口">实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承-Thread-类">继承 Thread 类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口-VS-继承-Thread">实现接口 VS 继承 Thread</h3><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2 id="二、基础线程机制">二、基础线程机制</h2><h3 id="Executor">Executor</h3><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Daemon">Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep">sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield">yield()</h3><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、中断">三、中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h3 id="InterruptedException">InterruptedException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><h3 id="interrupted">interrupted()</h3><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure><h3 id="Executor-的中断操作">Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="四、互斥同步">四、互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h3 id="synchronized">synchronized</h3><p><strong>1. 同步一个代码块</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p><strong>2. 同步一个方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p><strong>4. 同步一个静态方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类。</p><h3 id="ReentrantLock">ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="比较-3">比较</h3><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h3 id="使用选择">使用选择</h3><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h2 id="五、线程之间的协作">五、线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h3 id="join">join()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="wait-notify-notifyAll">wait() notify() notifyAll()</h3><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h3 id="await-signal-signalAll">await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h2 id="六、线程状态">六、线程状态</h2><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h3 id="新建（NEW）">新建（NEW）</h3><p>创建后尚未启动。</p><h3 id="可运行（RUNABLE）">可运行（RUNABLE）</h3><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><h3 id="阻塞（BLOCKED）">阻塞（BLOCKED）</h3><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p><h3 id="无限期等待（WAITING）">无限期等待（WAITING）</h3><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h3 id="限期等待（TIMED-WAITING）">限期等待（TIMED_WAITING）</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h3 id="死亡（TERMINATED）">死亡（TERMINATED）</h3><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html">Java SE 9 Enum Thread.State</a></p><h2 id="七、J-U-C-AQS">七、J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h3 id="CountDownLatch">CountDownLatch</h3><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier">CyclicBarrier</h3><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h3 id="Semaphore">Semaphore</h3><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2 1 2 2 2 2 2 1 2 2</span><br></pre></td></tr></table></figure><h2 id="八、J-U-C-其它组件">八、J.U.C - 其它组件</h2><h3 id="FutureTask">FutureTask</h3><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&lt;V&gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">other task is running...</span><br><span class="line">4950</span><br></pre></td></tr></table></figure><h3 id="BlockingQueue">BlockingQueue</h3><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong>  ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong>  ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;produce..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;consume..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure><h3 id="ForkJoin">ForkJoin</h3><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br><h2 id="九、线程不安全示例">九、线程不安全示例</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">997</span><br></pre></td></tr></table></figure><h2 id="十、Java-内存模型">十、Java 内存模型</h2><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存">主内存与工作内存</h3><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="600px"> </div><br><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="600px"> </div><br><h3 id="内存间交互操作">内存间交互操作</h3><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="450px"> </div><br><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h3 id="内存模型三大特性">内存模型三大特性</h3><h4 id="1-原子性">1. 原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="300px"> </div><br><p>AtomicInteger 能保证多个线程修改的原子性。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="300px"> </div><br><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="keyword">new</span> AtomicExample(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h4 id="2-可见性">2. 可见性</h4><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h4 id="3-有序性">3. 有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h3 id="先行发生原则">先行发生原则</h3><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h4 id="1-单一线程原则">1. 单一线程原则</h4><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" width="180px"> </div><br><h4 id="2-管程锁定规则">2. 管程锁定规则</h4><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" width="350px"> </div><br><h4 id="3-volatile-变量规则">3. volatile 变量规则</h4><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" width="400px"> </div><br><h4 id="4-线程启动规则">4. 线程启动规则</h4><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" width="380px"> </div><br><h4 id="5-线程加入规则">5. 线程加入规则</h4><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" width="400px"> </div><br><h4 id="6-线程中断规则">6. 线程中断规则</h4><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h4 id="7-对象终结规则">7. 对象终结规则</h4><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h4 id="8-传递性">8. 传递性</h4><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h2 id="十一、线程安全">十一、线程安全</h2><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h3 id="不可变">不可变</h3><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:9)</span><br></pre></td></tr></table></figure><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥同步">互斥同步</h3><p>synchronized 和 ReentrantLock。</p><h3 id="非阻塞同步">非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><h4 id="1-CAS">1. CAS</h4><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h4 id="2-AtomicInteger">2. AtomicInteger</h4><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ABA">3. ABA</h4><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h3 id="无同步方案">无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h4 id="1-栈封闭">1. 栈封闭</h4><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="2-线程本地存储（Thread-Local-Storage）">2. 线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>为了理解 ThreadLocal，先看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它所对应的底层结构图为：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" width="500px"> </div><br><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get() 方法类似。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h4 id="3-可重入代码（Reentrant-Code）">3. 可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h2 id="十二、锁优化">十二、锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁">自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h3 id="锁消除">锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h3 id="锁粗化">锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁">轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" width="500"/> </div><br><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" width="500"/> </div><br><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png" width="400"/> </div><br><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="偏向锁">偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" width="600"/> </div><br><h2 id="十三、多线程开发良好的实践">十三、多线程开发良好的实践</h2><ul><li><p>给线程起个有意义的名字，这样可以方便找 Bug。</p></li><li><p>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</p></li><li><p>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p></li><li><p>使用 BlockingQueue 实现生产者消费者问题。</p></li><li><p>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</p></li><li><p>使用本地变量和不可变类来保证线程安全。</p></li><li><p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</p></li></ul><h2 id="参考资料-5">参考资料</h2><ul><li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html">Threads and Locks</a></li><li><a href="http://ifeve.com/thread-signaling/#missed_signal">线程通信</a></li><li><a href="http://www.importnew.com/12773.html">Java 线程面试题 Top 50</a></li><li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html">BlockingQueue</a></li><li><a href="https://stackoverflow.com/questions/11265289/thread-state-java">thread state java</a></li><li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN">CSC 456 Spring 2012/ch7 MN</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html">Java - Understanding Happens-before relationship</a></li><li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization">6장 Thread Synchronization</a></li><li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015">How is Java’s ThreadLocal implemented under the hood?</a></li><li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1">Concurrent</a></li><li><a href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example">JAVA FORK JOIN EXAMPLE</a></li><li><a href="http://ifeve.com/talk-concurrency-forkjoin/">聊聊并发（八）——Fork/Join 框架介绍</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2022/03/17/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>Java 虚拟机</h1><!-- GFM-TOC --><ul><li><a href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA">Java 虚拟机</a><ul><li><a href="#%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">一、运行时数据区域</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li><li><a href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java 虚拟机栈</a></li><li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li><li><a href="#%E5%A0%86">堆</a></li><li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a></li><li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li></ul></li><li><a href="#%E4%BA%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86">二、垃圾收集</a><ul><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%9B%9E%E6%94%B6">判断一个对象是否可被回收</a></li><li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">垃圾收集算法</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">垃圾收集器</a></li></ul></li><li><a href="#%E4%B8%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">三、内存分配与回收策略</a><ul><li><a href="#minor-gc-%E5%92%8C-full-gc">Minor GC 和 Full GC</a></li><li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">内存分配策略</a></li><li><a href="#full-gc-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">Full GC 的触发条件</a></li></ul></li><li><a href="#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">四、类加载机制</a><ul><li><a href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">类的生命周期</a></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a></li><li><a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA">类初始化时机</a></li><li><a href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类与类加载器</a></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB">类加载器分类</a></li><li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0">自定义类加载器实现</a></li></ul></li><li><a href="#%E4%BA%94%E5%85%B6%E5%AE%83">五、其它</a><ul><li><a href="#hotspot">HotSpot</a></li><li><a href="#jni">jni</a></li><li><a href="#%E6%B0%B8%E4%B9%85%E4%BB%A3">永久代</a></li></ul></li><li><a href="#%E5%85%ADJava%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3">六、Java编译程序和运行过程详解</a><ul><li><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E7%BC%96%E8%AF%91">第一步(编译)</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E8%BF%90%E8%A1%8C">第二步(运行)</a></li></ul></li><li><a href="#%E4%B8%83JVM%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3">七、JVM中的常量池详解</a><ul><li><a href="#1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0">1.字符串常量池(String Constant Pool)</a></li><li><a href="#2.class%E5%B8%B8%E9%87%8F%E6%B1%A0">2.class常量池(Class Constant Pool)</a></li><li><a href="#3.%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">3.运行时常量池(Runtime Constant Pool)</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><p>本文大部分内容参考   <strong>周志明《深入理解 Java 虚拟机》</strong>  ，想要深入学习的话请看原书。</p><h2 id="一、运行时数据区域">一、运行时数据区域</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="400px"> </div><br><h3 id="程序计数器">程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h3 id="Java-虚拟机栈">Java 虚拟机栈</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br><p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h3 id="本地方法栈">本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" width="300px"> </div><br><h3 id="堆">堆</h3><p>所有对象都在这里分配内存，是垃圾收集的主要区域（“GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure><h3 id="方法区">方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><h3 id="运行时常量池">运行时常量池</h3><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h3 id="直接内存">直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h2 id="二、垃圾收集">二、垃圾收集</h2><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h3 id="判断一个对象是否可被回收">判断一个对象是否可被回收</h3><h4 id="1-引用计数算法">1. 引用计数算法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p><h4 id="2-可达性分析算法">2. 可达性分析算法</h4><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br><h4 id="3-方法区的回收">3. 方法区的回收</h4><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h4 id="4-finalize">4. finalize()</h4><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h3 id="引用类型">引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h4 id="1-强引用">1. 强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h4 id="2-软引用">2. 软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h4 id="3-弱引用">3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="4-虚引用">4. 虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="垃圾收集算法">垃圾收集算法</h3><h4 id="1-标记-清除">1. 标记 - 清除</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p><p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p><p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h4 id="2-标记-整理">2. 标记 - 整理</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优点:</p><ul><li>不会产生内存碎片</li></ul><p>不足:</p><ul><li>需要移动大量对象，处理效率比较低。</li></ul><h4 id="3-复制">3. 复制</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h4 id="4-分代收集">4. 分代收集</h4><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h3 id="垃圾收集器">垃圾收集器</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width=""/> </div><br><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h4 id="1-Serial-收集器">1. Serial 收集器</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" width=""/> </div><br><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><h4 id="2-ParNew-收集器">2. ParNew 收集器</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" width=""/> </div><br><p>它是 Serial 收集器的多线程版本。</p><p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><h4 id="3-Parallel-Scavenge-收集器">3. Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h4 id="4-Serial-Old-收集器">4. Serial Old 收集器</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" width=""/> </div><br><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h4 id="5-Parallel-Old-收集器">5. Parallel Old 收集器</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" width=""/> </div><br><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h4 id="6-CMS-收集器">6. CMS 收集器</h4><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""/> </div><br><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="7-G1-收集器">7. G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" width="600"/> </div><br><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" width="600"/> </div><br><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""/> </div><br><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h2 id="三、内存分配与回收策略">三、内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC">Minor GC 和 Full GC</h3><ul><li><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p></li><li><p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p></li></ul><h3 id="内存分配策略">内存分配策略</h3><h4 id="1-对象优先在-Eden-分配">1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h4 id="2-大对象直接进入老年代">2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h4 id="3-长期存活的对象进入老年代">3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="4-动态对象年龄判定">4. 动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="5-空间分配担保">5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h3 id="Full-GC-的触发条件">Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h4 id="1-调用-System-gc">1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="2-老年代空间不足">2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="3-空间分配担保失败">3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p><h4 id="4-JDK-1-7-及以前的永久代空间不足">4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="5-Concurrent-Mode-Failure">5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="四、类加载机制">四、类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p><h3 id="类的生命周期">类的生命周期</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br><p>包括以下 7 个阶段：</p><ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><h3 id="类加载过程">类加载过程</h3><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p><h4 id="1-加载">1. 加载</h4><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，最典型的应用是 Applet。</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li></ul><h4 id="2-验证">2. 验证</h4><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h4 id="3-准备">3. 准备</h4><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h4 id="4-解析">4. 解析</h4><p>将常量池的符号引用替换为直接引用的过程。</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><h4 id="5-初始化">5. 初始化</h4><div data="modify -->"></div>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit\>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。<p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p><h3 id="类初始化时机">类初始化时机</h3><h4 id="1-主动引用">1. 主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p></li><li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p></li></ul><h4 id="2-被动引用">2. 被动引用</h4><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h3 id="类与类加载器">类与类加载器</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p><h3 id="类加载器分类">类加载器分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p></li><li><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p></li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p></li><li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul><h3 id="双亲委派模型">双亲委派模型</h3><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p><p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br><h4 id="1-工作过程">1. 工作过程</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><h4 id="2-好处">2. 好处</h4><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p><h4 id="3-实现">3. 实现</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类加载器实现">自定义类加载器实现</h3><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、其它">五、其它</h2><h3 id="HotSpot">HotSpot</h3><h4 id="1-HotSpot历史">1. HotSpot历史</h4><p>SUN的JDK版本从1.3.1开始运用HotSpot虚拟机， 2006年底开源，主要使用C++实现，JNI接口部分用C实现。</p><p>HotSpot是较新的Java虚拟机，用来代替JIT(Just in Time)，可以大大提高Java运行的性能。</p><p>Java原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。而HotSpot将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。</p><p>HotSpot JVM 参数可以分为规则参数(standard options)和非规则参数(non-standard options)。</p><p>规则参数相对稳定，在JDK未来的版本里不会有太大的改动。</p><p>非规则参数则有因升级JDK而改动的可能。</p><p>规则和非规则参数这里不做介绍了，网上资料很多。</p><h4 id="2-HotSpot基础知识">2. HotSpot基础知识</h4><p>HotSpot包括一个解释器和两个编译器（client 和 server，二选一的），解释与编译混合执行模式，默认启动解释执行。</p><p>编译器：java源代码被编译器编译成class文件（字节码），java字节码在运行时可以被动态编译（JIT）成本地代码(前提是解释与编译混合执行模式且虚拟机不是刚启动时)。</p><p>解释器： 解释器用来解释class文件（字节码），java是解释语言（书上这么说的）。</p><p>server启动慢，占用内存多，执行效率高，适用于服务器端应用；</p><p>client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。</p><p>由-XX:+RewriteFrequentPairs参数控制  client模式默认关闭，server模式默认开启</p><p>在jre安装目录下的lib/i386/jvm.cfg 文件下。</p><p>java -version</p><p>Java HotSpot™ Client VM (build 14.3-b01, mixed mode, sharing)</p><p>mixed mode 解释与编译 混合的执行模式 默认使用这种模式</p><p>java -Xint -version</p><p>Java HotSpot™ Client VM (build 14.3-b01, interpreted mode, sharing)</p><p>interpreted  纯解释模式 禁用JIT编译</p><p>java -Xcomp -version</p><p>Java HotSpot™ Client VM (build 14.3-b01, compiled mode, sharing)</p><p>compiled  纯编译模式（如果方法无法编译，则回退到解释模式执行无法编译的方法）</p><h4 id="3-动态编译">3. 动态编译</h4><p>动态编译(compile during run-time)，英文称Dynamic compilation；Just In Time也是这个意思。</p><p>HotSpot对bytecode的编译不是在程序运行前编译的，而是在程序运行过程中编译的。</p><p>HotSpot里运行着一个监视器（Profile Monitor），用来监视程序的运行状况。</p><p>java字节码（class文件）是以解释的方式被加载到虚拟机中(默认启动时解释执行)。 程序运行过程中，那一部分运用频率大，那些对程序的性能影响重要。对程序运行效率影响大的代码，称为热点（hotspot），HotSpot会把这些热点动态地编译成机器码（native code），同时对机器码进行优化，从而提高运行效率。对那些较少运行的代码，HotSpot就不会把他们编译。</p><p>HotSpot对字节码有三层处理：不编译(字节码加载到虚拟机中时的状态。也就是当虚拟机执行的时候再编译)，编译(把字节码编译成本地代码。虚拟机执行的时候已经编译好了，不要再编译了)，编译并优化（不但把字节码编译成本地代码，而且还进行了优化）。</p><p>至于那些程序那些不编译，那些编译，那些优化，则是由监视器（Profile Monitor）决定。</p><h4 id="4-为什么不静态编译那？">4. 为什么不静态编译那？</h4><p>为什么字节码在装载到虚拟机之前就编译成本地代码那?</p><p>动态编译器也在许多方面比静态编译器优越。静态编译器通常很难准确预知程序运行过程中究竟什么部分最需要优化。</p><p>函数调用都是很浪费系统时间的，因为有许多进栈出栈操作。因此有一种优化办法，就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用出，变成顺序执行。</p><p>面向对象的语言支持多态，静态编译无效确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法。</p><h3 id="jni">jni</h3><p>JNI是Java Native Interface的缩写，通过使用 Java本地接口书写程序，可以确保代码在不同的平台上方便移植。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。</p><h3 id="永久代">永久代</h3><p>【永久代】是HotSpot的一种具体实现，实际上指的就是方法区，或者说用永久代来实现方法区。对于其他虚拟机来说是不存在永久代的概念的。</p><p>HotSpot中对于JVM规范中方法区的实现，指内存的永久保存区域，主要存放Class和Meta（元数据）的信息，Class在被加载的时候被放入永久区域。</p><p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存</p><h3 id="Java-String-intern">Java String.intern()</h3><p><strong>String.intern()原理</strong><br>String.intern()是一个Native方法，底层调用C++的 StringTable::intern 方法，源码注释：当调用 intern 方法时，如果常量池中已经该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回字符串的引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;String&quot;</span>).append(<span class="string">&quot;Test&quot;</span>).toString();</span><br><span class="line">        System.out.println(s1.intern() == s1);</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(s2.intern() == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK6 和 JDK7 中结果不一样：</p><p>1、JDK6的执行结果：false false<br>对于这个结果很好理解。在JDK6中，常量池在永久代分配内存，永久代和Java堆的内存是物理隔离的，执行intern方法时，如果常量池不存在该字符串，虚拟机会在常量池中复制该字符串，并返回引用，所以需要谨慎使用intern方法，避免常量池中字符串过多，导致性能变慢，甚至发生PermGen内存溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-ee42e5059da433e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/561/format/webp" alt=""></p><p>2、JDK7的执行结果：true false<br>对于这个结果就有点懵了。在JDK7中，常量池已经在Java堆上分配内存，执行intern方法时，如果常量池已经存在该字符串，则直接返回字符串引用，否则复制该字符串对象的引用到常量池中并返回，所以在JDK7中，可以重新考虑使用intern方法，减少String对象所占的内存空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/2184951-0d48da18cea9606a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt=""></p><p>对于变量s1，常量池中没有 “StringTest” 字符串，s1.intern() 和 s1都是指向Java对象上的String对象。<br>对于变量s2，常量池中一开始就已经存在 “java” 字符串，所以 s2.intern() 返回常量池中 “java” 字符串的引用。</p><p><strong>String.intern()性能</strong><br>常量池底层使用StringTable数据结构保存字符串引用，实现和HashMap类似，根据字符串的hashcode定位到对应的数组，遍历链表查找字符串，当字符串比较多时，会降低查询效率。</p><p>在JDK6中，由于常量池在PermGen中，受到内存大小的限制，不建议使用该方法。<br>在JDK7、8中，可以通过-XX:StringTableSize参数StringTable大小，下面通过几个测试用例看看intern方法的性能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cost(<span class="number">1000000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">cost</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一百万次intern()方法，不同StringTableSize的耗时情况如下：</p><p>1、-XX:StringTableSize=1009， 平均耗时23000ms；<br>2、-XX:StringTableSize=10009， 平均耗时2200ms；<br>3、-XX:StringTableSize=100009， 平均耗时200ms；<br>4、默认情况下，平均耗时400ms；</p><p>在默认StringTableSize下，执行不同次intern()方法的耗时情况如下：</p><p>1、一万次，平均耗时5ms；<br>2、十万次，平均耗时25ms；<br>3、五十万次，平均耗时130ms；<br>4、一百万次，平均耗时400ms；<br>5、五百万次，平均耗时5000ms；<br>6、一千万次，平均耗时15000ms；</p><p>从这些测试数据可以看出，尽管在Java 7以上对intern()做了细致的优化，但其耗时仍然很显著，如果无限制的使用intern(）方法，将导致系统性能下降，不过可以将有限值的字符串放入常量池，提高内存利用率，所以intern()方法是一把双刃剑。</p><h2 id="六、Java编译程序和运行过程详解">六、Java编译程序和运行过程详解</h2><p>java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：</p><p>编译原理简单过程：词法分析 --&gt; 语法分析 --&gt; 语义分析和中间代码生成 --&gt; 优化 --&gt; 目标代码生成</p><p>Java程序从源文件创建到程序运行要经过两大步骤：</p><p>1、Java文件会由编译器编译成class文件（字节码文件），会经过编译原理简单过程的前三步；</p><p>2、字节码由java虚拟机解释运行，解释执行即为目标代码生成并执行。因为java程序既要编译的同时也要经过JVM的解释运行，所以说Java被称为半解释语言！</p><p>（ “semi-interpreted” language）</p><p>​<img src="https://img-blog.csdn.net/20170509103254317" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        animal.printName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal = &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一步（编译）">第一步（编译）</h3><p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，若这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用；若java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报&quot;Can’t found sysbol&quot;的异常错误。</p><p>编译后的字节码文件格式主要分为两部分：常量池和方法字节码。</p><p>常量池记录的是代码出现过的字面量（文本字符串、八种基本类型的值、被声明为final的常量等）以及符号引用（类和方法的全限定名、字段的名称和描述符、方法的名称和描述符）；[<a href="https://www.cnblogs.com/superyc/p/9975254.html">https://www.cnblogs.com/superyc/p/9975254.html</a>]</p><p>方法字节码中放的是各个方法的字节码（依赖操作数栈和局部变量表，由JVM解释执行）</p><h3 id="第二步（运行）">第二步（运行）</h3><p>java类运行的过程大概分为两个步骤：</p><p>（1）类的加载</p><p>加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化（其中验证、准备、解析统称为类的连接）；（参考《深入了解Java虚拟机》）</p><p>加载：通过一个类的全限定名来获取定义此类的二进制字节流（Class文件）；将这个二进制字节流所代表的静态存储结果转化为方法区的运行时数据结构；在内存中生成一个java.lang.Class对象，注意：存放在方法区！</p><p>验证：验证目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全；使用纯粹的Java代码无法做到诸如访问数组边界意外的数据、将一个对象转型为它未实现的类型、跳转到不存在的代码之类的事情，如果这样做了，编译器将拒绝编译！</p><p>准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。首先这时候进行内存分配的仅包括类变量（static修饰的变量），而不是实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><blockquote><p>public static int value = 123;</p></blockquote><p>变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，在类初始化的时候才会将value的值赋为123.</p><p>解析：解析阶段是虚拟机将class常量池内的符号引用替换为直接引用的过程。</p><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可；</p><p>直接引用：是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。有了直接引用，那引用的目标必定已经在内存中存在。</p><p>初始化：类初始化阶段是类加载过程的最后一步；在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。</p><p>（2）类的执行</p><p>需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载，加载完毕就会生成一个java.lang.Class对象，并且存放在方法区。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次，初始化类构造器<code>&lt;clinit&gt;()</code>方法也只执行一次，所以static{} 块，类变量赋值语句也就只执行一次，只生成一个java.lang.Class对象！</p><p>由Java虚拟机的执行引擎来解释执行Java字节码，过程：输入字节码文件，字节码解析，输出执行完的结果！（不再赘述，请自行参考《深入了解Java虚拟机》）</p><p>重点理解：根据上面的程序和概念解释，详解该程序运行的详细步骤</p><p>（1）在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的 类信息加载到运行时数据区的方法区（JDK 8 方法区存在 堆区） 中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）；</p><p>（2）JVM 找到main方法的主函数入口， 持有一个指向当前类（Test）常量池的指针，而常量池中的第一项发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“Tom”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针（直接引用）替换了常量池中第一项的符号引用。</p><p>（3）加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量&quot;Tom&quot;会自动的放在方法区的运行时常量池中，对象会自动的放入堆区）</p><p>（4）当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息方法表，获得pringName()函数的字节码地址，然后Java虚拟机执行引擎依赖局部变量表，操作数栈进行字节码解释执行，返回结果！</p><p><img src="https://img-blog.csdn.net/20170509114514509" alt=""></p><p>​大家可能对Java执行引擎，结合局部变量表和操作数栈执行字节码的理解不是很透彻，下来我简单介绍一下字节码的执行过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">     <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">     <span class="keyword">return</span> (a + b) * c;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令展示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　public int calc();</span><br><span class="line"></span><br><span class="line">　　Code:</span><br><span class="line"></span><br><span class="line">　　Stack=2, Locals=4, Args_size=1 //操作栈深度为2和4个Slot局部变量表</span><br><span class="line"></span><br><span class="line">　　0：bipush 100   //将100压入操作数栈</span><br><span class="line"></span><br><span class="line">　　2：istore_1 　　//将栈顶100数值存放到局变量Slot，index=1中</span><br><span class="line"></span><br><span class="line">　　3：sipush 200  //将200压入操作数栈</span><br><span class="line"></span><br><span class="line">　　6：istore_2      //将栈顶200数值存放到局部变量Slot，index=2中</span><br><span class="line"></span><br><span class="line">　　7：sipush 300  //将300压入操作数栈</span><br><span class="line"></span><br><span class="line">　　10：istore_3     //将栈顶200数值存放到局部变量Slot，index=3中</span><br><span class="line"></span><br><span class="line">　　11：iload_1       //将index=1的局部变量表数值压入操作数栈（100）</span><br><span class="line"></span><br><span class="line">　　12：iload_2      //将index=2的局部变量表数值压入操作数栈（200）</span><br><span class="line"></span><br><span class="line">　　13：iadd          //取栈顶两个数值相加，结果压入操作数栈（300）</span><br><span class="line"></span><br><span class="line">　　14：iload_3      //将index=3的局部变量表数值压入操作数栈（300）</span><br><span class="line"></span><br><span class="line">　　15：imul          //取栈顶两个数值相乘，结果压入操作数栈（90000）</span><br><span class="line"></span><br><span class="line">　　16：ireturn      //取栈顶数值返回调用者结果</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1455557/201811/1455557-20181120111022102-110009185.png" alt=""></p><p>局部变量表 index = 0存储当前对象本身 this</p><h2 id="七、JVM中的常量池详解">七、JVM中的常量池详解</h2><h3 id="1-字符串常量池-String-Constant-Pool">1.字符串常量池(String Constant Pool)</h3><h4 id="1-1-字符串常量池在Java内存区域的哪个位置？">1.1:字符串常量池在Java内存区域的哪个位置？</h4><p>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</p><p>在JDK7.0版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。</p><p>JDK8以后也还是放在了Heap空间中，并没有移到元空间。</p><h4 id="1-2-字符串常量池是什么？">1.2:字符串常量池是什么？</h4><p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</p><p>在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</p><p>在JDK7.0中，StringTable的长度可以通过参数指定：</p><blockquote><p>-XX:StringTableSize=66666</p></blockquote><h4 id="1-3-字符串常量池里放的是什么？">1.3:字符串常量池里放的是什么？</h4><p>在JDK6.0及之前版本中，String Pool里放的都是字符串常量；</p><p>在JDK7.0中，由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。</p><p>需要说明的是：字符串常量池中的字符串只存在一份！<br>如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;hello,world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>即执行完第一行代码后，常量池中已存在 “hello,world!”，那么 s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。</p><h3 id="2-class常量池-Class-Constant-Pool">2.class常量池(Class Constant Pool)</h3><h4 id="2-1-class常量池简介">2.1:class常量池简介</h4><p>我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)；</p><p>每个class文件都有一个class常量池。</p><h4 id="2-2-什么是字面量和符号引用">2.2:什么是字面量和符号引用</h4><ul><li>字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;</li><li>符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。</li><li>直接引用 ：直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。</li></ul><p>直接引用可以是：</p><p>1：直接指向目标的指针。（个人理解为：指向对象，类变量和类方法的指针）</p><p>2：相对偏移量。      （指向实例的变量，方法的指针）</p><p>3：一个间接定位到对象的句柄。</p><h3 id="3-运行时常量池-Runtime-Constant-Pool">3.运行时常量池(Runtime Constant Pool)</h3><ul><li><p>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用</p></li><li><p>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//true</span></span><br><span class="line">        String s3=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 这里显示false，可能先在字符串常量池中添加s1，然后动态的添加s3，会显示false</span></span><br><span class="line">        s3.intern();    </span><br><span class="line">        System.out.println(s1==s3); <span class="comment">//false</span></span><br><span class="line">          </span><br><span class="line">        String s4=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;cd&quot;</span>);</span><br><span class="line">        <span class="comment">//s4.intern();</span></span><br><span class="line">        String s5=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        System.out.println(s4==s5);<span class="comment">//true,去掉intern之后是false;</span></span><br><span class="line">          </span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><h2 id="参考资料-7">参考资料</h2><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine</a></li><li><a href="https://www.slideshare.net/benewu/jvm-memory">Jvm memory</a><br><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Getting Started with the G1 Garbage Collector</a></li><li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li><li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/">Memory Architecture Of JVM(Runtime Data Areas)</a></li><li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/">JVM Run-Time Data Areas</a></li><li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271">Android on x86: Java Native Interface and the Android Native Development Kit</a></li><li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/">深入理解 JVM(2)——GC 算法与内存分配策略</a></li><li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解 JVM(3)——7 种垃圾收集器</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6">深入探讨 Java 类加载器</a></li><li><a href="http://www.baeldung.com/java-weakhashmap">Guide to WeakHashMap in Java</a></li><li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml">Tomcat example source code file (ConcurrentCache.java)</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/10/SQL%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/03/10/SQL%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>SQL 练习</h1><!-- GFM-TOC --><ul><li><a href="#sql-%E7%BB%83%E4%B9%A0">SQL 练习</a><ul><li><a href="#595-big-countries">595. Big Countries</a><ul><li><a href="#description">Description</a></li><li><a href="#solution">Solution</a></li><li><a href="#sql-schema">SQL Schema</a></li></ul></li><li><a href="#627-swap-salary">627. Swap Salary</a><ul><li><a href="#description-1">Description</a></li><li><a href="#solution-1">Solution</a></li><li><a href="#sql-schema-1">SQL Schema</a></li></ul></li><li><a href="#620-not-boring-movies">620. Not Boring Movies</a><ul><li><a href="#description-2">Description</a></li><li><a href="#solution-2">Solution</a></li><li><a href="#sql-schema-2">SQL Schema</a></li></ul></li><li><a href="#596-classes-more-than-5-students">596. Classes More Than 5 Students</a><ul><li><a href="#description-3">Description</a></li><li><a href="#solution-3">Solution</a></li><li><a href="#sql-schema-3">SQL Schema</a></li></ul></li><li><a href="#182-duplicate-emails">182. Duplicate Emails</a><ul><li><a href="#description-4">Description</a></li><li><a href="#solution-4">Solution</a></li><li><a href="#sql-schema-4">SQL Schema</a></li></ul></li><li><a href="#196-delete-duplicate-emails">196. Delete Duplicate Emails</a><ul><li><a href="#description-5">Description</a></li><li><a href="#solution-5">Solution</a></li><li><a href="#sql-schema-5">SQL Schema</a></li></ul></li><li><a href="#175-combine-two-tables">175. Combine Two Tables</a><ul><li><a href="#description-6">Description</a></li><li><a href="#solution-6">Solution</a></li><li><a href="#sql-schema-6">SQL Schema</a></li></ul></li><li><a href="#181-employees-earning-more-than-their-managers">181. Employees Earning More Than Their Managers</a><ul><li><a href="#description-7">Description</a></li><li><a href="#solution-7">Solution</a></li><li><a href="#sql-schema-7">SQL Schema</a></li></ul></li><li><a href="#183-customers-who-never-order">183. Customers Who Never Order</a><ul><li><a href="#description-8">Description</a></li><li><a href="#solution-8">Solution</a></li><li><a href="#sql-schema-8">SQL Schema</a></li></ul></li><li><a href="#184-department-highest-salary">184. Department Highest Salary</a><ul><li><a href="#description-9">Description</a></li><li><a href="#solution-9">Solution</a></li><li><a href="#sql-schema-9">SQL Schema</a></li></ul></li><li><a href="#176-second-highest-salary">176. Second Highest Salary</a><ul><li><a href="#description-10">Description</a></li><li><a href="#solution-10">Solution</a></li><li><a href="#sql-schema-10">SQL Schema</a></li></ul></li><li><a href="#177-nth-highest-salary">177. Nth Highest Salary</a><ul><li><a href="#description-11">Description</a></li><li><a href="#solution-11">Solution</a></li><li><a href="#sql-schema-11">SQL Schema</a></li></ul></li><li><a href="#178-rank-scores">178. Rank Scores</a><ul><li><a href="#description-12">Description</a></li><li><a href="#solution-12">Solution</a></li><li><a href="#sql-schema-12">SQL Schema</a></li></ul></li><li><a href="#180-consecutive-numbers">180. Consecutive Numbers</a><ul><li><a href="#description-13">Description</a></li><li><a href="#solution-13">Solution</a></li><li><a href="#sql-schema-13">SQL Schema</a></li></ul></li><li><a href="#626-exchange-seats">626. Exchange Seats</a><ul><li><a href="#description-14">Description</a></li><li><a href="#solution-14">Solution</a></li><li><a href="#sql-schema-14">SQL Schema</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><h2 id="595-Big-Countries">595. Big Countries</h2><p><a href="https://leetcode.com/problems/big-countries/description/">https://leetcode.com/problems/big-countries/description/</a></p><h3 id="Description">Description</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,</span><br><span class="line">    population,</span><br><span class="line">    area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    area <span class="operator">&gt;</span> <span class="number">3000000</span></span><br><span class="line">    <span class="keyword">OR</span> population <span class="operator">&gt;</span> <span class="number">25000000</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema">SQL Schema</h3><p>SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> World;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> World ( NAME <span class="type">VARCHAR</span> ( <span class="number">255</span> ), continent <span class="type">VARCHAR</span> ( <span class="number">255</span> ), area <span class="type">INT</span>, population <span class="type">INT</span>, gdp <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World ( NAME, continent, area, population, gdp )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">&#x27;Afghanistan&#x27;</span>, <span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;652230&#x27;</span>, <span class="string">&#x27;25500100&#x27;</span>, <span class="string">&#x27;203430000&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;Albania&#x27;</span>, <span class="string">&#x27;Europe&#x27;</span>, <span class="string">&#x27;28748&#x27;</span>, <span class="string">&#x27;2831741&#x27;</span>, <span class="string">&#x27;129600000&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;Algeria&#x27;</span>, <span class="string">&#x27;Africa&#x27;</span>, <span class="string">&#x27;2381741&#x27;</span>, <span class="string">&#x27;37100000&#x27;</span>, <span class="string">&#x27;1886810000&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Europe&#x27;</span>, <span class="string">&#x27;468&#x27;</span>, <span class="string">&#x27;78115&#x27;</span>, <span class="string">&#x27;37120000&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;Angola&#x27;</span>, <span class="string">&#x27;Africa&#x27;</span>, <span class="string">&#x27;1246700&#x27;</span>, <span class="string">&#x27;20609294&#x27;</span>, <span class="string">&#x27;1009900000&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="627-Swap-Salary">627. Swap Salary</h2><p><a href="https://leetcode.com/problems/swap-salary/description/">https://leetcode.com/problems/swap-salary/description/</a></p><h3 id="Description-2">Description</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure><p>只用一个 SQL 查询，将 sex 字段反转。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure><h3 id="Solution-2">Solution</h3><p>两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</p><p>sex  字段只有两个取值：‘f’ 和 ‘m’，并且有以下规律：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;f&#x27; ^ (&#x27;m&#x27; ^ &#x27;f&#x27;) = &#x27;m&#x27; ^ (&#x27;f&#x27; ^ &#x27;f&#x27;) = &#x27;m&#x27;</span><br><span class="line">&#x27;m&#x27; ^ (&#x27;m&#x27; ^ &#x27;f&#x27;) = &#x27;f&#x27; ^ (&#x27;m&#x27; ^ &#x27;m&#x27;) = &#x27;f&#x27;</span><br></pre></td></tr></table></figure><p>因此将 sex 字段和 ‘m’ ^ ‘f’ 进行异或操作，最后就能反转 sex 字段。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE salary</span><br><span class="line"><span class="keyword">SET</span> sex <span class="operator">=</span> <span class="type">CHAR</span> ( ASCII(sex) <span class="operator">^</span> ASCII( <span class="string">&#x27;m&#x27;</span> ) <span class="operator">^</span> ASCII( <span class="string">&#x27;f&#x27;</span> ) );</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-2">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> salary;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salary ( id <span class="type">INT</span>, NAME <span class="type">VARCHAR</span> ( <span class="number">100</span> ), sex <span class="type">CHAR</span> ( <span class="number">1</span> ), salary <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salary ( id, NAME, sex, salary )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;2500&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;1500&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;5500&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;500&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="620-Not-Boring-Movies">620. Not Boring Movies</h2><p><a href="https://leetcode.com/problems/not-boring-movies/description/">https://leetcode.com/problems/not-boring-movies/description/</a></p><h3 id="Description-3">Description</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><h3 id="Solution-3">Solution</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    cinema</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="operator">%</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> description <span class="operator">!=</span> <span class="string">&#x27;boring&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    rating <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-3">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> cinema;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cinema ( id <span class="type">INT</span>, movie <span class="type">VARCHAR</span> ( <span class="number">255</span> ), description <span class="type">VARCHAR</span> ( <span class="number">255</span> ), rating <span class="type">FLOAT</span> ( <span class="number">2</span>, <span class="number">1</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cinema ( id, movie, description, rating )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;War&#x27;</span>, <span class="string">&#x27;great 3D&#x27;</span>, <span class="number">8.9</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;Science&#x27;</span>, <span class="string">&#x27;fiction&#x27;</span>, <span class="number">8.5</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">&#x27;irish&#x27;</span>, <span class="string">&#x27;boring&#x27;</span>, <span class="number">6.2</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">&#x27;Ice song&#x27;</span>, <span class="string">&#x27;Fantacy&#x27;</span>, <span class="number">8.6</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="string">&#x27;House card&#x27;</span>, <span class="string">&#x27;Interesting&#x27;</span>, <span class="number">9.1</span> );</span><br></pre></td></tr></table></figure><h2 id="596-Classes-More-Than-5-Students">596. Classes More Than 5 Students</h2><p><a href="https://leetcode.com/problems/classes-more-than-5-students/description/">https://leetcode.com/problems/classes-more-than-5-students/description/</a></p><h3 id="Description-4">Description</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure><p>查找有五名及以上 student 的 class。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><h3 id="Solution-4">Solution</h3><p>对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING  针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    class</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    class</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> student ) <span class="operator">&gt;=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-4">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> courses;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> courses ( student <span class="type">VARCHAR</span> ( <span class="number">255</span> ), class <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> courses ( student, class )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;English&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;Biology&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;Computer&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;Math&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="182-Duplicate-Emails">182. Duplicate Emails</h2><p><a href="https://leetcode.com/problems/duplicate-emails/description/">https://leetcode.com/problems/duplicate-emails/description/</a></p><h3 id="Description-5">Description</h3><p>邮件地址表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>查找重复的邮件地址：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><h3 id="Solution-5">Solution</h3><p>对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email  重复。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="built_in">COUNT</span>( <span class="operator">*</span> ) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-5">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Person;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Person ( Id <span class="type">INT</span>, Email <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Person ( Id, Email )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;a@b.com&#x27;</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;c@d.com&#x27;</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">&#x27;a@b.com&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="196-Delete-Duplicate-Emails">196. Delete Duplicate Emails</h2><p><a href="https://leetcode.com/problems/delete-duplicate-emails/description/">https://leetcode.com/problems/delete-duplicate-emails/description/</a></p><h3 id="Description-6">Description</h3><p>邮件地址表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>删除重复的邮件地址：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure><h3 id="Solution-6">Solution</h3><p>只保留相同 Email 中 Id 最小的那一个，然后删除其它的。</p><p>连接查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email <span class="operator">=</span> p2.Email</span><br><span class="line">    <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure><p>子查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> id </span><br><span class="line">        <span class="keyword">FROM</span> ( </span><br><span class="line">            <span class="keyword">SELECT</span> <span class="built_in">min</span>( id ) <span class="keyword">AS</span> id </span><br><span class="line">            <span class="keyword">FROM</span> Person</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> email</span><br><span class="line">        ) <span class="keyword">AS</span> m</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can’t specify target table ‘Person’ for update in FROM clause。以下演示了这种错误解法。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="keyword">NOT</span> <span class="keyword">IN</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">min</span>( id ) <span class="keyword">AS</span> id </span><br><span class="line">        <span class="keyword">FROM</span> Person </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> email </span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause">pMySQL Error 1093 - Can't specify target table for update in FROM clause</a></p><h3 id="SQL-Schema-6">SQL Schema</h3><p>与 182 相同。</p><h2 id="175-Combine-Two-Tables">175. Combine Two Tables</h2><p><a href="https://leetcode.com/problems/combine-two-tables/description/">https://leetcode.com/problems/combine-two-tables/description/</a></p><h3 id="Description-7">Description</h3><p>Person 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId is the primary key column for this table.</span><br></pre></td></tr></table></figure><p>Address 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId is the primary key column for this table.</span><br></pre></td></tr></table></figure><p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p><h3 id="Solution-7">Solution</h3><p>涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    FirstName,</span><br><span class="line">    LastName,</span><br><span class="line">    City,</span><br><span class="line">    State</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person P</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address A</span><br><span class="line">    <span class="keyword">ON</span> P.PersonId <span class="operator">=</span> A.PersonId;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-7">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Person;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Person ( PersonId <span class="type">INT</span>, FirstName <span class="type">VARCHAR</span> ( <span class="number">255</span> ), LastName <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Address;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Address ( AddressId <span class="type">INT</span>, PersonId <span class="type">INT</span>, City <span class="type">VARCHAR</span> ( <span class="number">255</span> ), State <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Person ( PersonId, LastName, FirstName )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Address ( AddressId, PersonId, City, State )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;New York City&#x27;</span>, <span class="string">&#x27;New York&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="181-Employees-Earning-More-Than-Their-Managers">181. Employees Earning More Than Their Managers</h2><p><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a></p><h3 id="Description-8">Description</h3><p>Employee 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure><p>查找薪资大于其经理薪资的员工信息。</p><h3 id="Solution-8">Solution</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    E1.NAME <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee E1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Employee E2</span><br><span class="line">    <span class="keyword">ON</span> E1.ManagerId <span class="operator">=</span> E2.Id</span><br><span class="line">    <span class="keyword">AND</span> E1.Salary <span class="operator">&gt;</span> E2.Salary;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-8">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( Id <span class="type">INT</span>, NAME <span class="type">VARCHAR</span> ( <span class="number">255</span> ), Salary <span class="type">INT</span>, ManagerId <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( Id, NAME, Salary, ManagerId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="number">70000</span>, <span class="number">3</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;Henry&#x27;</span>, <span class="number">80000</span>, <span class="number">4</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="number">60000</span>, <span class="keyword">NULL</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">&#x27;Max&#x27;</span>, <span class="number">90000</span>, <span class="keyword">NULL</span> );</span><br></pre></td></tr></table></figure><h2 id="183-Customers-Who-Never-Order">183. Customers Who Never Order</h2><p><a href="https://leetcode.com/problems/customers-who-never-order/description/">https://leetcode.com/problems/customers-who-never-order/description/</a></p><h3 id="Description-9">Description</h3><p>Customers 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>Orders 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure><p>查找没有订单的顾客信息：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h3 id="Solution-9">Solution</h3><p>左外链接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    C.Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Customers C</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders O</span><br><span class="line">    <span class="keyword">ON</span> C.Id <span class="operator">=</span> O.CustomerId</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    O.CustomerId <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>子查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Customers</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Id <span class="keyword">NOT</span> <span class="keyword">IN</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span> CustomerId </span><br><span class="line">        <span class="keyword">FROM</span> Orders </span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-9">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Customers;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers ( Id <span class="type">INT</span>, NAME <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Orders;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders ( Id <span class="type">INT</span>, CustomerId <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers ( Id, NAME )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;Joe&#x27;</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;Henry&#x27;</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">&#x27;Sam&#x27;</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">&#x27;Max&#x27;</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders ( Id, CustomerId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">3</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">1</span> );</span><br></pre></td></tr></table></figure><h2 id="184-Department-Highest-Salary">184. Department Highest Salary</h2><p><a href="https://leetcode.com/problems/department-highest-salary/description/">https://leetcode.com/problems/department-highest-salary/description/</a></p><h3 id="Description-10">Description</h3><p>Employee 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure><p>Department 表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>查找一个 Department 中收入最高者的信息：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure><h3 id="Solution-10">Solution</h3><p>创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。</p><p>之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    D.NAME Department,</span><br><span class="line">    E.NAME Employee,</span><br><span class="line">    E.Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee E,</span><br><span class="line">    Department D,</span><br><span class="line">    ( <span class="keyword">SELECT</span> DepartmentId, <span class="built_in">MAX</span>( Salary ) Salary </span><br><span class="line">     <span class="keyword">FROM</span> Employee </span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId ) M</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    E.DepartmentId <span class="operator">=</span> D.Id</span><br><span class="line">    <span class="keyword">AND</span> E.DepartmentId <span class="operator">=</span> M.DepartmentId</span><br><span class="line">    <span class="keyword">AND</span> E.Salary <span class="operator">=</span> M.Salary;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Department.name <span class="keyword">AS</span> <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">    Employee.name <span class="keyword">AS</span> <span class="string">&#x27;Employee&#x27;</span>,</span><br><span class="line">    Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line">      <span class="keyword">JOIN</span></span><br><span class="line">    Department <span class="keyword">ON</span> Employee.DepartmentId <span class="operator">=</span> Department.Id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (Employee.DepartmentId , Salary) <span class="keyword">IN</span></span><br><span class="line">    (   <span class="keyword">SELECT</span></span><br><span class="line">            DepartmentId, <span class="built_in">MAX</span>(Salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            Employee</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-10">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( Id <span class="type">INT</span>, NAME <span class="type">VARCHAR</span> ( <span class="number">255</span> ), Salary <span class="type">INT</span>, DepartmentId <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> Department;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department ( Id <span class="type">INT</span>, NAME <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( Id, NAME, Salary, DepartmentId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="number">70000</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;Henry&#x27;</span>, <span class="number">80000</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="number">60000</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">&#x27;Max&#x27;</span>, <span class="number">90000</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Department ( Id, NAME )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">&#x27;IT&#x27;</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">&#x27;Sales&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="176-Second-Highest-Salary">176. Second Highest Salary</h2><p><a href="https://leetcode.com/problems/second-highest-salary/description/">https://leetcode.com/problems/second-highest-salary/description/</a></p><h3 id="Description-11">Description</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>查找工资第二高的员工。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>没有找到返回 null 而不是不返回数据。</p><h3 id="Solution-11">Solution</h3><p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ( <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary </span><br><span class="line">     <span class="keyword">FROM</span> Employee </span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> </span><br><span class="line">     LIMIT <span class="number">1</span>, <span class="number">1</span> ) SecondHighestSalary;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-11">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( Id <span class="type">INT</span>, Salary <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( Id, Salary )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">100</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">200</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">300</span> );</span><br></pre></td></tr></table></figure><h2 id="177-Nth-Highest-Salary">177. Nth Highest Salary</h2><h3 id="Description-12">Description</h3><p>查找工资第 N 高的员工。</p><h3 id="Solution-12">Solution</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary ( N <span class="type">INT</span> ) <span class="keyword">RETURNS</span> <span class="type">INT</span> <span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> N <span class="operator">=</span> N <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">RETURN</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary </span><br><span class="line">        <span class="keyword">FROM</span> Employee </span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> </span><br><span class="line">        LIMIT N, <span class="number">1</span> </span><br><span class="line">    ) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-12">SQL Schema</h3><p>同 176。</p><h2 id="178-Rank-Scores">178. Rank Scores</h2><p><a href="https://leetcode.com/problems/rank-scores/description/">https://leetcode.com/problems/rank-scores/description/</a></p><h3 id="Description-13">Description</h3><p>得分表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>将得分排序，并统计排名。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><h3 id="Solution-13">Solution</h3><p>要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量。</p><table><thead><tr><th style="text-align:center">Id</th><th style="text-align:center">score</th><th style="text-align:center">大于等于该 score 的 score 数量</th><th style="text-align:center">排名</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.3</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><p>使用连接操作找到某个 score 对应的大于等于其值的记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Scores S1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Scores S2</span><br><span class="line">    <span class="keyword">ON</span> S1.score <span class="operator">&lt;=</span> S2.score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    S1.score <span class="keyword">DESC</span>, S1.Id;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center"><a href="http://S1.Id">S1.Id</a></th><th style="text-align:center">S1.score</th><th style="text-align:center"><a href="http://S2.Id">S2.Id</a></th><th style="text-align:center">S2.score</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">4.3</td><td style="text-align:center">3</td><td style="text-align:center">4.3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td><td style="text-align:center">2</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td><td style="text-align:center">3</td><td style="text-align:center">4.3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">1</td><td style="text-align:center">4.1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">2</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">3</td><td style="text-align:center">4.3</td></tr></tbody></table><p>可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 ‘Rank’</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    S1.score <span class="string">&#x27;Score&#x27;</span>,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="string">&#x27;Rank&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Scores S1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Scores S2</span><br><span class="line">    <span class="keyword">ON</span> S1.score <span class="operator">&lt;=</span> S2.score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    S1.id, S1.score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    S1.score <span class="keyword">DESC</span>, S1.Id;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">score</th><th style="text-align:center">Rank</th></tr></thead><tbody><tr><td style="text-align:center">4.3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4.2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4.1</td><td style="text-align:center">3</td></tr></tbody></table><p>上面的解法看似没问题，但是对于以下数据，它却得到了错误的结果：</p><table><thead><tr><th style="text-align:center">Id</th><th style="text-align:center">score</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.2</td></tr></tbody></table><table><thead><tr><th style="text-align:center">score</th><th style="text-align:center">Rank</th></tr></thead><tbody><tr><td style="text-align:center">4.2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4.2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4.1</td><td style="text-align:center">3</td></tr></tbody></table><p>而我们希望的结果为：</p><table><thead><tr><th style="text-align:center">score</th><th style="text-align:center">Rank</th></tr></thead><tbody><tr><td style="text-align:center">4.2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4.2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4.1</td><td style="text-align:center">2</td></tr></tbody></table><p>连接情况如下：</p><table><thead><tr><th style="text-align:center"><a href="http://S1.Id">S1.Id</a></th><th style="text-align:center">S1.score</th><th style="text-align:center"><a href="http://S2.Id">S2.Id</a></th><th style="text-align:center">S2.score</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td><td style="text-align:center">3</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4.2</td><td style="text-align:center">2</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.2</td><td style="text-align:center">3</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.2</td><td style="text-align:center">2</td><td style="text-align:center">4.1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">3</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">2</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4.1</td><td style="text-align:center">1</td><td style="text-align:center">4.1</td></tr></tbody></table><p>我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    S1.score <span class="string">&#x27;Score&#x27;</span>,</span><br><span class="line">    <span class="built_in">COUNT</span>( <span class="keyword">DISTINCT</span> S2.score ) <span class="string">&#x27;Rank&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Scores S1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Scores S2</span><br><span class="line">    <span class="keyword">ON</span> S1.score <span class="operator">&lt;=</span> S2.score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    S1.id, S1.score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    S1.score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-13">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> Scores;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Scores ( Id <span class="type">INT</span>, Score <span class="type">DECIMAL</span> ( <span class="number">3</span>, <span class="number">2</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scores ( Id, Score )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">4.1</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">4.1</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">4.2</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="number">4.2</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="number">4.3</span> ),</span><br><span class="line">    ( <span class="number">6</span>, <span class="number">4.3</span> );</span><br></pre></td></tr></table></figure><h2 id="180-Consecutive-Numbers">180. Consecutive Numbers</h2><p><a href="https://leetcode.com/problems/consecutive-numbers/description/">https://leetcode.com/problems/consecutive-numbers/description/</a></p><h3 id="Description-14">Description</h3><p>数字表：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure><p>查找连续出现三次的数字。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ConsecutiveNums |</span><br><span class="line">+-----------------+</span><br><span class="line">| 1               |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><h3 id="Solution-14">Solution</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">DISTINCT</span> L1.num ConsecutiveNums</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Logs L1,</span><br><span class="line">    Logs L2,</span><br><span class="line">    Logs L3</span><br><span class="line"><span class="keyword">WHERE</span> L1.id <span class="operator">=</span> l2.id <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> L2.id <span class="operator">=</span> L3.id <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> L1.num <span class="operator">=</span> L2.num</span><br><span class="line">    <span class="keyword">AND</span> l2.num <span class="operator">=</span> l3.num;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-14">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> LOGS;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LOGS ( Id <span class="type">INT</span>, Num <span class="type">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> LOGS ( Id, Num )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">6</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">7</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure><h2 id="626-Exchange-Seats">626. Exchange Seats</h2><p><a href="https://leetcode.com/problems/exchange-seats/description/">https://leetcode.com/problems/exchange-seats/description/</a></p><h3 id="Description-15">Description</h3><p>seat 表存储着座位对应的学生。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><h3 id="Solution-15">Solution</h3><p>使用多个 union。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 处理偶数 id，让 id 减 <span class="number">1</span></span><br><span class="line">## 例如 <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,... 变成 <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,...</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s1.id <span class="operator">-</span> <span class="number">1</span> <span class="keyword">AS</span> id,</span><br><span class="line">    s1.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s1.id MOD <span class="number">2</span> <span class="operator">=</span> <span class="number">0</span> <span class="keyword">UNION</span></span><br><span class="line">## 处理奇数 id，让 id 加 <span class="number">1</span>。但是如果最大的 id 为奇数，则不做处理</span><br><span class="line">## 例如 <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,... 变成 <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,...</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s2.id <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> id,</span><br><span class="line">    s2.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s2.id MOD <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> s2.id <span class="operator">!=</span> ( <span class="keyword">SELECT</span> <span class="built_in">max</span>( s3.id ) <span class="keyword">FROM</span> seat s3 ) <span class="keyword">UNION</span></span><br><span class="line">## 如果最大的 id 为奇数，单独取出这个数</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s4.id <span class="keyword">AS</span> id,</span><br><span class="line">    s4.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s4</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s4.id MOD <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> s4.id <span class="operator">=</span> ( <span class="keyword">SELECT</span> <span class="built_in">max</span>( s5.id ) <span class="keyword">FROM</span> seat s5 )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    id;</span><br></pre></td></tr></table></figure><h3 id="SQL-Schema-15">SQL Schema</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">IF</span><br><span class="line">    <span class="keyword">EXISTS</span> seat;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seat ( id <span class="type">INT</span>, student <span class="type">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seat ( id, student )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Abbot&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Doris&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Emerson&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Green&#x27;</span> ),</span><br><span class="line">    ( <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;Jeames&#x27;</span> );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/10/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/10/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>MySQL</h1><!-- GFM-TOC --><ul><li><a href="#mysql">MySQL</a><ul><li><a href="#%E4%B8%80%E7%B4%A2%E5%BC%95">一、索引</a><ul><li><a href="#b-tree-%E5%8E%9F%E7%90%86">B+ Tree 原理</a><ul><li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li><li><a href="#2-%E6%93%8D%E4%BD%9C">2. 操作</a></li><li><a href="#3-%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83">3. 与红黑树的比较</a></li></ul></li><li><a href="#mysql-%E7%B4%A2%E5%BC%95">MySQL 索引</a><ul><li><a href="#1-btree-%E7%B4%A2%E5%BC%95">1. B+Tree 索引</a></li><li><a href="#2-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95">2. 哈希索引</a></li><li><a href="#3-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">3. 全文索引</a></li><li><a href="#4-%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95">4. 空间数据索引</a></li></ul></li><li><a href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">索引优化</a><ul><li><a href="#1-%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97">1. 独立的列</a></li><li><a href="#2-%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95">2. 多列索引</a></li><li><a href="#3-%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F">3. 索引列的顺序</a></li><li><a href="#4-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95">4. 前缀索引</a></li><li><a href="#5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">5. 覆盖索引</a></li></ul></li><li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">索引的优点</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6">索引的使用条件</a></li></ul></li><li><a href="#%E4%BA%8C%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">二、查询性能优化</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-explain-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90">使用 Explain 进行分析</a></li><li><a href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">优化数据访问</a><ul><li><a href="#1-%E5%87%8F%E5%B0%91%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F">1. 减少请求的数据量</a></li><li><a href="#2-%E5%87%8F%E5%B0%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%89%AB%E6%8F%8F%E7%9A%84%E8%A1%8C%E6%95%B0">2. 减少服务器端扫描的行数</a></li></ul></li><li><a href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">重构查询方式</a><ul><li><a href="#1-%E5%88%87%E5%88%86%E5%A4%A7%E6%9F%A5%E8%AF%A2">1. 切分大查询</a></li><li><a href="#2-%E5%88%86%E8%A7%A3%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">2. 分解大连接查询</a></li></ul></li></ul></li><li><a href="#%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">三、存储引擎</a><ul><li><a href="#innodb">InnoDB</a></li><li><a href="#myisam">MyISAM</a></li><li><a href="#%E6%AF%94%E8%BE%83">比较</a></li></ul></li><li><a href="#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">四、数据类型</a><ul><li><a href="#%E6%95%B4%E5%9E%8B">整型</a></li><li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F">时间和日期</a><ul><li><a href="#1-datetime">1. DATETIME</a></li><li><a href="#2-timestamp">2. TIMESTAMP</a></li></ul></li></ul></li><li><a href="#%E4%BA%94%E5%88%87%E5%88%86">五、切分</a><ul><li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86">水平切分</a></li><li><a href="#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86">垂直切分</a></li><li><a href="#sharding-%E7%AD%96%E7%95%A5">Sharding 策略</a></li><li><a href="#sharding-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Sharding 存在的问题</a><ul><li><a href="#1-%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">1. 事务问题</a></li><li><a href="#2-%E8%BF%9E%E6%8E%A5">2. 连接</a></li><li><a href="#3-id-%E5%94%AF%E4%B8%80%E6%80%A7">3. ID 唯一性</a></li></ul></li></ul></li><li><a href="#%E5%85%AD%E5%A4%8D%E5%88%B6">六、复制</a><ul><li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主从复制</a></li><li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">读写分离</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="一、索引">一、索引</h2><h3 id="B-Tree-原理">B+ Tree 原理</h3><h4 id="1-数据结构">1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<code>&lt;sub&gt;</code>i<code>&lt;/sub&gt;</code> 和 key<code>&lt;sub&gt;</code>i+1<code>&lt;/sub&gt;</code>，且不为 null，则该指针指向节点的所有 key 大于等于 key<code>&lt;sub&gt;</code>i<code>&lt;/sub&gt;</code> 且小于等于 key<code>&lt;sub&gt;</code>i+1<code>&lt;/sub&gt;</code>。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br><h4 id="2-操作">2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h4 id="3-与红黑树的比较">3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p><p>（一）B+ 树有更低的树高</p><p>平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p><p>（二）磁盘访问原理</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p><p>（三）磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h3 id="MySQL-索引">MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h4 id="1-B-Tree-索引">1. B+Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" width="350px"> </div><br><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" width="350px"> </div><br><h4 id="2-哈希索引">2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引">3. 全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="4-空间数据索引">4. 空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引优化">索引优化</h3><h4 id="1-独立的列">1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="2-多列索引">2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="3-索引列的顺序">3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h4 id="4-前缀索引">4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h4 id="5-覆盖索引">5. 覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h3 id="索引的优点">索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h3 id="索引的使用条件">索引的使用条件</h3><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h2 id="二、查询性能优化">二、查询性能优化</h2><h3 id="使用-Explain-进行分析">使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h3 id="优化数据访问">优化数据访问</h3><h4 id="1-减少请求的数据量">1. 减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h4 id="2-减少服务器端扫描的行数">2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h3 id="重构查询方式">重构查询方式</h3><h4 id="1-切分大查询">1. 切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-分解大连接查询">2. 分解大连接查询</h4><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h2 id="三、存储引擎">三、存储引擎</h2><h3 id="InnoDB">InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h3 id="MyISAM">MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="比较-2">比较</h3><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><h2 id="四、数据类型">四、数据类型</h2><h3 id="整型">整型</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id="浮点数">浮点数</h3><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id="字符串">字符串</h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h3 id="时间和日期">时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h4 id="1-DATETIME">1. DATETIME</h4><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h4 id="2-TIMESTAMP">2. TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="五、切分">五、切分</h2><h3 id="水平切分">水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" width=""> </div><br><h3 id="垂直切分">垂直切分</h3><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" width=""> </div><br><h3 id="Sharding-策略">Sharding 策略</h3><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h3 id="Sharding-存在的问题">Sharding 存在的问题</h3><h4 id="1-事务问题">1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-连接">2. 连接</h4><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h4 id="3-ID-唯一性">3. ID 唯一性</h4><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h2 id="六、复制">六、复制</h2><h3 id="主从复制">主从复制</h3><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong>  ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程</strong>  ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li><strong>SQL 线程</strong>  ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png" width=""> </div><br><h3 id="读写分离">读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" width=""> </div><br><h2 id="参考资料-2">参考资料</h2><ul><li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li><li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li><li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li><li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases">How to create unique row ID in sharded databases?</a></li><li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry.">SQL Azure Federation – Introduction</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li><li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">How Sharding Works</a></li><li><a href="https://tech.meituan.com/dianping_order_db_sharding.html">大众点评订单系统分库分表实践</a></li><li><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B + 树</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/08/Socket/"/>
      <url>/2022/03/08/Socket/</url>
      
        <content type="html"><![CDATA[<h1>Socket</h1><!-- GFM-TOC --><ul><li><a href="#socket">Socket</a><ul><li><a href="#%E4%B8%80io-%E6%A8%A1%E5%9E%8B">一、I/O 模型</a><ul><li><a href="#%E9%98%BB%E5%A1%9E%E5%BC%8F-io">阻塞式 I/O</a></li><li><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-io">非阻塞式 I/O</a></li><li><a href="#io-%E5%A4%8D%E7%94%A8">I/O 复用</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-io">信号驱动 I/O</a></li><li><a href="#%E5%BC%82%E6%AD%A5-io">异步 I/O</a></li><li><a href="#%E4%BA%94%E5%A4%A7-io-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83">五大 I/O 模型比较</a></li></ul></li><li><a href="#%E4%BA%8Cio-%E5%A4%8D%E7%94%A8">二、I/O 复用</a><ul><li><a href="#select">select</a></li><li><a href="#poll">poll</a></li><li><a href="#%E6%AF%94%E8%BE%83">比较</a><ul><li><a href="#1-%E5%8A%9F%E8%83%BD">1. 功能</a></li><li><a href="#2-%E9%80%9F%E5%BA%A6">2. 速度</a></li><li><a href="#3-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7">3. 可移植性</a></li></ul></li><li><a href="#epoll">epoll</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">工作模式</a><ul><li><a href="#1-lt-%E6%A8%A1%E5%BC%8F">1. LT 模式</a></li><li><a href="#2-et-%E6%A8%A1%E5%BC%8F">2. ET 模式</a></li></ul></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a><ul><li><a href="#1-select-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1. select 应用场景</a></li><li><a href="#2-poll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">2. poll 应用场景</a></li><li><a href="#3-epoll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3. epoll 应用场景</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="一、I-O-模型">一、I/O 模型</h2><p>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><h3 id="阻塞式-I-O">阻塞式 I/O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p><p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png"/> </div><br><h3 id="非阻塞式-I-O">非阻塞式 I/O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png"/> </div><br><h3 id="I-O-复用">I/O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png"/> </div><br><h3 id="信号驱动-I-O">信号驱动 I/O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png"/> </div><br><h3 id="异步-I-O">异步 I/O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png"/> </div><br><h3 id="五大-I-O-模型比较">五大 I/O 模型比较</h3><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li><li>异步 I/O：第二阶段应用进程不会阻塞。</li></ul><p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png"/> </div><br><h2 id="二、I-O-复用">二、I/O 复用</h2><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="select">select</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p><ul><li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li><li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li><li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the sets</span></span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input events</span></span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output events</span></span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></span><br><span class="line"><span class="keyword">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to 10 seconds</span></span><br><span class="line">tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the select</span></span><br><span class="line"><span class="keyword">int</span> ret = select( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if select actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll">poll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p><p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">               <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The structure for two events</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 10 seconds</span></span><br><span class="line"><span class="keyword">int</span> ret = poll( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if poll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">0</span>].revents &amp; POLLIN )</span><br><span class="line">        fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">1</span>].revents &amp; POLLOUT )</span><br><span class="line">        fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较">比较</h3><h4 id="1-功能">1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><ul><li>select 会修改描述符，而 poll 不会；</li><li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li></ul><h4 id="2-速度">2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p><h4 id="3-可移植性">3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h3 id="epoll">epoll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span></span><br><span class="line"><span class="comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span></span><br><span class="line"><span class="keyword">int</span> pollingfd = epoll_create( <span class="number">0xCAFE</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )</span><br><span class="line"> <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the epoll structure in case more members are added in future</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the connection class instance with the event. You can associate anything</span></span><br><span class="line"><span class="comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span></span><br><span class="line"><span class="comment">// waiting in epoll_wait - the descriptor will be properly added</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[ 20 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span></span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait( pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if epoll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any events detected</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get back our connection pointer</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作模式">工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><h4 id="1-LT-模式">1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h4 id="2-ET-模式">2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="应用场景">应用场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h4 id="1-select-应用场景">1. select 应用场景</h4><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><h4 id="2-poll-应用场景">2. poll 应用场景</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><h4 id="3-epoll-应用场景">3. epoll 应用场景</h4><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p><h2 id="参考资料">参考资料</h2><ul><li>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</li><li><a href="http://man7.org/linux/man-pages/man2/select.2.html">http://man7.org/linux/man-pages/man2/select.2.html</a></li><li><a href="http://man7.org/linux/man-pages/man2/poll.2.html">http://man7.org/linux/man-pages/man2/poll.2.html</a></li><li><a href="https://www.ibm.com/developerworks/linux/library/l-async/">Boost application performance using asynchronous I/O</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx">Synchronous and Asynchronous I/O</a></li><li><a href="https://segmentfault.com/a/1190000003063859">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href="https://daniel.haxx.se/docs/poll-vs-select.html">poll vs select vs event-based</a></li><li><a href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/">select / poll / epoll: practical difference for system architects</a></li><li><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/06/HTTP/"/>
      <url>/2022/03/06/HTTP/</url>
      
        <content type="html"><![CDATA[<h1>HTTP</h1><!-- GFM-TOC --><ul><li><a href="#http">HTTP</a><ul><li><a href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">一 、基础概念</a><ul><li><a href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">请求和响应报文</a></li><li><a href="#url">URL</a></li></ul></li><li><a href="#%E4%BA%8Chttp-%E6%96%B9%E6%B3%95">二、HTTP 方法</a><ul><li><a href="#get">GET</a></li><li><a href="#head">HEAD</a></li><li><a href="#post">POST</a></li><li><a href="#put">PUT</a></li><li><a href="#patch">PATCH</a></li><li><a href="#delete">DELETE</a></li><li><a href="#options">OPTIONS</a></li><li><a href="#connect">CONNECT</a></li><li><a href="#trace">TRACE</a></li></ul></li><li><a href="#%E4%B8%89http-%E7%8A%B6%E6%80%81%E7%A0%81">三、HTTP 状态码</a><ul><li><a href="#1xx-%E4%BF%A1%E6%81%AF">1XX 信息</a></li><li><a href="#2xx-%E6%88%90%E5%8A%9F">2XX 成功</a></li><li><a href="#3xx-%E9%87%8D%E5%AE%9A%E5%90%91">3XX 重定向</a></li><li><a href="#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">4XX 客户端错误</a></li><li><a href="#5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">5XX 服务器错误</a></li></ul></li><li><a href="#%E5%9B%9Bhttp-%E9%A6%96%E9%83%A8">四、HTTP 首部</a><ul><li><a href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">通用首部字段</a></li><li><a href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">请求首部字段</a></li><li><a href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">响应首部字段</a></li><li><a href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">实体首部字段</a></li></ul></li><li><a href="#%E4%BA%94%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8">五、具体应用</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a><ul><li><a href="#1-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5">1. 短连接与长连接</a></li><li><a href="#2-%E6%B5%81%E6%B0%B4%E7%BA%BF">2. 流水线</a></li></ul></li><li><a href="#cookie">Cookie</a><ul><li><a href="#1-%E7%94%A8%E9%80%94">1. 用途</a></li><li><a href="#2-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">2. 创建过程</a></li><li><a href="#3-%E5%88%86%E7%B1%BB">3. 分类</a></li><li><a href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F">4. 作用域</a></li><li><a href="#5-javascript">5. JavaScript</a></li><li><a href="#6-httponly">6. HttpOnly</a></li><li><a href="#7-secure">7. Secure</a></li><li><a href="#8-session">8. Session</a></li><li><a href="#9-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8-cookie">9. 浏览器禁用 Cookie</a></li><li><a href="#10-cookie-%E4%B8%8E-session-%E9%80%89%E6%8B%A9">10. Cookie 与 Session 选择</a></li></ul></li><li><a href="#%E7%BC%93%E5%AD%98">缓存</a><ul><li><a href="#1-%E4%BC%98%E7%82%B9">1. 优点</a></li><li><a href="#2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">2. 实现方法</a></li><li><a href="#3-cache-control">3. Cache-Control</a></li><li><a href="#4-%E7%BC%93%E5%AD%98%E9%AA%8C%E8%AF%81">4. 缓存验证</a></li></ul></li><li><a href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">内容协商</a><ul><li><a href="#1-%E7%B1%BB%E5%9E%8B">1. 类型</a></li><li><a href="#2-vary">2. Vary</a></li></ul></li><li><a href="#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81">内容编码</a></li><li><a href="#%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82">范围请求</a><ul><li><a href="#1-range">1. Range</a></li><li><a href="#2-accept-ranges">2. Accept-Ranges</a></li><li><a href="#3-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">3. 响应状态码</a></li></ul></li><li><a href="#%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">分块传输编码</a></li><li><a href="#%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88">多部分对象集合</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">虚拟主机</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91">通信数据转发</a><ul><li><a href="#1-%E4%BB%A3%E7%90%86">1. 代理</a></li><li><a href="#2-%E7%BD%91%E5%85%B3">2. 网关</a></li><li><a href="#3-%E9%9A%A7%E9%81%93">3. 隧道</a></li></ul></li></ul></li><li><a href="#%E5%85%ADhttps">六、HTTPS</a><ul><li><a href="#%E5%8A%A0%E5%AF%86">加密</a><ul><li><a href="#1-%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">1. 对称密钥加密</a></li><li><a href="#2%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">2.非对称密钥加密</a></li><li><a href="#3-https-%E9%87%87%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F">3. HTTPS 采用的加密方式</a></li></ul></li><li><a href="#%E8%AE%A4%E8%AF%81">认证</a></li><li><a href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4">完整性保护</a></li><li><a href="#https-%E7%9A%84%E7%BC%BA%E7%82%B9">HTTPS 的缺点</a></li></ul></li><li><a href="#%E4%B8%83http20">七、HTTP/2.0</a><ul><li><a href="#http1x-%E7%BC%BA%E9%99%B7">HTTP/1.x 缺陷</a></li><li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82">二进制分帧层</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81">服务端推送</a></li><li><a href="#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9">首部压缩</a></li></ul></li><li><a href="#%E5%85%ABhttp11-%E6%96%B0%E7%89%B9%E6%80%A7">八、HTTP/1.1 新特性</a></li><li><a href="#%E4%B9%9Dget-%E5%92%8C-post-%E6%AF%94%E8%BE%83">九、GET 和 POST 比较</a><ul><li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li><li><a href="#%E5%8F%82%E6%95%B0">参数</a></li><li><a href="#%E5%AE%89%E5%85%A8">安全</a></li><li><a href="#%E5%B9%82%E7%AD%89%E6%80%A7">幂等性</a></li><li><a href="#%E5%8F%AF%E7%BC%93%E5%AD%98">可缓存</a></li><li><a href="#xmlhttprequest">XMLHttpRequest</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="一-、基础概念">一 、基础概念</h2><h3 id="请求和响应报文">请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET http:<span class="comment">//www.example.com/ HTTP/1.1</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br><span class="line"><span class="comment">Host: www.example.com</span></span><br><span class="line"><span class="comment">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span></span><br><span class="line"><span class="comment">If-None-Match: &quot;3147526947+gzip&quot;</span></span><br><span class="line"><span class="comment">Proxy-Connection: keep-alive</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 xxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">param1=1&amp;param2=2</span></span><br></pre></td></tr></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Age: <span class="number">529651</span></span><br><span class="line">Cache-Control: max-age=<span class="number">604800</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">648</span></span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">Date: Mon, <span class="number">02</span> Nov <span class="number">2020</span> <span class="number">17</span>:<span class="number">53</span>:<span class="number">39</span> GMT</span><br><span class="line">Etag: <span class="string">&quot;3147526947+ident+gzip&quot;</span></span><br><span class="line">Expires: Mon, <span class="number">09</span> Nov <span class="number">2020</span> <span class="number">17</span>:<span class="number">53</span>:<span class="number">39</span> GMT</span><br><span class="line">Keep-Alive: timeout=<span class="number">4</span></span><br><span class="line">Last-Modified: Thu, <span class="number">17</span> Oct <span class="number">2019</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">26</span> GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc/<span class="number">16</span>DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line"><span class="comment">// 省略... </span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="URL">URL</h3><p>HTTP 使用 URL（ <strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是  URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" width="500px"> </div><br><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">wikipedia：统一资源标志符</a></li><li><a href="https://en.wikipedia.org/wiki/URL">wikipedia: URL</a></li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2">rfc2616：3.2.2 http URL</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn">What is the difference between a URI, a URL and a URN?</a></li></ul><h2 id="二、HTTP-方法">二、HTTP 方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p><h3 id="GET">GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id="HEAD">HEAD</h3><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h3 id="POST">POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>更多 POST 与 GET 的比较请见第九章。</p><h3 id="PUT">PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PATCH">PATCH</h3><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure><h3 id="DELETE">DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure><h3 id="OPTIONS">OPTIONS</h3><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h3 id="CONNECT">CONNECT</h3><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" width=""/> </div><br><h3 id="TRACE">TRACE</h3><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><ul><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">rfc2616：9 Method Definitions</a></li></ul><h2 id="三、HTTP-状态码">三、HTTP 状态码</h2><p>服务器返回的   <strong>响应报文</strong>   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h3 id="1XX-信息">1XX 信息</h3><ul><li><strong>100 Continue</strong>  ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功">2XX 成功</h3><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong>  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong>  ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h3 id="3XX-重定向">3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong>  ：永久性重定向</li><li><strong>302 Found</strong>  ：临时性重定向</li><li><strong>303 See Other</strong>  ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong>  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong>  ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h3 id="4XX-客户端错误">4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong>  ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>  ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong>  ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h3 id="5XX-服务器错误">5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong>  ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong>  ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="四、HTTP-首部">四、HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h3 id="通用首部字段">通用首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h3 id="请求首部字段">请求首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">优先的字符集</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">优先的内容编码</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">优先的语言（自然语言）</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">Web 认证信息</td></tr><tr><td style="text-align:center">Expect</td><td style="text-align:center">期待服务器的特定行为</td></tr><tr><td style="text-align:center">From</td><td style="text-align:center">用户的电子邮箱地址</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求资源所在服务器</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">比较实体标记（ETag）</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">比较资源的更新时间</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">比较实体标记（与 If-Match 相反）</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">最大传输逐跳数</td></tr><tr><td style="text-align:center">Proxy-Authorization</td><td style="text-align:center">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">实体的字节范围请求</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:center">TE</td><td style="text-align:center">传输编码的优先级</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="响应首部字段">响应首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">是否接受字节范围请求</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">推算资源创建经过时间</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">令客户端重定向至指定 URI</td></tr><tr><td style="text-align:center">Proxy-Authenticate</td><td style="text-align:center">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">HTTP 服务器的安装信息</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="实体首部字段">实体首部字段</h3><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:center">资源可支持的 HTTP 方法</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">实体主体适用的编码方式</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">实体主体的自然语言</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">实体主体的大小</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">替代对应资源的 URI</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">实体主体的报文摘要</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">实体主体的位置范围</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">实体主体的媒体类型</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">实体主体过期的日期时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="五、具体应用">五、具体应用</h2><h3 id="连接管理">连接管理</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" width="800"/> </div><br><h4 id="1-短连接与长连接">1. 短连接与长连接</h4><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用<code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用<code>Connection : Keep-Alive</code>。</li></ul><h4 id="2-流水线">2. 流水线</h4><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h3 id="Cookie">Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="1-用途">1. 用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="2-创建过程">2. 创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h4 id="3-分类">3. 分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h4 id="4-作用域">4. 作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 <a href="http://Domain=mozilla.org">Domain=mozilla.org</a>，则 Cookie 也包含在子域名中（如 <a href="http://developer.mozilla.org">developer.mozilla.org</a>）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/”) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h4 id="5-JavaScript">5. JavaScript</h4><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;yummy_cookie=choco&quot;;</span><br><span class="line">document.cookie = &quot;tasty_cookie=strawberry&quot;;</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure><h4 id="6-HttpOnly">6. HttpOnly</h4><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h4 id="7-Secure">7. Secure</h4><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="8-Session">8. Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h4 id="9-浏览器禁用-Cookie">9. 浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="10-Cookie-与-Session-选择">10. Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="缓存-2">缓存</h3><h4 id="1-优点">1. 优点</h4><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id="2-实现方法">2. 实现方法</h4><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h4 id="3-Cache-Control">3. Cache-Control</h4><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><strong>3.1 禁止进行缓存</strong></p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p><strong>3.2 强制确认缓存</strong></p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p><strong>3.3 私有缓存和公共缓存</strong></p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><p><strong>3.4 缓存过期机制</strong></p><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id="4-缓存验证">4. 缓存验证</h4><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><h3 id="内容协商">内容协商</h3><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h4 id="1-类型">1. 类型</h4><p><strong>1.1 服务端驱动型</strong></p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>1.2 代理驱动型</strong></p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h4 id="2-Vary">2. Vary</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h3 id="内容编码">内容编码</h3><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p><p>常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p><h3 id="范围请求">范围请求</h3><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h4 id="1-Range">1. Range</h4><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><h4 id="2-Accept-Ranges">2. Accept-Ranges</h4><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><h4 id="3-响应状态码">3. 响应状态码</h4><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h3 id="分块传输编码">分块传输编码</h3><p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h3 id="多部分对象集合">多部分对象集合</h3><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit-name&quot;</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h3 id="虚拟主机">虚拟主机</h3><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h3 id="通信数据转发">通信数据转发</h3><h4 id="1-代理">1. 代理</h4><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><ul><li>用户察觉得到正向代理的存在。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" width=""/> </div><br><ul><li>而反向代理一般位于内部网络中，用户察觉不到。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" width=""/> </div><br><h4 id="2-网关">2. 网关</h4><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h4 id="3-隧道">3. 隧道</h4><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="六、HTTPS">六、HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" width="700"/> </div><br><h3 id="加密">加密</h3><h4 id="1-对称密钥加密">1. 对称密钥加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"/> </div><br><h4 id="2-非对称密钥加密">2.非对称密钥加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"/> </div><br><h4 id="3-HTTPS-采用的加密方式">3. HTTPS 采用的加密方式</h4><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" width="600"/> </div><br><h3 id="认证">认证</h3><p>通过使用   <strong>证书</strong>   来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" width=""/> </div><br><h3 id="完整性保护">完整性保护</h3><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h3 id="HTTPS-的缺点">HTTPS 的缺点</h3><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="七、HTTP-2-0">七、HTTP/2.0</h2><h3 id="HTTP-1-x-缺陷">HTTP/1.x 缺陷</h3><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h3 id="二进制分帧层">二进制分帧层</h3><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" width="400"/> </div><br><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" width="600"/> </div><br><h3 id="服务端推送">服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" width="800"/> </div><br><h3 id="首部压缩">首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" width="600"/> </div><br><h2 id="八、HTTP-1-1-新特性">八、HTTP/1.1 新特性</h2><p>详细内容请见上文</p><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h2 id="九、GET-和-POST-比较">九、GET 和 POST 比较</h2><h3 id="作用">作用</h3><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h3 id="参数">参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><h3 id="安全">安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h3 id="幂等性">幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure><h3 id="可缓存">可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h3 id="XMLHttpRequest">XMLHttpRequest</h3><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h2 id="参考资料-4">参考资料</h2><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">MDN : HTTP</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></li><li><a href="http://php.net/manual/zh/function.htmlspecialchars.php">htmlspecialchars</a></li><li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java">Difference between file URI and URL in java</a></li><li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html">浅谈 HTTP 中 Get 与 Post 的区别</a></li><li><a href="https://www.webdancers.com/are-http-and-www-necesary/">Are http:// and www really necessary?</a></li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html">HTTP (HyperText Transfer Protocol)</a></li><li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg">File:HTTP persistent connection.svg</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server">Proxy server</a></li><li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/">What is SSL Offloading?</a></li><li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication">An Introduction to Mutual SSL Authentication</a></li><li><a href="https://danielmiessler.com/study/url-uri/">The Difference Between URLs and URIs</a></li><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment">Cookie 与 Session 的区别</a></li><li><a href="https://www.zhihu.com/question/19786827">COOKIE 和 SESSION 有什么区别</a></li><li><a href="https://harttle.land/2015/08/10/cookie-session.html">Cookie/Session 的机制与安全</a></li><li><a href="https://shijianan.com/2017/06/11/https/">HTTPS 证书原理</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn">What is the difference between a URI, a URL and a URN?</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li><li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2">Web 性能优化与 HTTP/2</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络 - 概述</h1><!-- GFM-TOC --><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E6%A6%82%E8%BF%B0">计算机网络 - 概述</a><ul><li><a href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li><li><a href="#isp">ISP</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">主机之间的通信方式</a></li><li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">电路交换与分组交换</a><ul><li><a href="#1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1. 电路交换</a></li><li><a href="#2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">2. 分组交换</a></li></ul></li><li><a href="#%E6%97%B6%E5%BB%B6">时延</a><ul><li><a href="#1-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">1. 排队时延</a></li><li><a href="#2-%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">2. 处理时延</a></li><li><a href="#3-%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6">3. 传输时延</a></li><li><a href="#4-%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">4. 传播时延</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a><ul><li><a href="#1-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">1. 五层协议</a></li><li><a href="#2-osi">2. OSI</a></li><li><a href="#3-tcpip">3. TCP/IP</a></li><li><a href="#4-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B">4. 数据在各层之间的传递过程</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82">计算机网络-物理层</a><ul><li><a href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a><ul><li><a href="#%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6">带通调制</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E9%93%BE%E8%B7%AF%E5%B1%82">计算机网络 - 链路层</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a><ul><li><a href="#1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">1. 封装成帧</a></li><li><a href="#2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">2. 透明传输</a></li><li><a href="#3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3. 差错检测</a></li></ul></li><li><a href="#%E4%BF%A1%E9%81%93%E5%88%86%E7%B1%BB">信道分类</a><ul><li><a href="#1-%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">1. 广播信道</a></li><li><a href="#2-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">2. 点对点信道</a></li></ul></li><li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a><ul><li><a href="#1-%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8">1. 频分复用</a></li><li><a href="#2-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">2. 时分复用</a></li><li><a href="#3-%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">3. 统计时分复用</a></li><li><a href="#4-%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8">4. 波分复用</a></li><li><a href="#5-%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8">5. 码分复用</a></li></ul></li><li><a href="#csmacd-%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li><li><a href="#ppp-%E5%8D%8F%E8%AE%AE">PPP 协议</a></li><li><a href="#mac-%E5%9C%B0%E5%9D%80">MAC 地址</a></li><li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li><li><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E7%BD%91%E7%BB%9C%E5%B1%82">计算机网络 - 网络层</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li><li><a href="#ip-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a><ul><li><a href="#1-%E5%88%86%E7%B1%BB">1. 分类</a></li><li><a href="#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li><li><a href="#3-%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li></ul></li><li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li><li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a><ul><li><a href="#1-ping">1. Ping</a></li><li><a href="#2-traceroute">2. Traceroute</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a><ul><li><a href="#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li><li><a href="#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li><li><a href="#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E4%BC%A0%E8%BE%93%E5%B1%82">计算机网络 - 传输层</a><ul><li><a href="#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li><li><a href="#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li><li><a href="#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li><li><a href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li><li><a href="#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li><li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li><li><a href="#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li><li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li><li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a><ul><li><a href="#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li><li><a href="#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E5%BA%94%E7%94%A8%E5%B1%82">计算机网络 - 应用层</a><ul><li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">文件传送协议</a></li><li><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机配置协议</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE">远程登录协议</a></li><li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a><ul><li><a href="#1-smtp">1. SMTP</a></li><li><a href="#2-pop3">2. POP3</a></li><li><a href="#3-imap">3. IMAP</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li><li><a href="#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a><ul><li><a href="#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li><li><a href="#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li><li><a href="#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li><li><a href="#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><h2 id="网络的网络">网络的网络</h2><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" width="450"/> </div><br><h2 id="ISP">ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" width="500"/> </div><br><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" width="500"/> </div><br><h2 id="主机之间的通信方式">主机之间的通信方式</h2><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" width="240px"> </div><br><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" width="200px"> </div><br><h2 id="电路交换与分组交换">电路交换与分组交换</h2><h3 id="1-电路交换">1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><h3 id="2-分组交换">2. 分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h2 id="时延">时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" width="380"/> </div><br><h3 id="1-排队时延">1. 排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h3 id="2-处理时延">2. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p><h3 id="3-传输时延">3. 传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(bit)}{v(bit/s)}" class="mathjax-pic"/></div> <br> --><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" width="150px"> </div><br><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="4-传播时延">4. 传播时延</h3><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(m)}{v(m/s)}" class="mathjax-pic"/></div> <br> --><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" width="150"> </div><br><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h2 id="计算机网络体系结构">计算机网络体系结构</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/> </div><br><h3 id="1-五层协议">1. 五层协议</h3><ul><li><strong>应用层</strong>  ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文(message)。</li><li><strong>传输层</strong>  ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段(segment)；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报(User datagram)。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong>  ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组(packet)。</li><li><strong>数据链路层</strong>  ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong>  ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="2-OSI">2. OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong>  ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="3-TCP-IP">3. TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="250"/> </div><br><h3 id="4-数据在各层之间的传递过程">4. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1>计算机网络-物理层</h1><h2 id="通信方式">通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h3 id="带通调制">带通调制</h3><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p><img src="https://camo.githubusercontent.com/59e58745fe8f7b2ec9020e6fb10da969ee0ecc5ba40bb04318690171449586bc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63333466343530332d663632632d343034332d396463362d3365303332383836353764662e6a7067" alt=""></p><h1>计算机网络 - 链路层</h1><!-- GFM-TOC --><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E6%A6%82%E8%BF%B0">计算机网络 - 概述</a><ul><li><a href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li><li><a href="#isp">ISP</a></li><li><a href="#%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">主机之间的通信方式</a></li><li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">电路交换与分组交换</a><ul><li><a href="#1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1. 电路交换</a></li><li><a href="#2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">2. 分组交换</a></li></ul></li><li><a href="#%E6%97%B6%E5%BB%B6">时延</a><ul><li><a href="#1-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">1. 排队时延</a></li><li><a href="#2-%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">2. 处理时延</a></li><li><a href="#3-%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6">3. 传输时延</a></li><li><a href="#4-%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">4. 传播时延</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a><ul><li><a href="#1-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">1. 五层协议</a></li><li><a href="#2-osi">2. OSI</a></li><li><a href="#3-tcpip">3. TCP/IP</a></li><li><a href="#4-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B">4. 数据在各层之间的传递过程</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82">计算机网络-物理层</a><ul><li><a href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a><ul><li><a href="#%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6">带通调制</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E9%93%BE%E8%B7%AF%E5%B1%82">计算机网络 - 链路层</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a><ul><li><a href="#1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">1. 封装成帧</a></li><li><a href="#2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">2. 透明传输</a></li><li><a href="#3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3. 差错检测</a></li></ul></li><li><a href="#%E4%BF%A1%E9%81%93%E5%88%86%E7%B1%BB">信道分类</a><ul><li><a href="#1-%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">1. 广播信道</a></li><li><a href="#2-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">2. 点对点信道</a></li></ul></li><li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a><ul><li><a href="#1-%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8">1. 频分复用</a></li><li><a href="#2-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">2. 时分复用</a></li><li><a href="#3-%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">3. 统计时分复用</a></li><li><a href="#4-%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8">4. 波分复用</a></li><li><a href="#5-%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8">5. 码分复用</a></li></ul></li><li><a href="#csmacd-%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li><li><a href="#ppp-%E5%8D%8F%E8%AE%AE">PPP 协议</a></li><li><a href="#mac-%E5%9C%B0%E5%9D%80">MAC 地址</a></li><li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li><li><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA">交换机</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E7%BD%91%E7%BB%9C%E5%B1%82">计算机网络 - 网络层</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li><li><a href="#ip-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a><ul><li><a href="#1-%E5%88%86%E7%B1%BB">1. 分类</a></li><li><a href="#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li><li><a href="#3-%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li></ul></li><li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li><li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a><ul><li><a href="#1-ping">1. Ping</a></li><li><a href="#2-traceroute">2. Traceroute</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a><ul><li><a href="#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li><li><a href="#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li><li><a href="#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E4%BC%A0%E8%BE%93%E5%B1%82">计算机网络 - 传输层</a><ul><li><a href="#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li><li><a href="#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li><li><a href="#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li><li><a href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li><li><a href="#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li><li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li><li><a href="#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li><li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li><li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a><ul><li><a href="#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li><li><a href="#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E5%BA%94%E7%94%A8%E5%B1%82">计算机网络 - 应用层</a><ul><li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">文件传送协议</a></li><li><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机配置协议</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE">远程登录协议</a></li><li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a><ul><li><a href="#1-smtp">1. SMTP</a></li><li><a href="#2-pop3">2. POP3</a></li><li><a href="#3-imap">3. IMAP</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li><li><a href="#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a><ul><li><a href="#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li><li><a href="#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li><li><a href="#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li><li><a href="#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><h2 id="基本问题">基本问题</h2><h3 id="1-封装成帧">1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" width="300"/> </div><br><h3 id="2-透明传输">2. 透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" width="500"/> </div><br><h3 id="3-差错检测">3. 差错检测</h3><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类">信道分类</h2><h3 id="1-广播信道">1. 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="2-点对点信道">2. 点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术">信道复用技术</h2><h3 id="1-频分复用">1. 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" width="350"/> </div><br><h3 id="2-时分复用">2. 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" width="350"/> </div><br><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><h3 id="3-统计时分复用">3. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" width="350"/> </div><br><h3 id="4-波分复用">4. 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="5-码分复用">5. 码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;S&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 和 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;T&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 有</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0" class="mathjax-pic"/></div> <br> --><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" width="100px"> </div><br><p>为了讨论方便，取 m=8，设码片 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;S&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1" class="mathjax-pic"/></div> <br> --><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1" class="mathjax-pic"/></div> <br> --><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" width="100px"> </div><br><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" width="125px"> </div><br><p>其中 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;S'&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 为 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;S&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 <code>&lt;img src=&quot;https://latex.codecogs.com/gif.latex?\vec&#123;S&#125;&quot; class=&quot;mathjax-pic&quot;/&gt;</code> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" width="500px"> </div><br><h2 id="CSMA-CD-协议">CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, …, (2<code>&lt;sup&gt;</code>k<code>&lt;/sup&gt;</code>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" width="400"/> </div><br><h2 id="PPP-协议">PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" width="300"/> </div><br><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" width="400"/> </div><br><h2 id="MAC-地址">MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网">局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" width="800"/> </div><br><h2 id="以太网">以太网</h2><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><ul><li><strong>类型</strong>  ：标记上层使用的协议；</li><li><strong>数据</strong>  ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" width="500"/> </div><br><h2 id="交换机">交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" width="800"/> </div><br><h2 id="虚拟局域网">虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" width="500"/> </div><br><h1>计算机网络 - 网络层</h1><!-- GFM-TOC --><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E7%BD%91%E7%BB%9C%E5%B1%82">计算机网络 - 网络层</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li><li><a href="#ip-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F">IP 地址编址方式</a><ul><li><a href="#1-%E5%88%86%E7%B1%BB">1. 分类</a></li><li><a href="#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86">2. 子网划分</a></li><li><a href="#3-%E6%97%A0%E5%88%86%E7%B1%BB">3. 无分类</a></li></ul></li><li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li><li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a><ul><li><a href="#1-ping">1. Ping</a></li><li><a href="#2-traceroute">2. Traceroute</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a><ul><li><a href="#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li><li><a href="#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li><li><a href="#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><h2 id="概述">概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" width="800"/> </div><br><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式">IP 数据报格式</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"/> </div><br><ul><li><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong>   : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"/> </div><br><h2 id="IP-地址编址方式">IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="1-分类">1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br><h3 id="2-子网划分">2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="3-无分类">3. 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="地址解析协议-ARP">地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"/> </div><br><p>ARP 实现由 IP 地址得到 MAC 地址。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"/> </div><br><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"/> </div><br><h2 id="网际控制报文协议-ICMP">网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/> </div><br><p>ICMP 报文分为差错报告报文和询问报文。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"/> </div><br><h3 id="1-Ping">1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="2-Traceroute">2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="虚拟专用网-VPN">虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"/> </div><br><h2 id="网络地址转换-NAT">网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> </div><br><h2 id="路由器的结构">路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"/> </div><br><h2 id="路由器分组转发流程">路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"/> </div><br><h2 id="路由选择协议">路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><h3 id="1-内部网关协议-RIP">1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF">2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议-BGP">3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"/> </div><br><h1>计算机网络 - 传输层</h1><!-- GFM-TOC --><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E4%BC%A0%E8%BE%93%E5%B1%82">计算机网络 - 传输层</a><ul><li><a href="#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li><li><a href="#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li><li><a href="#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li><li><a href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li><li><a href="#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li><li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li><li><a href="#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li><li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li><li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a><ul><li><a href="#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li><li><a href="#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="UDP-和-TCP-的特点">UDP 和 TCP 的特点</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h2 id="UDP-首部格式">UDP 首部格式</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式">TCP 首部格式</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br><ul><li><strong>序号</strong>   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong>   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong>   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="TCP-的三次握手">TCP 的三次握手</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="TCP-的四次挥手">TCP 的四次挥手</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="TCP-可靠传输">TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT" class="mathjax-pic"/></div> <br>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d" class="mathjax-pic"/></div> <br>其中 RTT<sub>d</sub> 为偏差的加权平均值。<h2 id="TCP-滑动窗口">TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br><h2 id="TCP-流量控制">TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="TCP-拥塞控制">TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br><h3 id="1-慢开始与拥塞避免">1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="2-快重传与快恢复">2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<code>&lt;sub&gt;</code>1<code>&lt;/sub&gt;</code> 和 M<code>&lt;sub&gt;</code>2<code>&lt;/sub&gt;</code>，此时收到 M<code>&lt;sub&gt;</code>4<code>&lt;/sub&gt;</code>，应当发送对 M<code>&lt;sub&gt;</code>2<code>&lt;/sub&gt;</code> 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<code>&lt;sub&gt;</code>2<code>&lt;/sub&gt;</code>，则 M<code>&lt;sub&gt;</code>3<code>&lt;/sub&gt;</code> 丢失，立即重传 M<code>&lt;sub&gt;</code>3<code>&lt;/sub&gt;</code>。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br><h1>计算机网络 - 应用层</h1><!-- GFM-TOC --><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C---%E5%BA%94%E7%94%A8%E5%B1%82">计算机网络 - 应用层</a><ul><li><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">文件传送协议</a></li><li><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机配置协议</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE">远程登录协议</a></li><li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a><ul><li><a href="#1-smtp">1. SMTP</a></li><li><a href="#2-pop3">2. POP3</a></li><li><a href="#3-imap">3. IMAP</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li><li><a href="#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a><ul><li><a href="#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li><li><a href="#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li><li><a href="#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li><li><a href="#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li></ul></li></ul></li></ul><!-- GFM-TOC --><h2 id="域名系统">域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg"/> </div><br><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h2 id="文件传送协议">文件传送协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><ul><li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg"/> </div><br><ul><li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg"/> </div><br><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h2 id="动态主机配置协议">动态主机配置协议</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"/> </div><br><h2 id="远程登录协议">远程登录协议</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议">电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"/> </div><br><h3 id="1-SMTP">1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""/> </div><br><h3 id="2-POP3">2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h3 id="3-IMAP">3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p><h2 id="常用端口">常用端口</h2><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">端口号</th><th style="text-align:center">传输层协议</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">域名解析</td><td style="text-align:center">DNS</td><td style="text-align:center">53</td><td style="text-align:center">UDP/TCP</td><td style="text-align:center">长度超过 512 字节时使用 TCP</td></tr><tr><td style="text-align:center">动态主机配置协议</td><td style="text-align:center">DHCP</td><td style="text-align:center">67/68</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单网络管理协议</td><td style="text-align:center">SNMP</td><td style="text-align:center">161/162</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">文件传送协议</td><td style="text-align:center">FTP</td><td style="text-align:center">20/21</td><td style="text-align:center">TCP</td><td style="text-align:center">控制连接 21，数据连接 20</td></tr><tr><td style="text-align:center">远程终端协议</td><td style="text-align:center">TELNET</td><td style="text-align:center">23</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">超文本传送协议</td><td style="text-align:center">HTTP</td><td style="text-align:center">80</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单邮件传送协议</td><td style="text-align:center">SMTP</td><td style="text-align:center">25</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">邮件读取协议</td><td style="text-align:center">POP3</td><td style="text-align:center">110</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">网际报文存取协议</td><td style="text-align:center">IMAP</td><td style="text-align:center">143</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr></tbody></table><h2 id="Web-页面请求过程">Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息">1. DHCP 配置主机信息</h3><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li><li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF，将广播到与交换机连接的所有设备。</li><li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h3 id="2-ARP-解析-MAC-地址">2. ARP 解析 MAC 地址</h3><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li><li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li></ul><h3 id="3-DNS-解析域名">3. DNS 解析域名</h3><ul><li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li><li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li><li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li><li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li></ul><h3 id="4-HTTP-请求页面">4. HTTP 请求页面</h3><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/04/linux%E5%85%A5%E9%97%A8/"/>
      <url>/2022/03/04/linux%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>Linux</h1><!-- GFM-TOC --><ul><li><a href="#linux">Linux</a><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#%E4%B8%80%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5">一、常用操作以及概念</a><ul><li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li><li><a href="#%E6%B1%82%E5%8A%A9">求助</a><ul><li><a href="#1---help">1. --help</a></li><li><a href="#2-man">2. man</a></li><li><a href="#3-info">3. info</a></li><li><a href="#4-doc">4. doc</a></li></ul></li><li><a href="#%E5%85%B3%E6%9C%BA">关机</a><ul><li><a href="#1-who">1. who</a></li><li><a href="#2-sync">2. sync</a></li><li><a href="#3-shutdown">3. shutdown</a></li></ul></li><li><a href="#path">PATH</a></li><li><a href="#sudo">sudo</a></li><li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">包管理工具</a></li><li><a href="#%E5%8F%91%E8%A1%8C%E7%89%88">发行版</a></li><li><a href="#vim-%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F">VIM 三个模式</a></li><li><a href="#gnu">GNU</a></li><li><a href="#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE">开源协议</a></li></ul></li><li><a href="#%E4%BA%8C%E7%A3%81%E7%9B%98">二、磁盘</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E6%8E%A5%E5%8F%A3">磁盘接口</a><ul><li><a href="#1-ide">1. IDE</a></li><li><a href="#2-sata">2. SATA</a></li><li><a href="#3-scsi">3. SCSI</a></li><li><a href="#4-sas">4. SAS</a></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D">磁盘的文件名</a></li></ul></li><li><a href="#%E4%B8%89%E5%88%86%E5%8C%BA">三、分区</a><ul><li><a href="#%E5%88%86%E5%8C%BA%E8%A1%A8">分区表</a><ul><li><a href="#1-mbr">1. MBR</a></li><li><a href="#2-gpt">2. GPT</a></li></ul></li><li><a href="#%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F">开机检测程序</a><ul><li><a href="#1-bios">1. BIOS</a></li><li><a href="#2-uefi">2. UEFI</a></li></ul></li></ul></li><li><a href="#%E5%9B%9B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">四、文件系统</a><ul><li><a href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分区与文件系统</a></li><li><a href="#%E7%BB%84%E6%88%90">组成</a></li><li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">文件读取</a></li><li><a href="#%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87">磁盘碎片</a></li><li><a href="#block">block</a></li><li><a href="#inode">inode</a></li><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E6%97%A5%E5%BF%97">日志</a></li><li><a href="#%E6%8C%82%E8%BD%BD">挂载</a></li><li><a href="#%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">目录配置</a></li></ul></li><li><a href="#%E4%BA%94%E6%96%87%E4%BB%B6">五、文件</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">文件属性</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">文件与目录的基本操作</a><ul><li><a href="#1-ls">1. ls</a></li><li><a href="#2-cd">2. cd</a></li><li><a href="#3-mkdir">3. mkdir</a></li><li><a href="#4-rmdir">4. rmdir</a></li><li><a href="#5-touch">5. touch</a></li><li><a href="#6-cp">6. cp</a></li><li><a href="#7-rm">7. rm</a></li><li><a href="#8-mv">8. mv</a></li></ul></li><li><a href="#%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90">修改权限</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90">默认权限</a></li><li><a href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90">目录的权限</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a><ul><li><a href="#1-%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5">1. 实体链接</a></li><li><a href="#2-%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5">2. 符号链接</a></li></ul></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">获取文件内容</a><ul><li><a href="#1-cat">1. cat</a></li><li><a href="#2-tac">2. tac</a></li><li><a href="#3-more">3. more</a></li><li><a href="#4-less">4. less</a></li><li><a href="#5-head">5. head</a></li><li><a href="#6-tail">6. tail</a></li><li><a href="#7-od">7. od</a></li></ul></li><li><a href="#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2">指令与文件搜索</a><ul><li><a href="#1-which">1. which</a></li><li><a href="#2-whereis">2. whereis</a></li><li><a href="#3-locate">3. locate</a></li><li><a href="#4-find">4. find</a></li></ul></li></ul></li><li><a href="#%E5%85%AD%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85">六、压缩与打包</a><ul><li><a href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%90%8D">压缩文件名</a></li><li><a href="#%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4">压缩指令</a><ul><li><a href="#1-gzip">1. gzip</a></li><li><a href="#2-bzip2">2. bzip2</a></li><li><a href="#3-xz">3. xz</a></li></ul></li><li><a href="#%E6%89%93%E5%8C%85">打包</a></li></ul></li><li><a href="#%E4%B8%83bash">七、Bash</a><ul><li><a href="#%E7%89%B9%E6%80%A7">特性</a></li><li><a href="#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C">变量操作</a></li><li><a href="#%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F">指令搜索顺序</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91">数据流重定向</a></li></ul></li><li><a href="#%E5%85%AB%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4">八、管道指令</a><ul><li><a href="#%E6%8F%90%E5%8F%96%E6%8C%87%E4%BB%A4">提取指令</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E6%8C%87%E4%BB%A4">排序指令</a></li><li><a href="#%E5%8F%8C%E5%90%91%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">双向输出重定向</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4">字符转换指令</a></li><li><a href="#%E5%88%86%E5%8C%BA%E6%8C%87%E4%BB%A4">分区指令</a></li></ul></li><li><a href="#%E4%B9%9D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">九、正则表达式</a><ul><li><a href="#grep">grep</a></li><li><a href="#printf">printf</a></li><li><a href="#awk">awk</a></li></ul></li><li><a href="#%E5%8D%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">十、进程管理</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a><ul><li><a href="#1-ps">1. ps</a></li><li><a href="#2-pstree">2. pstree</a></li><li><a href="#3-top">3. top</a></li><li><a href="#4-netstat">4. netstat</a></li></ul></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a></li><li><a href="#sigchld">SIGCHLD</a></li><li><a href="#wait">wait()</a></li><li><a href="#waitpid">waitpid()</a></li><li><a href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">孤儿进程</a></li><li><a href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">僵尸进程</a></li></ul></li><li><a href="#piduid">PID,UID</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="前言">前言</h2><p>为了便于理解，本文从常用操作和概念开始讲起。虽然已经尽量做到简化，但是涉及到的内容还是有点多。在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可。为了方便大家准备面试，在此先将一些比较重要的知识点列出来：</p><ul><li>能简单使用 cat，grep，cut 等命令进行一些操作；</li><li>文件系统相关的原理，inode 和 block 等概念，数据恢复；</li><li>硬链接与软链接；</li><li>进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。</li><li>一、四、五、八、九、十</li></ul><h2 id="一、常用操作以及概念">一、常用操作以及概念</h2><h3 id="快捷键">快捷键</h3><ul><li>Tab：命令和文件名补全；</li><li>Ctrl+C：中断正在运行的程序；</li><li>Ctrl+D：结束键盘输入（End Of File，EOF）</li></ul><h3 id="求助">求助</h3><h4 id="1-help">1. --help</h4><p>指令的基本用法与选项介绍。</p><h4 id="2-man">2. man</h4><p>man 是 manual 的缩写，将指令的具体信息显示出来。</p><p>当执行 <code>man date</code> 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p><table><thead><tr><th style="text-align:center">代号</th><th>类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>用户在 shell 环境中可以操作的指令或者可执行文件</td></tr><tr><td style="text-align:center">5</td><td>配置文件</td></tr><tr><td style="text-align:center">8</td><td>系统管理员可以使用的管理指令</td></tr></tbody></table><h4 id="3-info">3. info</h4><p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。</p><h4 id="4-doc">4. doc</h4><p>/usr/share/doc 存放着软件的一整套说明文件。</p><h3 id="关机">关机</h3><h4 id="1-who">1. who</h4><p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p><h4 id="2-sync">2. sync</h4><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p><h4 id="3-shutdown">3. shutdown</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## shutdown [-krhc] 时间 [信息]</span><br><span class="line">-k ： 不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class="line">-r ： 将系统的服务停掉后就重新启动</span><br><span class="line">-h ： 将系统的服务停掉后就立即关机</span><br><span class="line">-c ： 取消已经在进行的 shutdown</span><br></pre></td></tr></table></figure><p><img src="/img/linux/example1.png" alt=""></p><h3 id="PATH">PATH</h3><p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br></pre></td></tr></table></figure><h3 id="sudo">sudo</h3><p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p><h3 id="包管理工具">包管理工具</h3><p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p><ul><li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li><li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li></ul><h3 id="发行版">发行版</h3><p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p><table><thead><tr><th style="text-align:center">基于的包管理工具</th><th style="text-align:center">商业发行版</th><th style="text-align:center">社区发行版</th></tr></thead><tbody><tr><td style="text-align:center">RPM</td><td style="text-align:center">Red Hat</td><td style="text-align:center">Fedora / CentOS</td></tr><tr><td style="text-align:center">DPKG</td><td style="text-align:center">Ubuntu</td><td style="text-align:center">Debian</td></tr></tbody></table><h3 id="VIM-三个模式">VIM 三个模式</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png"/> </div><br><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p>在指令列模式下，有以下命令用于离开或者保存文件。</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">写入磁盘</td></tr><tr><td style="text-align:center">:w!</td><td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">离开</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制离开不保存</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">写入磁盘后离开</td></tr><tr><td style="text-align:center">:wq!</td><td style="text-align:center">强制写入磁盘后离开</td></tr></tbody></table><h3 id="GNU">GNU</h3><p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：</p><ul><li>以任何目的运行此程序的自由；</li><li>再复制的自由；</li><li>改进此程序，并公开发布改进的自由。</li></ul><h3 id="开源协议">开源协议</h3><ul><li><a href="https://choosealicense.com/">Choose an open source license</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a></li></ul><h2 id="二、磁盘">二、磁盘</h2><h3 id="磁盘接口">磁盘接口</h3><h4 id="1-IDE">1. IDE</h4><p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg" width="400"/> </div><br><h4 id="2-SATA">2. SATA</h4><p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg" width=""/> </div><br><h4 id="3-SCSI">3. SCSI</h4><p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg" width=""/> </div><br><h4 id="4-SAS">4. SAS</h4><p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg" width=""/> </div><br><h3 id="磁盘的文件名">磁盘的文件名</h3><p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p><ul><li>IDE 磁盘：/dev/hd[a-d]</li><li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li></ul><p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p><h2 id="三、分区">三、分区</h2><h3 id="分区表">分区表</h3><p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p><h4 id="1-MBR">1. MBR</h4><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p><p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p><p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p><h4 id="2-GPT">2. GPT</h4><p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p><p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p><p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p><p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<code>&lt;sup&gt;</code>33<code>&lt;/sup&gt;</code> TB = 8 ZB。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png" width="400"/> </div><br><h3 id="开机检测程序">开机检测程序</h3><h4 id="1-BIOS">1. BIOS</h4><p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"/> </div><br><p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p><p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p><p>下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg" width="600"/> </div><br><p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p><h4 id="2-UEFI">2. UEFI</h4><p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p><h2 id="四、文件系统">四、文件系统</h2><h3 id="分区与文件系统">分区与文件系统</h3><p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p><h3 id="组成">组成</h3><p>最主要的几个组成部分如下：</p><ul><li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li><li>block：记录文件的内容，文件太大时，会占用多个 block。</li></ul><p>除此之外还包括：</p><ul><li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>block bitmap：记录 block 是否被使用的位图。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png" width="800"/> </div></br><h3 id="文件读取">文件读取</h3><p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" width="500px"> </div></br><p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" width="500px"> </div></br><h3 id="磁盘碎片">磁盘碎片</h3><p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p><h3 id="block">block</h3><p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p><table><thead><tr><th style="text-align:center">大小</th><th style="text-align:center">1KB</th><th style="text-align:center">2KB</th><th style="text-align:center">4KB</th></tr></thead><tbody><tr><td style="text-align:center">最大单一文件</td><td style="text-align:center">16GB</td><td style="text-align:center">256GB</td><td style="text-align:center">2TB</td></tr><tr><td style="text-align:center">最大文件系统</td><td style="text-align:center">2TB</td><td style="text-align:center">8TB</td><td style="text-align:center">16TB</td></tr></tbody></table><p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p><h3 id="inode">inode</h3><p>inode 具体包含以下信息：</p><ul><li>权限 (read/write/excute)；</li><li>拥有者与群组 (owner/group)；</li><li>容量；</li><li>建立或状态改变的时间 (ctime)；</li><li>最近读取时间 (atime)；</li><li>最近修改时间 (mtime)；</li><li>定义文件特性的旗标 (flag)，如 SetUID…；</li><li>该文件真正内容的指向 (pointer)。</li></ul><p>inode 具有以下特点：</p><ul><li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li><li>每个文件都仅会占用一个 inode。</li></ul><p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg" width="600"/> </div><br><h3 id="目录">目录</h3><p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p><p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p><p>目录的直接表现与文件夹类似</p><h3 id="日志">日志</h3><p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p><p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p><h3 id="挂载">挂载</h3><p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p><h3 id="目录配置">目录配置</h3><p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p><ul><li>/ (root, 根目录)</li><li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li><li>/var (variable)：存放系统或程序运行过程中的数据文件。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png" width=""/> </div><br><h2 id="五、文件">五、文件</h2><h3 id="文件属性">文件属性</h3><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p>文件时间有以下三种：</p><ul><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h3 id="文件与目录的基本操作">文件与目录的基本操作</h3><h4 id="1-ls">1. ls</h4><p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure><h4 id="2-cd">2. cd</h4><p>更换当前目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><h4 id="3-mkdir">3. mkdir</h4><p>创建目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## mkdir [-mp] 目录名称</span><br><span class="line">-m ：配置目录权限</span><br><span class="line">-p ：递归创建目录</span><br></pre></td></tr></table></figure><h4 id="4-rmdir">4. rmdir</h4><p>删除目录，目录必须为空。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br><span class="line">-p ：递归删除目录</span><br></pre></td></tr></table></figure><h4 id="5-touch">5. touch</h4><p>更新文件时间或者建立新文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure><h4 id="6-cp">6. cp</h4><p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve=all</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure><h4 id="7-rm">7. rm</h4><p>删除文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## rm [-fir] 文件或目录</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure><h4 id="8-mv">8. mv</h4><p>移动文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## mv [-fiu] source destination</span><br><span class="line">## mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure><h3 id="修改权限">修改权限</h3><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure><p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod 754 .bashrc</span><br></pre></td></tr></table></figure><p>也可以使用符号来设定权限。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- =：设定权限</span><br></pre></td></tr></table></figure><p>示例：为 .bashrc 文件的所有用户添加写权限。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod a+w .bashrc</span><br></pre></td></tr></table></figure><h3 id="默认权限">默认权限</h3><ul><li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li><li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li></ul><p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p><h3 id="目录的权限">目录的权限</h3><p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p><p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p><h3 id="链接">链接</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" width="450px"> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ln [-sf] source_filename dist_filename</span><br><span class="line">-s ：默认是实体链接，加 -s 为符号链接</span><br><span class="line">-f ：如果目标文件存在时，先删除目标文件</span><br></pre></td></tr></table></figure><h4 id="1-实体链接">1. 实体链接</h4><p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p><p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p><p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ln /etc/crontab .</span><br><span class="line">## ll -i /etc/crontab crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure><h4 id="2-符号链接">2. 符号链接</h4><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p><p>当源文件被删除了，链接文件就打不开了。</p><p>因为记录的是路径，所以可以为目录建立符号链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ll -i /etc/crontab /root/crontab2</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br><span class="line">53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure><h3 id="获取文件内容">获取文件内容</h3><h4 id="1-cat">1. cat</h4><p>取得文件内容。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## cat [-AbEnTv] filename</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br></pre></td></tr></table></figure><h4 id="2-tac">2. tac</h4><p>是 cat 的反向操作，从最后一行开始打印。</p><h4 id="3-more">3. more</h4><p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p><h4 id="4-less">4. less</h4><p>和 more 类似，但是多了一个向前翻页的功能。</p><h4 id="5-head">5. head</h4><p>取得文件前几行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## head [-n number] filename</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure><h4 id="6-tail">6. tail</h4><p>是 head 的反向操作，只是取得是后几行。</p><h4 id="7-od">7. od</h4><p>以字符或者十六进制的形式显示二进制文件。</p><h3 id="指令与文件搜索">指令与文件搜索</h3><h4 id="1-which">1. which</h4><p>指令搜索。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## which [-a] command</span><br><span class="line">-a ：将所有指令列出，而不是只列第一个</span><br></pre></td></tr></table></figure><h4 id="2-whereis">2. whereis</h4><p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## whereis [-bmsu] dirname/filename</span><br></pre></td></tr></table></figure><h4 id="3-locate">3. locate</h4><p>文件搜索。可以用关键字或者正则表达式进行搜索。</p><p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## locate [-ir] keyword</span><br><span class="line">-r：正则表达式</span><br></pre></td></tr></table></figure><h4 id="4-find">4. find</h4><p>文件搜索。可以使用文件的属性和权限进行搜索。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## find [basedir] [option]</span><br><span class="line">example: find . -name &quot;shadow*&quot;</span><br></pre></td></tr></table></figure><p><strong>① 与时间有关的选项</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-mtime  n ：列出在 n 天前的那一天修改过内容的文件</span><br><span class="line">-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件</span><br><span class="line">-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件</span><br><span class="line">-newer file ： 列出比 file 更新的文件</span><br></pre></td></tr></table></figure><p>+4、4 和 -4 的指示的时间范围如下：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png" width=""/> </div><br><p><strong>② 与文件拥有者和所属群组有关的选项</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-uid n</span><br><span class="line">-gid n</span><br><span class="line">-user name</span><br><span class="line">-group name</span><br><span class="line">-nouser ：搜索拥有者不存在 /etc/passwd 的文件</span><br><span class="line">-nogroup：搜索所属群组不存在于 /etc/group 的文件</span><br></pre></td></tr></table></figure><p><strong>③ 与文件权限和名称有关的选项</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-name filename</span><br><span class="line">-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span><br><span class="line">-type TYPE</span><br><span class="line">-perm mode  ：搜索权限等于 mode 的文件</span><br><span class="line">-perm -mode ：搜索权限包含 mode 的文件</span><br><span class="line">-perm /mode ：搜索权限包含任一 mode 的文件</span><br></pre></td></tr></table></figure><h2 id="六、压缩与打包">六、压缩与打包</h2><h3 id="压缩文件名">压缩文件名</h3><p>Linux 底下有很多压缩文件名，常见的如下：</p><table><thead><tr><th>扩展名</th><th>压缩程序</th></tr></thead><tbody><tr><td>*.Z</td><td>compress</td></tr><tr><td>*.zip</td><td>zip</td></tr><tr><td>*.gz</td><td>gzip</td></tr><tr><td>*.bz2</td><td>bzip2</td></tr><tr><td>*.xz</td><td>xz</td></tr><tr><td>*.tar</td><td>tar 程序打包的数据，没有经过压缩</td></tr><tr><td>*.tar.gz</td><td>tar 程序打包的文件，经过 gzip 的压缩</td></tr><tr><td>*.tar.bz2</td><td>tar 程序打包的文件，经过 bzip2 的压缩</td></tr><tr><td>*.tar.xz</td><td>tar 程序打包的文件，经过 xz 的压缩</td></tr></tbody></table><h3 id="压缩指令">压缩指令</h3><h4 id="1-gzip">1. gzip</h4><p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p><p>经过 gzip 压缩过，源文件就不存在了。</p><p>有 9 个不同的压缩等级可以使用。</p><p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span><br><span class="line">-c ：将压缩的数据输出到屏幕上</span><br><span class="line">-d ：解压缩</span><br><span class="line">-t ：检验压缩文件是否出错</span><br><span class="line">-v ：显示压缩比等信息</span><br><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br></pre></td></tr></table></figure><h4 id="2-bzip2">2. bzip2</h4><p>提供比 gzip 更高的压缩比。</p><p>查看命令：bzcat、bzmore、bzless、bzgrep。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ bzip2 [-cdkzv#] filename</span><br><span class="line">-k ：保留源文件</span><br></pre></td></tr></table></figure><h4 id="3-xz">3. xz</h4><p>提供比 bzip2 更佳的压缩比。</p><p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p><p>查看命令：xzcat、xzmore、xzless、xzgrep。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span><br></pre></td></tr></table></figure><h3 id="打包">打包</h3><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class="line">-z ：使用 zip；</span><br><span class="line">-j ：使用 bzip2；</span><br><span class="line">-J ：使用 xz；</span><br><span class="line">-c ：新建打包文件；</span><br><span class="line">-t ：查看打包文件里面有哪些文件；</span><br><span class="line">-x ：解打包或解压缩的功能；</span><br><span class="line">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class="line">-f : filename：要处理的文件；</span><br><span class="line">-C 目录 ： 在特定目录解压缩。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">使用方式</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:center">打包压缩</td><td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td></tr><tr><td style="text-align:center">查 看</td><td>tar -jtv -f filename.tar.bz2</td></tr><tr><td style="text-align:center">解压缩</td><td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td></tr></tbody></table><h2 id="七、Bash">七、Bash</h2><p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p><h3 id="特性">特性</h3><ul><li>命令历史：记录使用过的命令</li><li>命令与文件补全：快捷键：tab</li><li>命名别名：例如 ll 是 ls -al 的别名</li><li>shell scripts</li><li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li></ul><h3 id="变量操作">变量操作</h3><p>对一个变量赋值直接使用 =。</p><p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p><p>输出变量使用 echo 命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ x=abc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br></pre></td></tr></table></figure><p>变量内容如果有空格，必须使用双引号或者单引号。</p><ul><li>双引号内的特殊字符可以保留原本特性，例如 x=“lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li><li>单引号内的特殊字符就是特殊字符本身，例如 x=‘lang is $LANG’，则 x 的值为 lang is $LANG。</li></ul><p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p><p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p><p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ declare [-aixr] variable</span><br><span class="line">-a ： 定义为数组类型</span><br><span class="line">-i ： 定义为整数类型</span><br><span class="line">-x ： 定义为环境变量</span><br><span class="line">-r ： 定义为 readonly 类型</span><br></pre></td></tr></table></figure><p>使用 [ ] 来对数组进行索引操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ array[1]=a</span><br><span class="line">$ array[2]=b</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="指令搜索顺序">指令搜索顺序</h3><ul><li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li><li>由别名找到该指令来执行；</li><li>由 Bash 内置的指令来执行；</li><li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li></ul><h3 id="数据流重定向">数据流重定向</h3><p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">代码</th><th style="text-align:center">运算符</th></tr></thead><tbody><tr><td style="text-align:center">标准输入 (stdin)</td><td style="text-align:center">0</td><td style="text-align:center">&lt; 或 &lt;&lt;</td></tr><tr><td style="text-align:center">标准输出 (stdout)</td><td style="text-align:center">1</td><td style="text-align:center">&gt; 或 &gt;&gt;</td></tr><tr><td style="text-align:center">标准错误输出 (stderr)</td><td style="text-align:center">2</td><td style="text-align:center">2&gt; 或 2&gt;&gt;</td></tr></tbody></table><p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p><p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p><p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="八、管道指令">八、管道指令</h2><p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p><p>在命令之间使用 | 分隔各个管道命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al /etc | less</span><br></pre></td></tr></table></figure><h3 id="提取指令">提取指令</h3><p>cut 对数据进行切分，取出想要的部分。</p><p>切分过程一行一行地进行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d ：分隔符</span><br><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间</span><br><span class="line">-c ：以字符为单位取出区间</span><br></pre></td></tr></table></figure><p>示例 1：last 显示登入者的信息，取出用户名。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last</span><br><span class="line">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class="line">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line"></span><br><span class="line">$ last | cut -d &#x27; &#x27; -f 1</span><br></pre></td></tr></table></figure><p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ export</span><br><span class="line">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class="line">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class="line">declare -x HOME=&quot;/home/dmtsai&quot;</span><br><span class="line">declare -x HOSTNAME=&quot;study.centos.vbird&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"></span><br><span class="line">$ export | cut -c 12-</span><br></pre></td></tr></table></figure><h3 id="排序指令">排序指令</h3><p><strong>sort</strong>   用于排序。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">-f ：忽略大小写</span><br><span class="line">-b ：忽略最前面的空格</span><br><span class="line">-M ：以月份的名字来排序，例如 JAN，DEC</span><br><span class="line">-n ：使用数字</span><br><span class="line">-r ：反向排序</span><br><span class="line">-u ：相当于 unique，重复的内容只出现一次</span><br><span class="line">-t ：分隔符，默认为 tab</span><br><span class="line">-k ：指定排序的区间</span><br></pre></td></tr></table></figure><p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line">arod:x:1002:1003::/home/arod:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>uniq</strong>   可以将重复的数据只取一个。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ uniq [-ic]</span><br><span class="line">-i ：忽略大小写</span><br><span class="line">-c ：进行计数</span><br></pre></td></tr></table></figure><p>示例：取得每个人的登录总次数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c</span><br><span class="line">1</span><br><span class="line">6 (unknown</span><br><span class="line">47 dmtsai</span><br><span class="line">4 reboot</span><br><span class="line">7 root</span><br><span class="line">1 wtmp</span><br></pre></td></tr></table></figure><h3 id="双向输出重定向">双向输出重定向</h3><p>输出重定向会将输出内容重定向到文件中，而   <strong>tee</strong>   不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tee [-a] file</span><br></pre></td></tr></table></figure><h3 id="字符转换指令">字符转换指令</h3><p><strong>tr</strong>   用来删除一行中的字符，或者对字符进行替换。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tr [-ds] SET1 ...</span><br><span class="line">-d ： 删除行中 SET1 这个字符串</span><br></pre></td></tr></table></figure><p>示例，将 last 输出的信息所有小写转换为大写。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure><p><strong>col</strong>   将 tab 字符转为空格字符。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ col [-xb]</span><br><span class="line">-x ： 将 tab 键转换成对等的空格键</span><br></pre></td></tr></table></figure><p><strong>expand</strong>   将 tab 转换一定数量的空格，默认是 8 个。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ expand [-t] file</span><br><span class="line">-t ：tab 转为空格的数量</span><br></pre></td></tr></table></figure><p><strong>join</strong>   将有相同数据的那一行合并在一起。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ join [-ti12] file1 file2</span><br><span class="line">-t ：分隔符，默认为空格</span><br><span class="line">-i ：忽略大小写的差异</span><br><span class="line">-1 ：第一个文件所用的比较字段</span><br><span class="line">-2 ：第二个文件所用的比较字段</span><br></pre></td></tr></table></figure><p><strong>paste</strong>   直接将两行粘贴在一起。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ paste [-d] file1 file2</span><br><span class="line">-d ：分隔符，默认为 tab</span><br></pre></td></tr></table></figure><h3 id="分区指令">分区指令</h3><p><strong>split</strong>   将一个文件划分成多个文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span><br><span class="line">-b ：以大小来进行分区，可加单位，例如 b, k, m 等</span><br><span class="line">-l ：以行数来进行分区。</span><br><span class="line">- PREFIX ：分区文件的前导名称</span><br></pre></td></tr></table></figure><h2 id="九、正则表达式">九、正则表达式</h2><h3 id="grep">grep</h3><p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class="line">-c ： 统计匹配到行的个数</span><br><span class="line">-i ： 忽略大小写</span><br><span class="line">-n ： 输出行号</span><br><span class="line">-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行</span><br><span class="line">--color=auto ：找到的关键字加颜色显示</span><br></pre></td></tr></table></figure><p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep -n &#x27;the&#x27; regular_express.txt</span><br><span class="line">8:I can&#x27;t finish the test.</span><br><span class="line">12:the symbol &#x27;*&#x27; is represented as start.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world Happy is the same with &quot;glad&quot;.</span><br><span class="line">18:google is the best tools for search keyword</span><br></pre></td></tr></table></figure><p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep -n &#x27;a\&#123;2,5\&#125;&#x27; regular_express.txt</span><br></pre></td></tr></table></figure><h3 id="printf">printf</h3><p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ printf &#x27;%10s %5i %5i %5i %8.2f \n&#x27; $(cat printf.txt)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure><h3 id="awk">awk</h3><p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p><p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p><p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5</span><br><span class="line">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span><br><span class="line">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   Fri</span><br></pre></td></tr></table></figure><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...&#x27; filename</span><br></pre></td></tr></table></figure><p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#x27;</span><br><span class="line">root 0</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br></pre></td></tr></table></figure><p>awk 变量：</p><table><thead><tr><th style="text-align:center">变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td style="text-align:center">NF</td><td>每一行拥有的字段总数</td></tr><tr><td style="text-align:center">NR</td><td>目前所处理的是第几行数据</td></tr><tr><td style="text-align:center">FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>示例：显示正在处理的行号以及每一行有多少字段</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF&#125;&#x27;</span><br><span class="line">dmtsai lines: 1 columns: 10</span><br><span class="line">dmtsai lines: 2 columns: 10</span><br><span class="line">dmtsai lines: 3 columns: 10</span><br><span class="line">dmtsai lines: 4 columns: 10</span><br><span class="line">dmtsai lines: 5 columns: 9</span><br></pre></td></tr></table></figure><h2 id="十、进程管理">十、进程管理</h2><h3 id="查看进程">查看进程</h3><h4 id="1-ps">1. ps</h4><p>查看某个时间点的进程信息。</p><p>示例：查看自己的进程</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps -l</span></span><br></pre></td></tr></table></figure><p>示例：查看系统所有进程</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps aux</span></span><br></pre></td></tr></table></figure><p>示例：查看特定的进程</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps aux | grep threadx</span></span><br></pre></td></tr></table></figure><h4 id="2-pstree">2. pstree</h4><p>查看进程树。</p><p>示例：查看所有进程树</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## pstree -A</span></span><br></pre></td></tr></table></figure><h4 id="3-top">3. top</h4><p>实时显示进程信息。</p><p>示例：两秒钟刷新一次</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## top -d 2</span></span><br></pre></td></tr></table></figure><h4 id="4-netstat">4. netstat</h4><p>查看占用端口的进程</p><p>示例：查看特定端口的进程</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## netstat -anp | grep port</span></span><br></pre></td></tr></table></figure><h3 id="进程状态">进程状态</h3><table><thead><tr><th style="text-align:center">状态</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">R</td><td>running or runnable (on run queue)<code>&lt;br&gt;</code>正在执行或者可执行，此时进程位于执行队列中。</td></tr><tr><td style="text-align:center">D</td><td>uninterruptible sleep (usually I/O)<code>&lt;br&gt;</code>不可中断阻塞，通常为 IO 阻塞。</td></tr><tr><td style="text-align:center">S</td><td>interruptible sleep (waiting for an event to complete)<code>&lt;br&gt;</code> 可中断阻塞，此时进程正在等待某个事件完成。</td></tr><tr><td style="text-align:center">Z</td><td>zombie (terminated but not reaped by its parent)<code>&lt;br&gt;</code>僵死，进程已经终止但是尚未被其父进程获取信息。</td></tr><tr><td style="text-align:center">T</td><td>stopped (either by a job control signal or because it is being traced)<code>&lt;br&gt;</code> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td></tr><tr><td style="text-align:center"><code>&lt;br&gt;</code></td><td></td></tr></tbody></table><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png" width="490px"/> </div><br><h3 id="SIGCHLD">SIGCHLD</h3><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p><ul><li>得到 SIGCHLD 信号；</li><li>waitpid() 或者 wait() 调用会返回。</li></ul><p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p><p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p><div align="center"> <!-- <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/flow.png" width=""/> --> </div><br><h3 id="wait">wait()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span></span><br></pre></td></tr></table></figure><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p><p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p><p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p><h3 id="waitpid">waitpid()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p><p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p><p>options 参数主要有 <code>WNOHANG</code> 和 <code>WUNTRACED</code> 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p><h3 id="孤儿进程">孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p><p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h3 id="僵尸进程">僵尸进程</h3><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p><h2 id="PID-UID">PID,UID</h2><blockquote><p>PID – 进程ID<br>PPID – 父进程ID<br>SID – 会话ID<br>PGID – 流程组ID<br>UID – 用户ID<br>EUID – Effective User ID</p></blockquote><h2 id="参考资料-6">参考资料</h2><ul><li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html">Linux 平台上的软件包管理</a></li><li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></li><li><a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link">What is the difference between a symbolic link and a hard link?</a></li><li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/">Linux process states</a></li><li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</a></li><li><a href="https://blog.csdn.net/kevinhg/article/details/7001719">详解 wait 和 waitpid 函数</a></li><li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li><li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/">Akai IB-301S SCSI Interface for S2800,S3000</a></li><li><a href="https://en.wikipedia.org/wiki/Parallel_ATA">Parallel ATA</a></li><li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li><li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1">Decoding UCS Invicta – Part 1</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a></li><li><a href="http://www.differencebetween.info/difference-between-sas-and-sata">Difference between SAS and SATA</a></li><li><a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a></li><li><a href="https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html">File system design case studies</a></li><li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml">Programming Project #4</a></li><li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html">FILE SYSTEM DESIGN</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.md">参考教程</a></p><h2 id="基本特征">基本特征</h2><h3 id="并发">并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><div class="note info simple"><p>进程与线程的区别</p></div><h3 id="共享">共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h3 id="虚拟">虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><div class="note info simple"><p>内存要存储页表</p></div><h3 id="异步">异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="基本功能">基本功能</h2><h3 id="进程管理">进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="内存管理">内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h3 id="文件管理">文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="设备管理">设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h2 id="系统调用">系统调用</h2><p><img src="/img/OperatingSystem/example1.png" alt=""></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th>Task</th><th>Commands</th></tr></thead><tbody><tr><td>进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td>进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td>文件操作</td><td>open(); read(); write();</td></tr><tr><td>设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td>信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td>安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="宏内核和微内核">宏内核和微内核</h2><h3 id="宏内核">宏内核</h3><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="微内核">微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><img src="/img/OperatingSystem/example2.png" alt=""></p><h2 id="中断分类">中断分类</h2><h3 id="外中断">外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="异常">异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="陷入">陷入</h3><p>在用户程序中使用系统调用。</p><h1>进程管理</h1><h2 id="进程与线程">进程与线程</h2><h3 id="1-进程">1. 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="/img/OperatingSystem/example3.png" alt=""></p><h3 id="2-线程">2. 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h3 id="3-区别">3. 区别</h3><p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(进程间通信，interprocess communication)。</p><h2 id="进程状态的切换">进程状态的切换</h2><p><img src="/img/OperatingSystem/example4.png" alt=""></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="进程调度算法">进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="1-批处理系统">1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><h4 id="1-1-先来先服务-first-come-first-serverd（FCFS）">1.1 先来先服务 first-come first-serverd（FCFS）</h4><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="1-2-短作业优先-shortest-job-first（SJF）">1.2 短作业优先 shortest job first（SJF）</h4><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="1-3-最短剩余时间优先-shortest-remaining-time-next（SRTN）">1.3 最短剩余时间优先 shortest remaining time next（SRTN）</h4><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="2-交互式系统">2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h4 id="2-1-时间片轮转">2.1 时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br>而如果时间片过长，那么实时性就不能得到保证。</p><h4 id="2-2-优先级调度">2.2 优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h4 id="2-3-多级反馈队列">2.3 多级反馈队列</h4><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="/img/OperatingSystem/example5.png" alt=""></p><h3 id="3-实时系统">3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="进程同步">进程同步</h2><h3 id="1-临界区">1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-同步与互斥">2. 同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-信号量">3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<br>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。<br>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <code>互斥量（Mutex）</code> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用信号量实现生产者-消费者问题</p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 <code>mutex</code>来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">produce_item</span>();</span><br><span class="line">        <span class="built_in">down</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">insert_item</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">down</span>(&amp;full);</span><br><span class="line">        <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">remove_item</span>();</span><br><span class="line">        <span class="built_in">consume_item</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-管程">4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了 <code>类 Pascal</code>语言来描述管程。示例代码的管程提供了 <code>insert()</code>和 <code>remove()</code> 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 条件变量 以及相关的操作：<code>wait()</code>和 <code>signal()</code>来实现同步操作。对条件变量执行 <code>wait()</code> 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。<code>signal()</code> 操作用于唤醒被阻塞的进程。</p><p>使用管程实现生产者-消费者问题</p><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题">经典同步问题</h2><h3 id="1-哲学家进餐问题">1. 哲学家进餐问题</h3><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-读者-写者问题">2. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信-IPC">进程通信(IPC)</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h3 id="1-管道">1. 管道</h3><p>管道是通过调用 <code>pipe</code>函数创建的，<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><p><img src="/img/OperatingSystem/example6.png" alt=""></p><h3 id="2-FIFO">2. FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><p><img src="/img/OperatingSystem/example7.png" alt=""></p><h3 id="3-消息队列">3. 消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h3 id="4-信号量">4. 信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h3 id="5-共享存储">5. 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><p>Linux系统中，进程可以通过共享内存实现进程间通信。共享内存主要有两种实现方法：XSI共享存储(通过shmget，shmat，shmdt等函数实现)和内存映射(mmap实现)。两者的主要区别是前者没有相关的文件，共享的是内存匿名段；而后者通常需要指定一个文件路径，调用open函数打开之后实现mmap内存映射。涉及到多个进程共享存储区，就必须有访问控制，这通常通过信号量，记录锁和互斥量实现。下面分别介绍每一种方法的使用细节。</p><p><a href="https://www.cnblogs.com/yuanwebpage/p/12422529.html">XSI共享存储和内存映射</a></p><h3 id="6-套接字">6. 套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h1>计算机操作系统 - 死锁</h1><h2 id="必要条件">必要条件</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png" alt=""></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h2 id="处理方法">处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h2 id="鸵鸟策略">鸵鸟策略</h2><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h2 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><h3 id="1-每种类型一个资源的死锁检测">1. 每种类型一个资源的死锁检测</h3><p><img src="" alt=""></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h3 id="2-每种类型多个资源的死锁检测">2. 每种类型多个资源的死锁检测</h3><p><img src="" alt=""></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3可以，让 P3 执行，之后释放 P3拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。4</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h3 id="3-死锁恢复">3. 死锁恢复</h3><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防">死锁预防</h2><p>在程序运行之前预防发生死锁。</p><h3 id="1-破坏互斥条件">1. 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h3 id="2-破坏占有和等待条件">2. 破坏占有和等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h3 id="3-破坏不可抢占条件">3. 破坏不可抢占条件</h3><h3 id="4-破坏环路等待">4. 破坏环路等待</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h2 id="死锁避免">死锁避免</h2><p>在程序运行时避免发生死锁。</p><h3 id="1-安全状态">1. 安全状态</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png" alt=""></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="2-单个资源的银行家算法">2. 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt=""></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="3-多个资源的银行家算法">3. 多个资源的银行家算法</h3><p><img src="" alt=""></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1>内存管理</h1><h2 id="虚拟内存">虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="" alt=""></p><h2 id="分页系统地址映射">分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br><h2 id="页面置换算法">页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最佳">1. 最佳</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-最近最久未使用">2. 最近最久未使用</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br><h3 id="3-最近未使用">3. 最近未使用</h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3 id="4-先进先出">4. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3 id="5-第二次机会算法">5. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br><h3 id="6-时钟">6. 时钟</h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br><h2 id="分段">分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br><h2 id="段页式">段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h2 id="分页与分段的比较">分页与分段的比较</h2><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h1>设备管理</h1><h2 id="磁盘结构">磁盘结构</h2><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br><h2 id="磁盘调度算法">磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h3 id="1-先来先服务">1. 先来先服务</h3><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="2-最短寻道时间优先">2. 最短寻道时间优先</h3><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br><h3 id="3-电梯算法">3. 电梯算法</h3><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br><h1>链接</h1><h2 id="编译系统">编译系统</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h2 id="静态链接">静态链接</h2><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br><h2 id="目标文件">目标文件</h2><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h2 id="动态链接">动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/02/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/02/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Redis</h1><!-- GFM-TOC --><ul><li><a href="#redis">Redis</a><ul><li><a href="#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li><li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">二、数据类型</a><ul><li><a href="#string">STRING</a></li><li><a href="#list">LIST</a></li><li><a href="#set">SET</a></li><li><a href="#hash">HASH</a></li><li><a href="#zset">ZSET</a></li></ul></li><li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">三、数据结构</a><ul><li><a href="#%E5%AD%97%E5%85%B8">字典</a></li><li><a href="#%E8%B7%B3%E8%B7%83%E8%A1%A8">跳跃表</a></li></ul></li><li><a href="#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、使用场景</a><ul><li><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li><li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E8%A1%A8">查找表</a></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li><li><a href="#%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98">会话缓存</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">分布式锁实现</a></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a></li></ul></li><li><a href="#%E4%BA%94redis-%E4%B8%8E-memcached">五、Redis 与 Memcached</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li><li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">内存管理机制</a></li></ul></li><li><a href="#%E5%85%AD%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">六、键的过期时间</a></li><li><a href="#%E4%B8%83%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">七、数据淘汰策略</a></li><li><a href="#%E5%85%AB%E6%8C%81%E4%B9%85%E5%8C%96">八、持久化</a><ul><li><a href="#rdb-%E6%8C%81%E4%B9%85%E5%8C%96">RDB 持久化</a></li><li><a href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96">AOF 持久化</a></li></ul></li><li><a href="#%E4%B9%9D%E4%BA%8B%E5%8A%A1">九、事务</a></li><li><a href="#%E5%8D%81%E4%BA%8B%E4%BB%B6">十、事件</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6">文件事件</a></li><li><a href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6">时间事件</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C">事件的调度与执行</a></li></ul></li><li><a href="#%E5%8D%81%E4%B8%80%E5%A4%8D%E5%88%B6">十一、复制</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">连接过程</a></li><li><a href="#%E4%B8%BB%E4%BB%8E%E9%93%BE">主从链</a></li></ul></li><li><a href="#%E5%8D%81%E4%BA%8Csentinel">十二、Sentinel</a></li><li><a href="#%E5%8D%81%E4%B8%89%E5%88%86%E7%89%87">十三、分片</a></li><li><a href="#%E5%8D%81%E5%9B%9B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BA%E5%9D%9B%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90">十四、一个简单的论坛系统分析</a><ul><li><a href="#%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF">文章信息</a></li><li><a href="#%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD">点赞功能</a></li><li><a href="#%E5%AF%B9%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">对文章进行排序</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><!-- GFM-TOC --><h2 id="一、概述">一、概述</h2><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h2 id="二、数据类型">二、数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">可以存储的值</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">STRING</td><td style="text-align:center">字符串、整数或者浮点数</td><td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt; 对整数和浮点数执行自增或者自减操作</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">列表</td><td style="text-align:center">从两端压入或者弹出元素&lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">无序集合</td><td style="text-align:center">添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">包含键值对的无序散列表</td><td style="text-align:center">添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">有序集合</td><td style="text-align:center">添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p></blockquote><h3 id="STRING">STRING</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"/> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="LIST">LIST</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"/> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure><h3 id="SET">SET</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"/> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure><h3 id="HASH">HASH</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"/> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;sub-key2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) &quot;sub-key1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br></pre></td></tr></table></figure><h3 id="ZSET">ZSET</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"/> </div><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure><h2 id="三、数据结构">三、数据结构</h2><h3 id="字典">字典</h3><p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃表">跳跃表</h3><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"/> </div><br><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" width="600px"/> </div><br><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h2 id="四、使用场景">四、使用场景</h2><h3 id="计数器">计数器</h3><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h3 id="缓存">缓存</h3><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h3 id="查找表">查找表</h3><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h3 id="消息队列">消息队列</h3><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h3 id="会话缓存">会话缓存</h3><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h3 id="分布式锁实现">分布式锁实现</h3><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h3 id="其它">其它</h3><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h2 id="五、Redis-与-Memcached">五、Redis 与 Memcached</h2><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h3 id="数据类型">数据类型</h3><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p><h3 id="数据持久化">数据持久化</h3><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h3 id="分布式">分布式</h3><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h3 id="内存管理机制">内存管理机制</h3><ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li></ul><h2 id="六、键的过期时间">六、键的过期时间</h2><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h2 id="七、数据淘汰策略">七、数据淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th style="text-align:center">策略</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">volatile-lru</td><td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">volatile-ttl</td><td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td style="text-align:center">volatile-random</td><td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td style="text-align:center">allkeys-lru</td><td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">allkeys-random</td><td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td style="text-align:center">noeviction</td><td style="text-align:center">禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h2 id="八、持久化">八、持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h3 id="RDB-持久化">RDB 持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h3 id="AOF-持久化">AOF 持久化</h3><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">同步频率</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">每个写命令都同步</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒同步一次</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h2 id="九、事务">九、事务</h2><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h2 id="十、事件">十、事件</h2><p>Redis 服务器是一个事件驱动程序。</p><h3 id="文件事件">文件事件</h3><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" width=""/> </div><br><h3 id="时间事件">时间事件</h3><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h3 id="事件的调度与执行">事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span>():</span></span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" width="350"/> </div><br><h2 id="十一、复制">十一、复制</h2><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h3 id="连接过程">连接过程</h3><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li></ol><h3 id="主从链">主从链</h3><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"/> </div><br><h2 id="十二、Sentinel">十二、Sentinel</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h2 id="十三、分片">十三、分片</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h2 id="十四、一个简单的论坛系统分析">十四、一个简单的论坛系统分析</h2><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h3 id="文章信息">文章信息</h3><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"/> </div><br><h3 id="点赞功能">点赞功能</h3><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"/> </div><br><h3 id="对文章进行排序">对文章进行排序</h3><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"/> </div><br><h2 id="参考资料-3">参考资料</h2><ul><li>Carlson J L. Redis in Action[J]. <a href="http://Media.johnwiley.com.au">Media.johnwiley.com.au</a>, 2013.</li><li><a href="http://redisbook.com/index.html">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href="https://redislabs.com/ebook/foreword/">REDIS IN ACTION</a></li><li><a href="http://ticki.github.io/blog/skip-lists-done-right/">Skip Lists: Done Right</a></li><li><a href="http://www.cnblogs.com/loveincode/p/7411911.html">论述 Redis 和 Memcached 的差异</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis-guide">Redis 3.0 中文版- 分片</a></li><li><a href="http://www.scienjus.com/redis-use-case/">Redis 应用场景</a></li><li><a href="https://redis.io/topics/lru-cache">Using Redis as an LRU cache</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/21/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/21/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>SQL教程</h1><h2 id="关系数据库概述">关系数据库概述</h2><h3 id="数据模型">数据模型</h3><p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul><p>层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        ┌─────┐</span><br><span class="line">        │     │</span><br><span class="line">        └─────┘</span><br><span class="line">           │</span><br><span class="line">   ┌───────┴───────┐</span><br><span class="line">   │               │</span><br><span class="line">┌─────┐         ┌─────┐</span><br><span class="line">│     │         │     │</span><br><span class="line">└─────┘         └─────┘</span><br><span class="line">   │               │</span><br></pre></td></tr></table></figure><p>┌───┴───┐       ┌───┴───┐<br>│       │       │       │<br>┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐<br>│     │ │     │ │     │ │     │<br>└─────┘ └─────┘ └─────┘ └─────┘<br>网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────┐      ┌─────┐</span><br></pre></td></tr></table></figure><p>┌─│     │──────│     │──┐<br>│ └─────┘      └─────┘  │<br>│    │            │     │<br>│    └──────┬─────┘     │<br>│           │           │<br>┌─────┐     ┌─────┐     ┌─────┐<br>│     │─────│     │─────│     │<br>└─────┘     └─────┘     └─────┘<br>│           │           │<br>│     ┌─────┴─────┐     │<br>│     │           │     │<br>│  ┌─────┐     ┌─────┐  │<br>└──│     │─────│     │──┘<br>└─────┘     └─────┘<br>关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表：</p><p>┌─────┬─────┬─────┬─────┬─────┐<br>│     │     │     │     │     │<br>├─────┼─────┼─────┼─────┼─────┤<br>│     │     │     │     │     │<br>├─────┼─────┼─────┼─────┼─────┤<br>│     │     │     │     │     │<br>├─────┼─────┼─────┼─────┼─────┤<br>│     │     │     │     │     │<br>└─────┴─────┴─────┴─────┴─────┘<br>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。</p><p>为什么关系数据库获得了最广泛的应用？</p><p>因为相比层次模型和网状模型，关系模型理解和使用起来最简单。</p><p>关系数据库的关系模型是基于数学理论建立的。我们把域（Domain）定义为一组具有相同数据类型的值的集合，给定一组域D1,D2,…,Dn，它们的笛卡尔集定义为D1×D2×……×Dn={(d1,d2,…,dn)|di∈Di,i=1,2,…,n}， 而D1×D2×……×Dn的子集叫作在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，这里的R表示…(……算了，根本讲不明白，大家也不用理解。</p><p>基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>其中，班级ID对应着另一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p><h3 id="数据类型-2">数据类型</h3><p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><p>上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，<code>REAL</code>又可以写成 <code>FLOAT</code>(24)。还有一些不常用的数据类型，例如，<code>TINYINT</code>（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如 <code>JSON</code>。</p><p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p><h3 id="主流关系数据库">主流关系数据库</h3><p>目前，主流的关系数据库主要分为以下几类：</p><ol><li>商用数据库，例如：Oracle，SQL Server，DB2等；</li><li>开源数据库，例如：MySQL，PostgreSQL等；</li><li>桌面数据库，以微软Access为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。</li></ol><h3 id="SQL">SQL</h3><p>什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><p>虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为 <code>PL/SQL</code>，Microsoft把自己扩展的SQL称为 <code>T-SQL</code>。</p><p>现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><p><strong>DDL：Data Definition Language</strong><br>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p><p><strong>DML：Data Manipulation Language</strong><br>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p><p><strong>DQL：Data Query Language</strong><br>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p><h3 id="语法特点">语法特点</h3><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p><p>所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p><h2 id="MySQL概述">MySQL概述</h2><p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p><p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。</p><p>因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本：</p><p><strong>MariaDB</strong><br>由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。</p><p><strong>Aurora</strong><br>由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。</p><p><strong>PolarDB</strong><br>由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。</p><p>而MySQL官方版本又分了好几个版本：</p><ul><li>Community Edition：社区开源版本，免费；</li><li>Standard Edition：标准版；</li><li>Enterprise Edition：企业版；</li><li>Cluster Carrier Grade Edition：集群版。</li></ul><p>以上版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。</p><p>所以使用MySQL就带来了一个巨大的好处：可以在自己的电脑上安装免费的Community Edition版本，进行学习、开发、测试，部署的时候，可以选择付费的高级版本，或者云服务商提供的兼容版本，而不需要对应用程序本身做改动。</p><h3 id="运行MySQL">运行MySQL</h3><p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过 <code>mysql</code>这个命令行程序来连接MySQL服务器。</p><p>在命令提示符下输入 <code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为 <code>mysql&gt;</code>。</p><p>输入 <code>exit</code>退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p><h2 id="关系模型">关系模型</h2><p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p><p>表的每一行称为 <code>记录（Record）</code>，记录是一个逻辑意义上的数据。</p><p>表的每一列称为 <code>字段（Column）</code>，同一个表的每一行记录都拥有相同的若干字段。</p><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为 <code>NULL</code>。注意 <code>NULL</code>表示字段数据不存在。一个整型字段如果为 <code>NULL</code>不表示它的值为0，同样的，一个字符串型字段为 <code>NULL</code>也不表示它的值为空串 <code>''</code>。</p><div class="note info simple"><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p></div><p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p><p>例如，一个班级表：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>王老师</td></tr><tr><td>202</td><td>二年级二班</td><td>李老师</td></tr></tbody></table><p>每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”：</p><table><thead><tr><th>ID</th><th>姓名</th><th>班级ID</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>201</td><td>M</td><td>9</td></tr><tr><td>2</td><td>小红</td><td>202</td><td>F</td><td>8</td></tr><tr><td>3</td><td>小军</td><td>202</td><td>M</td><td>8</td></tr><tr><td>4</td><td>小白</td><td>201</td><td>F</td><td>9</td></tr></tbody></table><p>反过来，如果我们先在学生表中定位了一行记录，例如 <code>ID=1</code>的小明，要确定他的班级，只需要根据他的“班级ID”对应的值201找到班级表中 <code>ID=201</code>的记录，即二年级一班。所以，学生表和班级表是“多对一”的关系。</p><p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p><table><thead><tr><th>ID</th><th>名称</th><th>年龄</th></tr></thead><tbody><tr><td>A1</td><td>王老师</td><td>26</td></tr><tr><td>A2</td><td>张老师</td><td>39</td></tr><tr><td>A3</td><td>李老师</td><td>32</td></tr><tr><td>A4</td><td>赵老师</td><td>27</td></tr></tbody></table><p>班级表只存储教师ID：</p><table><thead><tr><th>ID</th><th>名称</th><th>班主任ID</th></tr></thead><tbody><tr><td>201</td><td>二年级一班</td><td>A1</td></tr><tr><td>202</td><td>二年级二班</td><td>A3</td></tr></tbody></table><p>这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。</p><p>在关系数据库中，关系是通过<mark class="hl-label default">主键</mark> 和<mark class="hl-label default">外键</mark> 来维护的。我们在后面会分别深入讲解。</p><h3 id="主键">主键</h3><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr></tbody></table><p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<mark class="hl-label default">主键</mark> 。</p><p>例如，假设我们把 <code>name</code>字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为 <code>id</code>。常见的可作为id字段的类型有：</p><ul><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ul><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在 <code>students</code>表中定义的主键也是 <code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><div class="note info simple"><p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p></div><h4 id="联合主键">联合主键</h4><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p><table><thead><tr><th>id_num</th><th>id_type</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>…</td></tr><tr><td>2</td><td>A</td><td>…</td></tr><tr><td>2</td><td>B</td><td>…</td></tr></tbody></table><p>如果我们把上述表的 <code>id_num</code>和 <code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p><p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p><h3 id="外键">外键</h3><p>当我们用主键唯一标识记录时，我们就可以在 <code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>小红</td><td>…</td></tr></tbody></table><p>我们还可以在 <code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>…</td></tr><tr><td>2</td><td>二班</td><td>…</td></tr></tbody></table><p>但是我们如何确定 <code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个 <code>classes</code>的记录可以对应多个 <code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在students表中加入一列 <code>class_id</code>，让它的值与 <code>classes</code>表的某条记录相对应：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>…</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>…</td></tr></tbody></table><p>这样，我们就可以根据 <code>class_id</code>这个列直接定位出一个 <code>students</code>表的记录应该对应到classes的哪条记录。</p><p>例如：</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在 <code>students</code>表中，通过 <code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<mark class="hl-label default">外键</mark> 。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称 <code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了 <code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到 <code>classes</code>表的 <code>id</code>列（即 <code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果 <code>classes</code>表不存在 <code>id=99</code>的记录，<code>students</code>表就无法插入 <code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过 <code>ALTER TABLE</code>实现的：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过 <code>DROP COLUMN ...</code>实现的。</p><h4 id="多对多">多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table><p>中间表 <code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table><p>通过中间表 <code>teacher_class</code>可知 <code>teachers</code>到 <code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知 <code>classes</code>到 <code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h4 id="一对一">一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表 <code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给 <code>students</code>表增加一个 <code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是 <code>contacts</code>表一对一对应 <code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表 <code>user_info</code>和用户详细信息表 <code>user_profiles</code>，大部分时候，只需要查询 <code>user_info</code>表，并不需要查询 <code>user_profiles</code>表，这样就提高了查询速度。</p><h3 id="索引">索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于 <code>students</code>表：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr><tr><td>如果要经常根据 <code>score</code>列进行查询，就可以对 <code>score</code>列创建索引：</td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用 <code>ADD INDEX idx_score (score)</code>就创建了一个名称为 <code>idx_score</code>，使用列 <code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如 <code>gender</code>列，大约一半的记录值是 <code>M</code>，另一半是 <code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h4 id="唯一索引">唯一索引</h4><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设 <code>students</code>表的 <code>name</code>不能重复：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过 <code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h2 id="基础语法">基础语法</h2><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 注释</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><p>数据库创建与使用：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  # <span class="type">int</span> 类型，不为空，自增</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  # <span class="type">int</span> 类型，不可为空，默认值为 <span class="number">1</span>，不为空</span><br><span class="line">  col1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  # 变长字符串类型，最长为 <span class="number">45</span> 个字符，可以为空</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  # 日期类型，可为空</span><br><span class="line">  col3 <span class="type">DATE</span> <span class="keyword">NULL</span>,</span><br><span class="line">  # 设置主键为 id</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`));</span><br></pre></td></tr></table></figure><h3 id="修改表">修改表</h3><p>添加列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="查询数据">查询数据</h2><p><strong>DISTINCT</strong><br>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>LIMIT</strong><br>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="基本查询">基本查询</h3><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><blockquote><p>SELECT * FROM &lt;表名&gt;</p></blockquote><p>假设表名是 <code>students</code>，要查询 <code>students</code>表的所有行，我们用如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>使用 <code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是 <code>students</code>表。</p><p>该SQL将查询出 <code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。</p><p><code>SELECT</code>语句其实并不要求一定要有 <code>FROM</code>子句。我们来试试下面的 <code>SELECT</code>语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>上述查询会直接计算出表达式的结果。虽然 <code>SELECT</code>可以用作计算，但它并不是SQL的强项。但是，不带 <code>FROM</code>子句的 <code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条 <code>SELECT 1;</code>来测试数据库连接。</p><h3 id="条件查询">条件查询</h3><p>使用 <code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p><p>SELECT语句可以通过 <code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成 <code>WHERE</code>条件就是 <code>SELECT * FROM students WHERE score &gt;= 80。</code></p><p>其中，<code>WHERE</code>关键字后面的 <code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录</p><p>因此，条件查询的语法就是：</p><blockquote><p>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</p></blockquote><p>条件表达式可以用 <code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p><ul><li>条件1：根据<code>score</code>列的数据判断：<code>score &gt;= 80</code>；</li><li>条件2：根据<code>gender</code>列的数据判断：<code>gender = 'M'</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li></ul><p>就可以写出 <code>WHERE</code>条件 <code>：score &gt;= 80 AND gender = 'M'</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>第二种条件是 <code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1或者满足条件2。例如，把上述 <code>AND</code>查询的两个条件改为 <code>OR</code>，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">OR</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>很显然 <code>OR</code>条件要比 <code>AND</code>条件宽松，返回的符合条件的记录也更多。</p><p>第三种条件是 <code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：<code>class_id = 2</code>，再加上 <code>NOT</code>：<code>NOT class_id = 2</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="keyword">NOT</span> class_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上述 <code>NOT</code>条件 <code>NOT class_id = 2</code>其实等价于 <code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</p><p>要组合三个或者更多的条件，就需要用小括号 <code>()</code>表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> (score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">OR</span> score <span class="operator">&gt;</span> <span class="number">90</span>) <span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果不加括号，条件运算按照 <code>NOT</code>、<code>AND</code>、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。</p><h3 id="通配符">通配符</h3><table><thead><tr><th>条件</th><th>表达式举例1</th><th>表达式举例2</th><th>说明</th></tr></thead><tbody><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>name LIKE ‘%bc%’</td><td>%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td></tr></tbody></table><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li>% 匹配 &gt;=0 个任意字符；</li><li>_ 匹配 ==1 个任意字符；</li><li><code>[ ]</code>可以匹配集合内的字符，例如 <code>[ab]</code> 将匹配字符 a 或者 b。用脱字符 <code>^</code> 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><p>使用 <code>Like</code> 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;[^AB]%&#x27;</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h3 id="计算字段">计算字段</h3><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <code>AS</code> 来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="operator">*</span> col2 <span class="keyword">AS</span> alias</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><code>CONCAT()</code> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <code>TRIM()</code> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h3 id="投影查询">投影查询</h3><p>使用 <code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用 <code>SELECT 列1, 列2, 列3 FROM ...，</code>让结果集仅包含指定列。这种操作称为投影查询。</p><p>例如，从 <code>students</code>表中返回 <code>id</code>、<code>score</code>和 <code>name</code>这三列：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, score, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p><p>使用 <code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是 <code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下 <code>SELECT</code>语句将列名 <code>score</code>重命名为 <code>points</code>，而 <code>id</code>和 <code>name</code>列名保持不变：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, score points, name <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>投影查询同样可以接 <code>WHERE</code>条件，实现复杂的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用投影查询+WHERE条件：</span></span><br><span class="line"><span class="keyword">SELECT</span> id, score points, name <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="排序">排序</h3><p>我们使用 <code>SELECT</code>查询时，细心的读者可能注意到，查询结果集通常是按照 <code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上 <code>ORDER BY</code>子句。例如按照成绩 <code>从低到高</code>进行排序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score;</span><br></pre></td></tr></table></figure><p>如果要反过来，按照成绩 <code>从高到底</code>排序，我们可以加上 <code>DESC</code>表示“倒序”：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按score从高到低</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用 <code>ORDER BY score DESC, gender</code>表示先按 <code>score</code>列倒序，如果有相同分数的，再按 <code>gender</code>列排序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按score, gender排序:</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender;</span><br></pre></td></tr></table></figure><p>默认的排序规则是 <code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即 <code>ORDER BY score ASC</code>和 <code>ORDER BY score</code>效果一样。</p><p>如果有 <code>WHERE</code>子句，那么 <code>ORDER BY</code>子句要放到 <code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 带WHERE条件的ORDER BY:</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>这样，结果集仅包含符合 <code>WHERE</code>条件的记录，并按照 <code>ORDER BY</code>的设定排序。</p><h3 id="分页查询">分页查询</h3><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>要实现分页功能，实际上就是从结果集中显示第 <code>1~100</code>条记录作为第1页，显示第 <code>101~200</code>条记录作为第2页，以此类推。</p><p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过 <code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按score从高到低</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用 <code>LIMIT 3 OFFSET 0</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询第1页</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上述查询 <code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p><p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把 <code>OFFSET</code>设定为 <code>3</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询第2页</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>类似的，查询第3页的时候，<code>OFFSET</code>应该设定为 <code>6</code>:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询第3页</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>查询第4页的时候，<code>OFFSET</code>应该设定为 <code>9</code>:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询第4页</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。<code>LIMIT 3</code>表示的意思是“最多3条记录”。</p><p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量 <code>pageSize</code>（这里是3），然后根据当前页的索引 <code>pageIndex</code>（从1开始），确定 <code>LIMIT</code>和 <code>OFFSET</code>应该设定的值：</p><ul><li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li><li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li></ul><p>这样就能正确查询出第N页的记录集。</p><p>如果原本记录集一共就10条记录，但我们把 <code>OFFSET</code>设置为20，会得到什么结果呢？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- OFFSET设定为20</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p><h4 id="注意">注意</h4><p><code>OFFSET</code>是可选的，如果只写 <code>LIMIT 15</code>，那么相当于 <code>LIMIT 15 OFFSET 0</code>。</p><p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成 <code>LIMIT 30, 15</code>。</p><p>使用 <code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着 <code>N</code>越来越大，查询效率也会越来越低。</p><h3 id="聚合查询">聚合查询</h3><p>如果我们要统计一张表的数据量，例如，想查询 <code>students</code>表一共有多少条记录，难道必须用 <code>SELECT * FROM students</code>查出来然后再数一数有多少行吗？</p><p>这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p>仍然以查询 <code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的 <code>COUNT()</code>函数查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用聚合查询:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是 <code>COUNT(*)</code>。</p><p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用聚合查询并设置结果集的列名为num:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p><code>COUNT(*)</code>和 <code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用 <code>WHERE</code>条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用聚合查询并设置WHERE条件:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除了 <code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均值，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><p>注意，<code>MAX()</code>和 <code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和 <code>MIN()</code>会返回 <code>排序最后</code>和 <code>排序最前</code>的字符。</p><p>要统计男生的平均成绩，我们用下面的聚合查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用聚合查询计算男生平均成绩:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(score) average <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>要特别注意：如果聚合查询的 <code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回 <code>0</code>，而 <code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和 <code>MIN()</code>会返回 <code>NULL</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- WHERE条件gender = &#x27;X&#x27;匹配不到任何行:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(score) average <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure><p>每页3条记录，如何通过聚合查询获得总页数？</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="number">3</span>) <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><h4 id="分组">分组</h4><p>如果我们要统计一班的学生数量，我们知道，可以用 <code>SELECT COUNT(*) num FROM students WHERE class_id = 1</code>;。如果要继续统计二班、三班的学生数量，难道必须不断修改 <code>WHERE</code>条件来执行 <code>SELECT</code>语句吗？</p><p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>执行这个查询，<code>COUNT()</code>的结果不再是一个，而是3个，这是因为，<code>GROUP BY</code>子句指定了按 <code>class_id</code>分组，因此，执行该 <code>SELECT</code>语句时，会把 <code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把 <code>class_id</code>列也放入结果集中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按class_id分组:</span></span><br><span class="line"><span class="keyword">SELECT</span> class_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把 <code>name</code>放入结果集：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按class_id分组:</span></span><br><span class="line"><span class="keyword">SELECT</span> name, class_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有 <code>class_id</code>都相同，<code>name</code>是不同的，SQL引擎不能把多个 <code>name</code>的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。</p><div class="note warning sample simple"><p>注意：AlaSQL并没有严格执行SQL标准，上述SQL在浏览器可以正常执行，但是在MySQL、Oracle等环境下将报错，请自行在MySQL中测试。</p></div><p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按class_id, gender分组:</span></span><br><span class="line"><span class="keyword">SELECT</span> class_id, gender, <span class="built_in">COUNT</span>(<span class="operator">*</span>) num <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id, gender;</span><br></pre></td></tr></table></figure><p>上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。</p><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h3 id="嵌套查询">嵌套查询</h3><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><h4 id="in操作符">in操作符</h4><p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p><p>SQL IN 语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...)</span><br></pre></td></tr></table></figure><p>原始的表 (在实例中使用：)<br>Persons 表:</p><table><thead><tr><th>Id</th><th>LastName</th><th>FirstName</th><th>Address</th><th>City</th></tr></thead><tbody><tr><td>1</td><td>Adams</td><td>John</td><td>Oxford Street</td><td>London</td></tr><tr><td>2</td><td>Bush</td><td>George</td><td>Fifth Avenue</td><td>New York</td></tr><tr><td>3</td><td>Carter</td><td>Thomas</td><td>Changan Street</td><td>Beijing</td></tr></tbody></table><p>IN 操作符实例</p><p>现在，我们希望从上表中选取姓氏为 Adams 和 Carter 的人：</p><p>我们可以使用下面的 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> LastName <span class="keyword">IN</span> (<span class="string">&#x27;Adams&#x27;</span>,<span class="string">&#x27;Carter&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果集：</p><table><thead><tr><th>Id</th><th>LastName</th><th>FirstName</th><th>Address</th><th>City</th></tr></thead><tbody><tr><td>1</td><td>Adams</td><td>John</td><td>Oxford Street</td><td>London</td></tr><tr><td>3</td><td>Carter</td><td>Thomas</td><td>Changan Street</td><td>Beijing</td></tr></tbody></table><h4 id="带有比较运算符的子查询">带有比较运算符的子查询</h4><p>带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用 &gt;、&lt;、=、&gt;=、&lt;=、!=、或&lt;&gt;等比较运算符。</p><p>找出每个学生超过他自己选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno</span><br><span class="line"><span class="keyword">FROM</span> SC X</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line">               <span class="keyword">FROM</span> SC y</span><br><span class="line">               <span class="keyword">WHERE</span> y.Sno<span class="operator">=</span>x.Sno);</span><br></pre></td></tr></table></figure><h4 id="带有ANY（SOME）或ALL谓词的子查询">带有ANY（SOME）或ALL谓词的子查询</h4><p>子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或ALL谓词修饰符。而使用ANY或ALL谓词时则必须同时使用比较运算符。其语义如下：</p><p>|<code>&gt;ANY</code>|大于子查询结果中的某个值|<br>|<code>&gt;ALL</code>|大于子查询结果中的所有值|<br>|<code>&lt;ANY</code>|小于子查询结果中的某个值|<br>|<code>&lt;ALL</code>|小于子查询结果中的所有值|<br>|<code>&gt;=ANY</code>|大于等于子查询结果中的某个值|<br>|<code>&gt;=ALL</code>|大于等于子查询结果中的所有值|<br>|<code>&lt;=ALL</code>|小于等于子查询结果中的所有值|<br>|<code>&lt;=ANY</code>|大于等于子查询结果中的某个值|<br>|<code>=ANY</code>|等于子查询结果中的某个值|<br>|<code>=ALL</code>|等于子查询结果中的所有值（通常没有实际意义）|<br>|<code>!=（或&lt;&gt;）ANY</code>|不等于子查询结果中的某个值|<br>|<code>!=（或&lt;&gt;）ALL</code>|不等于子查询结果中的任何一个值|</p><p>查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;</span><span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                <span class="keyword">FROM</span> Student</span><br><span class="line">                <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;</span><span class="keyword">ALL</span></span><br><span class="line">          (<span class="keyword">SELECT</span> Sage</span><br><span class="line">           <span class="keyword">FROM</span> Student</span><br><span class="line">           <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><p>提示：本查询同样可以用聚集函数实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Sage)</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span><span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在此把ANY、ALL与聚集函数的对应关系表示如下</p><p><img src="https://images2017.cnblogs.com/blog/922928/201801/922928-20180106224147987-155828251.png" alt=""></p><h4 id="带有-EXISTS-谓词的子查询">带有 EXISTS 谓词的子查询</h4><p>带有EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。</p><p>查询所有选修了1号课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用存在量词EXISTS后，若内层查询结果为空，则外层的WHERE子句返回真值，否则返回假值。</p><p>查询没有选修1号课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC</span><br><span class="line">     <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>查询选修了全部课程的学生姓名</p><p>由于没有全称量词，可将题目的意思转换成等价的用存在量词的形式：查询这样的学生，没有一门课程是他不选修的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> Course</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">         <span class="keyword">FROM</span> SC</span><br><span class="line">         <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno</span><br><span class="line">            <span class="keyword">AND</span> Cno<span class="operator">=</span>Course.Cno));</span><br></pre></td></tr></table></figure><p>查询至少选修了学生201215122选修的全部课程的学生号码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">FROM</span> SC SCY</span><br><span class="line">     <span class="keyword">WHERE</span> SCY.Sno<span class="operator">=</span><span class="string">&#x27;201215122&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">        <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">         <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">         <span class="keyword">WHERE</span> SCZ.Sno<span class="operator">=</span>SCX.Sno <span class="keyword">AND</span></span><br><span class="line">         SCZ.Cno<span class="operator">=</span>SCY.Cno));</span><br></pre></td></tr></table></figure><h4 id="子查询">子查询</h4><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h3 id="多表查询">多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p><p>例如，同时从 <code>students</code>表和 <code>classes</code>表的“乘积”，即查询数据，可以这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- FROM students, classes:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></table></figure><p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是 <code>students</code>表和 <code>classes</code>表的“乘积”，即 <code>students</code>表的每一行与 <code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是 <code>students</code>表和 <code>classes</code>表的列数之和，行数是 <code>students</code>表和 <code>classes</code>表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><p>你可能还注意到了，上述查询的结果集有两列 <code>id</code>和两列 <code>name</code>，两列id是因为其中一列是 <code>students</code>表的 <code>id</code>，而另一列是 <code>classes</code>表的 <code>id</code>，但是在结果集中，不好区分。两列 <code>name</code>同理</p><p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的 <code>id</code>和 <code>name</code>列起别名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- set alias:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line"><span class="keyword">FROM</span> students, classes;</span><br></pre></td></tr></table></figure><p>注意，多表查询时，要使用 <code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用 <code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- set table alias:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br></pre></td></tr></table></figure><p>注意到 <code>FROM</code>子句给表设置别名的语法是 <code>FROM &lt;表名1&gt; &lt;别名1&gt;</code>, <code>&lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名 <code>s</code>和 <code>c</code>分别表示 <code>students</code>表和 <code>classes</code>表。</p><p>多表查询也是可以添加 <code>WHERE</code>条件的，我们来试试：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- set where clause:</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c</span><br><span class="line"><span class="keyword">WHERE</span> s.gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span> c.id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个查询的结果集每行记录都满足条件 <code>s.gender = 'M'</code>和 <code>c.id = 1</code>。添加WHERE条件后结果集的数量大大减少了。</p><h3 id="连接查询">连接查询</h3><p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>例如，我们想要选出 <code>students</code>表的所有学生信息，可以用一条简单的SELECT语句完成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 选出所有学生</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, s.gender, s.score <span class="keyword">FROM</span> students s;</span><br></pre></td></tr></table></figure><p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有 <code>class_id</code>列，缺少对应班级的 <code>name</code>列。</p><p>现在问题来了，存放班级名称的 <code>name</code>列存储在 <code>classes</code>表中，只有根据 <code>students</code>表的 <code>class_id</code>，找到 <code>classes</code>表对应的行，再取出 <code>name</code>列，就可以获得班级名称。</p><p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——<code>INNER JOIN</code>来实现：</p><h4 id="内连接">内连接</h4><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 选出所有学生，同时返回班级名称</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p>注意 <code>INNER JOIN</code>查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上WHERE子句、ORDER BY等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。</p><p>那什么是 <code>内连接（INNER JOIN）</code>呢？先别着急，有 <code>内连接（INNER JOIN）</code>就有 <code>外连接（OUTER JOIN）</code>。我们把内连接查询改成外连接查询，看看效果：</p><h4 id="外连接">外连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用OUTER JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p>执行上述 <code>RIGHT OUTER JOIN</code>可以看到，和 <code>INNER JOIN</code>相比，<code>RIGHT OUTER JOIN</code>多了一行，多出来的一行是“四班”，但是，学生相关的列如 <code>name</code>、<code>gender</code>、<code>score</code>都为 <code>NULL</code>。</p><p>这也容易理解，因为根据 <code>ON</code>条件 <code>s.class_id = c.id</code>，<code>classes</code>表的 <code>id=4</code>的行正是“四班”，但是，<code>students</code>表中并不存在 <code>class_id=4</code>的行。</p><p>有 <code>RIGHT OUTER JOIN</code>，就有 <code>LEFT OUTER JOIN</code>，以及 <code>FULL OUTER JOIN</code>。它们的区别是：</p><p><code>INNER JOIN</code>只返回同时存在于两张表的行数据，由于 <code>students</code>表的 <code>class_id</code>包含 <code>1</code>，<code>2</code>，<code>3</code>，<code>classes</code>表的id包含 <code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，所以，<code>INNER JOIN</code>根据条件 <code>s.class_id = c.id</code>返回的结果集仅包含 <code>1，2，3</code>。</p><p><code>RIGHT OUTER JOIN</code>返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以 <code>NULL</code>填充剩下的字段。</p><p><code>LEFT OUTER JOIN</code>则返回左表都存在的行。如果我们给 <code>students</code>表增加一行，并添加 <code>class_id=5</code>，由于 <code>classes</code>表并不存在 <code>id=5</code>的行，所以，<code>LEFT OUTER JOIN</code>的结果会增加一行，对应的 <code>class_name</code>是 <code>NULL</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先增加一列class_id=5:</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, name, gender, score) <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">&#x27;新生&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">88</span>);</span><br><span class="line"><span class="comment">-- 使用LEFT OUTER JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p>最后，我们使用 <code>FULL OUTER JOIN</code>，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为 <code>NULL</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用FULL OUTER JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。</p><p>假设查询语句是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tableA ??? <span class="keyword">JOIN</span> tableB <span class="keyword">ON</span> tableA.column1 <span class="operator">=</span> tableB.column2;</span><br></pre></td></tr></table></figure><p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246892164662976/l" alt="inner-join"></p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893588481376/l" alt="left-outer-join"></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893609222688/l" alt="right-outer-join"></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1246893632359424/l" alt="full-outer-join"></p><h4 id="自连接">自连接</h4><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jim&quot;);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br></pre></td></tr></table></figure><h4 id="自然连接">自然连接</h4><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure><h3 id="组合查询">组合查询</h3><p>使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="修改数据">修改数据</h2><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了 <code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h3 id="INSERT">INSERT</h3><p>当我们需要向数据库表中插入一条新记录时，就必须使用 <code>INSERT</code>语句。</p><p><code>INSERT</code>语句的基本语法是：</p><blockquote><p>INSERT INTO &lt;表名&gt; (字段1, 字段2, …) VALUES (值1, 值2, …);</p></blockquote><p>例如，我们向 <code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在 <code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加一条新记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;大牛&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>注意到我们并没有列出 <code>id</code>字段，也没有列出 <code>id</code>字段对应的值，这是因为 <code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在 <code>INSERT</code>语句中也可以不出现。</p><p>要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写 <code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的 <code>VALUES</code>就得变成 <code>(80, 'M', '大牛', 2)</code>。</p><p>还可以一次性添加多条记录，只需要在 <code>VALUES</code>子句中指定多个记录值，每个记录是由 <code>(...)</code>包含的一组值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一次性添加多条新记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, name, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">&#x27;二宝&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h3 id="UPDATE">UPDATE</h3><p>如果要更新数据库表中的记录，我们就必须使用 <code>UPDATE</code>语句。</p><p><code>UPDATE</code>语句的基本语法是：</p><blockquote><p>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, … WHERE …;</p></blockquote><p>例如，我们想更新 <code>students</code>表 <code>id=1</code>的记录的 <code>name</code>和 <code>score</code>这两个字段，先写出 <code>UPDATE students SET name='大牛', score=66</code>，然后在WHERE子句中写出需要更新的行的筛选条件 <code>id=1</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新id=1的记录</span></span><br><span class="line">UPDATE students <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;大牛&#x27;</span>, score<span class="operator">=</span><span class="number">66</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意到 <code>UPDATE</code>语句的 <code>WHERE</code>条件和 <code>SELECT</code>语句的 <code>WHERE</code>条件其实是一样的，因此完全可以一次更新多条记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新id=5,6,7的记录</span></span><br><span class="line">UPDATE students <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;小牛&#x27;</span>, score<span class="operator">=</span><span class="number">77</span> <span class="keyword">WHERE</span> id<span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">AND</span> id<span class="operator">&lt;=</span><span class="number">7</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>在 <code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p><p>``sql<br>– 更新score&lt;80的记录<br>UPDATE students SET score=score+10 WHERE score&lt;80;<br>– 查询并观察结果:<br>SELECT * FROM students;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中，`SET score=score+10`就是给当前行的`score`字段的值加上了`10`。</span><br><span class="line"></span><br><span class="line">如果`WHERE`条件没有匹配到任何记录，`UPDATE`语句不会报错，也不会有任何记录被更新。例如：</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">-- 更新id=999的记录</span><br><span class="line">UPDATE students SET score=100 WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，<code>UPDATE</code>语句可以没有 <code>WHERE</code>条件，例如：</p><blockquote><p>UPDATE students SET score=60;</p></blockquote><p>这时，整个表的所有记录都会被更新。所以，在执行 <code>UPDATE</code>语句时要非常小心，最好先用 <code>SELECT</code>语句来测试 <code>WHERE</code>条件是否筛选出了期望的记录集，然后再用 <code>UPDATE</code>更新。</p><h4 id="MySQL">MySQL</h4><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及 <code>WHERE</code>条件匹配的行数。</p><p>例如，更新 <code>id=1</code>的记录时：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> UPDATE students <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;大宝&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>MySQL会返回1，可以从打印的结果 <code>Rows matched: 1 Changed: 1</code>看到。</p><p>当更新 <code>id=999</code>的记录时：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> UPDATE students <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;大宝&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">999</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>MySQL会返回 <code>0</code>，可以从打印的结果 <code>Rows matched: 0 Changed: 0</code>看到。</p><h3 id="DELETE-2">DELETE</h3><p>如果要删除数据库表中的记录，我们可以使用 <code>DELETE</code>语句</p><p><code>DELETE</code>语句的基本语法是：</p><blockquote><p>DELETE FROM &lt;表名&gt; WHERE …;</p></blockquote><p>例如，我们想删除 <code>students</code>表中 <code>id=1</code>的记录，就需要这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除id=1的记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>注意到 <code>DELETE</code>语句的 <code>WHERE</code>条件也是用来筛选需要删除的行，因此和 <code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除id=5,6,7的记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">AND</span> id<span class="operator">&lt;=</span><span class="number">7</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>如果 <code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除id=999的记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">999</span>;</span><br><span class="line"><span class="comment">-- 查询并观察结果:</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，和 <code>UPDATE</code>类似，不带 <code>WHERE</code>条件的 <code>DELETE</code>语句会删除整个表的数据：</p><blockquote><p>DELETE FROM students;</p></blockquote><p>这时，整个表的所有记录都会被删除。所以，在执行 <code>DELETE</code>语句时也要非常小心，最好先用 <code>SELECT</code>语句来测试 <code>WHERE</code>条件是否筛选出了期望的记录集，然后再用 <code>DELETE</code>删除。</p><p>TRUNCATE TABLE 可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 <code>WHERE</code> 子句，不然会把整张表的数据都破坏。可以先用 <code>SELECT</code>语句进行测试，防止错误删除。</p><h4 id="MySQL-2">MySQL</h4><p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及 <code>WHERE</code>条件匹配的行数。</p><p>例如，分别执行删除 <code>id=1</code>和 <code>id=999</code>的记录：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">999</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h2 id="其它操作">其它操作</h2><h3 id="视图">视图</h3><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(col1, col2) <span class="keyword">AS</span> concat_col, col3<span class="operator">*</span>col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 <span class="operator">=</span> val;</span><br></pre></td></tr></table></figure><h3 id="存储过程">存储过程</h3><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="type">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="type">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y<span class="operator">*</span>y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(<span class="variable">@ret</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ret</span>;</span><br></pre></td></tr></table></figure><h3 id="游标">游标</h3><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="type">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> 这个条件出现时，会执行 <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">open</span> mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            <span class="keyword">fetch</span> mycursor <span class="keyword">into</span> ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">close</span> mycursor;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h3 id="触发器">触发器</h3><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h3 id="事务管理">事务管理</h3><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h3 id="字符集">字符集</h3><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(col <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h3 id="权限管理">权限管理</h3><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><blockquote><p>CREATE USER myuser IDENTIFIED BY ‘mypassword’;</p></blockquote><p><strong>修改账户名</strong></p><blockquote><p>RENAME USER myuser TO newuser;</p></blockquote><p><strong>删除账户</strong></p><blockquote><p>DROP USER myuser;</p></blockquote><p><strong>查看权限</strong></p><blockquote><p>SHOW GRANTS FOR myuser;</p></blockquote><p><strong>授予权限</strong></p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><blockquote><p>GRANT SELECT, INSERT ON mydatabase.* TO myuser;</p></blockquote><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><blockquote><p>REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</p></blockquote><p><strong>更改密码</strong></p><p>必须使用 Password() 函数进行加密。</p><blockquote><p>SET PASSWROD FOR myuser = Password(‘new_password’);</p></blockquote><h2 id="MySQL-3">MySQL</h2><p>安装完MySQL后，除了 <code>MySQL Server</code>，即真正的MySQL服务器外，还附赠一个 <code>MySQL Client</code>程序。<code>MySQL Client</code>是一个命令行客户端，可以通过 <code>MySQL Client</code>登录MySQL，然后，输入SQL语句并执行。</p><p>打开命令提示符，输入命令 <code>mysql -u root -p</code>，提示输入口令。填入MySQL的 <code>root</code>口令，如果正确，就连上了 <code>MySQL Server</code>，同时提示符变为 <code>mysql&gt;</code>：</p><p>┌────────────────────────────────────────────────────────┐<br>│Command Prompt                                    - □ x │<br>├────────────────────────────────────────────────────────┤<br>│Microsoft Windows [Version 10.0.0]                      │<br>│© 2015 Microsoft Corporation. All rights reserved.    │<br>│                                                        │<br>│C:&gt; mysql -u root -p                                   │<br>│Enter password: ******                                  │<br>│                                                        │<br>│Server version: 5.7                                     │<br>│Copyright © 2000, 2018, …                           │<br>│Type ‘help;’ or ‘\h’ for help.                          │<br>│                                                        │<br>│mysql&gt;                                                  │<br>│                                                        │<br>└────────────────────────────────────────────────────────┘<br>输入 <code>exit</code>断开与 <code>MySQL Server</code>的连接并返回到命令提示符。</p><div class="note info simple"><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。<br>MySQL Client和MySQL Server的关系如下：</p></div><p>┌──────────────┐  SQL   ┌──────────────┐<br>│ MySQL Client │───────&gt;│ MySQL Server │<br>└──────────────┘  TCP   └──────────────┘<br>在 <code>MySQL Client</code>中输入的SQL语句通过TCP连接发送到 <code>MySQL Server</code>。默认端口号是 <code>3306</code>，即如果发送到本机 <code>MySQL Server</code>，地址就是 <code>127.0.0.1:3306</code>。</p><p>也可以只安装 <code>MySQL Client</code>，然后连接到远程 <code>MySQL Server</code>。假设远程 <code>MySQL Server</code>的IP地址是 <code>10.0.1.99</code>，那么就使用 <code>-h</code>指定IP或域名：</p><blockquote><p>mysql -h 10.0.1.99 -u root -p</p></blockquote><h3 id="实用SQL语句">实用SQL语句</h3><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h4 id="插入或替换">插入或替换</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用 <code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><blockquote><p>REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, ‘小明’, ‘F’, 99);</p></blockquote><p>若 <code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前 <code>id=1</code>的记录将被删除，然后再插入新记录。</p><h4 id="插入或更新">插入或更新</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用 <code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>) <span class="keyword">ON</span> DUPLICATE KEY UPDATE name<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>, gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>, score<span class="operator">=</span><span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>若 <code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前 <code>id=1</code>的记录将被更新，更新的字段由 <code>UPDATE</code>指定。</p><h4 id="插入或忽略">插入或忽略</h4><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用 <code>INSERT IGNORE INTO ...</code>语句：</p><blockquote><p>INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, ‘小明’, ‘F’, 99);</p></blockquote><p>若 <code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h4 id="快照">快照</h4><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合 <code>CREATE TABLE</code>和 <code>SELECT</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students_of_class1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>新创建的表结构和 <code>SELECT</code>使用的表结构完全一致。</p><h4 id="写入查询结果集">写入查询结果集</h4><p>如果查询结果集需要写入到表中，可以结合 <code>INSERT</code>和 <code>SELECT</code>，将 <code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表 <code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> statistics (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    class_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    average <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><blockquote><p>INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</p></blockquote><p>确保 <code>INSERT</code>语句的列和 <code>SELECT</code>语句的列能一一对应，就可以在 <code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="强制使用指定索引">强制使用指定索引</h4><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用 <code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><blockquote><p>SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</p></blockquote><p>指定索引的前提是索引 <code>idx_class_id</code>必须存在。</p><h2 id="事务">事务</h2><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>可见，数据库事务具有 <code>ACID</code>这4个特性：</p><ul><li>A：<code>Atomic</code>，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：<code>Consistent</code>，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100， B账户则必定加上了100；</li><li>I：<code>Isolation</code>，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：<code>Duration</code>，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为 <code>隐式事务</code>。</p><p>要手动把多条SQL语句作为一个事务执行，使用 <code>BEGIN</code>开启一个事务，使用 <code>COMMIT</code>提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>很显然多条SQL语句要想作为一个事务执行，就必须使用 <code>显式事务</code>。</p><p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果 <code>COMMIT</code>语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用 <code>ROLLBACK</code>回滚事务，整个事务会失败：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">UPDATE accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><p><strong>隔离级别</strong></p><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="Read-Uncommitted">Read Uncommitted</h3><p><code>Read Uncommitted</code>是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是 <code>脏读（Dirty Read）</code>。</p><p>我们来看一个例子。</p><p>首先，我们准备好 <code>students</code>表的数据，该表仅一行记录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td>SET TRANSACTIONISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>5</td><td>ROLLBACK;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务A执行完第3步时，它更新了 <code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p><p>随后，事务A在第5步进行了回滚，事务B再次读取 <code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p><p>可见，在 <code>Read Uncommitted</code>隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p><h3 id="Read-Committed">Read Committed</h3><p>在 <code>Read Committed</code>隔离级别下，一个事务可能会遇到 <code>不可重复读（Non Repeatable Read）</code>的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>我们仍然先准备好 <code>students</code>表的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td>SET TRANSACTIONISOLATION LEVEL READ COMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>4</td><td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 1;</td></tr><tr><td>7</td><td></td><td>COMMIT;</td></tr></tbody></table><p>当事务B第一次执行第3步的查询时，得到的结果是 <code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了 <code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p><h3 id="Repeatable-Read">Repeatable Read</h3><p>在 <code>Repeatable Read</code>隔离级别下，一个事务可能会遇到 <code>幻读（Phantom Read）</code>的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p>我们仍然先准备好 <code>students</code>表的数据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th>时刻</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td>SET TRANSACTIONISOLATION LEVEL READ COMMITTED;</td></tr><tr><td>2</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>3</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>4</td><td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>7</td><td></td><td>UPDATE students SET name = ‘Alice’ WHERE id = 99;</td></tr><tr><td>8</td><td></td><td>SELECT * FROM students WHERE id = 99;</td></tr><tr><td>9</td><td></td><td>COMMIT;</td></tr></tbody></table><p>事务B在第3步第一次读取 <code>id=99</code>的记录时，读到的记录为空，说明不存在 <code>id=99</code>的记录。随后，事务A在第4步插入了一条 <code>id=99</code>的记录并提交。事务B在第6步再次读取 <code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取 <code>id=99</code>的记录时，记录出现了。</p><p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p><h3 id="Serializable">Serializable</h3><p><code>Serializable</code>是最严格的隔离级别。在 <code>Serializable</code>隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然 <code>Serializable</code>隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用 <code>Serializable</code>隔离级别。</p><h4 id="默认隔离级别">默认隔离级别</h4><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在 <code>MySQL</code>中，如果使用 <code>InnoDB</code>，默认的隔离级别是 <code>Repeatable Read</code>。</p><h2 id="其他">其他</h2><h3 id="sql中is和-的区别">sql中is和=的区别</h3><p>1.=为比较运算符，同时也是sql中的赋值运算符， 除 text、ntext 或 image 数据类型的表达式外，=可以用于所有其他表达式，更多是一种数值类型上的判断，对于bool类型的判断会有3个结果TRUE、FALSE 和 UNKNOWN，在判断是否为null则会返回UNKNOWN，所以不能用=判断是否为null</p><p><a href="http://2.is">2.is</a> 判断表达式是否为bool类型的结果，以及类型是否为空，在判断是否为null应使用is</p><h3 id="自定义函数">自定义函数</h3><p>自定义函数与存储过程的区别：</p><p>1.输出参数：自定义函数不能拥有输出参数，因为其本身就是输出参数；而存储过程可以包含输出参数。</p><p>2.RETURN语句，自定义函数必须有一条RETURN语句；存储过程不能有RETURN语句</p><p>3.可以直接在SQL语句中调用自定义函数；存储过程需要使用call来调用。</p><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名([参数列表]) <span class="keyword">returns</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sql</span>语句;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fundemo(num <span class="type">INT</span>) <span class="keyword">returns</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> num<span class="operator">+</span><span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> fundemo(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>输出：666</p><p>再来一个demo：定义一个判断网站浏览量等级的函数，&lt;100为C，100到1000为B，大于1000为A</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> rankABC; <span class="comment">-- 存在函数时将函数删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rankABC(num <span class="type">INT</span>) <span class="keyword">returns</span> <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> rank <span class="type">varchar</span>(<span class="number">10</span>); <span class="comment">-- declare关键字定义变量</span></span><br><span class="line"></span><br><span class="line">IF num<span class="operator">&lt;=</span><span class="number">100</span> <span class="keyword">THEN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> rank <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>; <span class="comment">-- set关键字用来给变量赋值</span></span><br><span class="line"></span><br><span class="line">ELSEIF (num<span class="operator">&gt;</span><span class="number">100</span> <span class="keyword">and</span> num<span class="operator">&lt;</span><span class="number">1000</span>) <span class="keyword">THEN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> rank <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> rank <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,rankABC(alexa) <span class="keyword">from</span> websites;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/18734336-62781520c79f6a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1091/format/webp" alt=""></p><h3 id="mybatis中的sql语句">mybatis中的sql语句</h3><h4 id="select-2">select</h4><p>一个select 元素非常简单。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生，根据id --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT ST.STUDENT_ID,  </span><br><span class="line">               ST.STUDENT_NAME,  </span><br><span class="line">               ST.STUDENT_SEX,  </span><br><span class="line">               ST.STUDENT_BIRTHDAY,  </span><br><span class="line">               ST.CLASS_ID  </span><br><span class="line">          FROM STUDENT_TBL ST  </span><br><span class="line">         WHERE ST.STUDENT_ID = #&#123;studentID&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>这条语句就叫做‘getStudent，有一个String参数，并返回一个StudentEntity类型的对象。<br>注意参数的标识是：#{studentID}。#{}占位符对应传入的参数，可以随意写字符串标识符，但最好还是和传入参数对应起来，保持良好的可读性</p><p>占位符 # 和 $ 的区别</p><p><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 都可以替代参数，即占位符</p><p><code>#&#123;&#125;</code> 在SQL语句运行的时候显示的是一个一个的 <code>？ ？ ？</code></p><p>例如针对根据某个ID的一条删除语句，ID号用 <code>#&#123;id&#125;</code> 替代</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteData&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">   delete from Products where ProductID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出的SQL日志如下 ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Preparing: <span class="keyword">delete</span> <span class="keyword">from</span> Products <span class="keyword">where</span> ProductID <span class="operator">=</span> ? </span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="number">2</span>(<span class="type">Integer</span>)</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Updates: <span class="number">1</span></span><br><span class="line">[Products] 已经删除第<span class="number">2</span>条记录！</span><br></pre></td></tr></table></figure><p><code>#&#123; &#125;</code>在处理接受的字段会当做字符串处理，会把传入的参数自动加上引号<code>&quot;&quot;</code>，例如这里如果想要删掉 <code>ID=2</code> 的记录</p><p>当执行函数 deleteData（2）的时候，输出的SQL语句实际上是：</p><p><code>delete from Products where ProductID = &quot;2&quot;</code></p><p>而 <code>$&#123; &#125;</code> 不会自动添加引号<code>&quot;&quot;</code> ，就是简单的字符串拼接，容易引发SQL语句注入的安全隐患，所以一般还是推荐使用 <code>#&#123; &#125;</code>.</p><p>select 语句属性配置细节：</p><table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>resultType</td><td>语句返回值类型的整类名或别名。注意，如果是集合，那么这里填写的是集合的项的整类名或别名，而不是集合本身的类名。（resultType 与resultMap 不能并用)</td><td></td><td></td></tr><tr><td>resultMap</td><td>引用的外部resultMap 名。结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。（resultType 与resultMap 不能并用）</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false true</td><td>false</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>true</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType</td><td>statement，preparedstatement，callablestatement。</td><td></td><td></td></tr><tr><td>预准备语句、可调用语句</td><td>STATEMENT</td><td></td><td></td></tr><tr><td>PREPARED</td><td></td><td></td><td></td></tr><tr><td>CALLABLE</td><td>PREPARED</td><td></td><td></td></tr><tr><td>resultSetType</td><td>forward_only，scroll_sensitive，scroll_insensitive</td><td></td><td></td></tr><tr><td>只转发，滚动敏感，不区分大小写的滚动</td><td>FORWARD_ONLY</td><td></td><td></td></tr><tr><td>SCROLL_SENSITIVE</td><td></td><td></td><td></td></tr><tr><td>SCROLL_INSENSITIVE</td><td>驱动器决定</td><td></td><td></td></tr></tbody></table><h4 id="insert">insert</h4><p>一个简单的insert语句：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 插入学生 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;StudentEntity&quot;</span>&gt;</span>  </span><br><span class="line">        INSERT INTO STUDENT_TBL (STUDENT_ID,  </span><br><span class="line">                                          STUDENT_NAME,  </span><br><span class="line">                                          STUDENT_SEX,  </span><br><span class="line">                                          STUDENT_BIRTHDAY,  </span><br><span class="line">                                          CLASS_ID)  </span><br><span class="line">              VALUES   (#&#123;studentID&#125;,  </span><br><span class="line">                          #&#123;studentName&#125;,  </span><br><span class="line">                          #&#123;studentSex&#125;,  </span><br><span class="line">                          #&#123;studentBirthday&#125;,  </span><br><span class="line">                          #&#123;classEntity.classID&#125;)  </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>insert可以使用数据库支持的自动生成主键策略，设置useGeneratedKeys=”true”，然后把keyProperty 设成对应的列，就搞定了。比如说上面的StudentEntity 使用auto-generated 为id 列生成主键.<br>还可以使用selectKey元素。下面例子，使用mysql数据库nextval(‘student’)为自定义函数，用来生成一个key。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 插入学生 自动主键--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudentAutoKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;StudentEntity&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;studentID&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span>  </span><br><span class="line">            select nextval(&#x27;student&#x27;)  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span>  </span><br><span class="line">        INSERT INTO STUDENT_TBL (STUDENT_ID,  </span><br><span class="line">                                 STUDENT_NAME,  </span><br><span class="line">                                 STUDENT_SEX,  </span><br><span class="line">                                 STUDENT_BIRTHDAY,  </span><br><span class="line">                                 CLASS_ID)  </span><br><span class="line">              VALUES   (#&#123;studentID&#125;,  </span><br><span class="line">                        #&#123;studentName&#125;,  </span><br><span class="line">                        #&#123;studentSex&#125;,  </span><br><span class="line">                        #&#123;studentBirthday&#125;,  </span><br><span class="line">                        #&#123;classEntity.classID&#125;)      </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>insert语句属性配置细节：</p><table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false</td><td>true</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>true</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType, statement，preparedstatement，callablestatement。</td><td></td><td></td><td></td></tr><tr><td>预准备语句、可调用语句</td><td>STATEMENT</td><td></td><td></td></tr><tr><td>PREPARED</td><td></td><td></td><td></td></tr><tr><td>CALLABLE</td><td>PREPARED</td><td></td><td></td></tr><tr><td>useGeneratedKeys</td><td>告诉MyBatis 使用JDBC 的getGeneratedKeys 方法来获取数据库自己生成的主键（MySQL、SQLSERVER 等</td><td></td><td></td></tr><tr><td>关系型数据库会有自动生成的字段）。默认：false</td><td></td><td></td><td></td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>keyProperty</td><td></td><td></td><td></td></tr><tr><td>标识一个将要被MyBatis 设置进getGeneratedKeys 的key 所返回的值，或者为insert 语句使用一个selectKey</td><td></td><td></td><td></td></tr><tr><td>子元素。</td><td></td><td></td><td></td></tr></tbody></table><p>selectKey语句属性配置细节：</p><table><thead><tr><th>属性</th><th>描述</th><th>取值</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey 语句生成结果需要设置的属性。</td><td></td></tr><tr><td>resultType</td><td>生成结果类型，MyBatis 允许使用基本的数据类型，包括String 、int类型。</td><td></td></tr><tr><td>order</td><td>可以设成BEFORE 或者AFTER，如果设为BEFORE，那它会先选择主键，然后设置keyProperty，再执行insert语句；如果设为AFTER，它就先运行insert 语句再运行selectKey 语句，通常是insert 语句中内部调用数据库（像Oracle）内嵌的序列机制。</td><td>BEFORE</td></tr><tr><td>AFTER</td><td></td><td></td></tr><tr><td>statementType</td><td>像上面的那样， MyBatis 支持STATEMENT，PREPARED和CALLABLE 的语句形式， 对应Statement ，PreparedStatement 和CallableStatement 响应</td><td>STATEMENT</td></tr><tr><td>PREPARED</td><td></td><td></td></tr><tr><td>CALLABLE</td><td></td><td></td></tr></tbody></table><h4 id="update、delete">update、delete</h4><p>一个简单的update：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 更新学生信息 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;StudentEntity&quot;</span>&gt;</span>  </span><br><span class="line">        UPDATE STUDENT_TBL  </span><br><span class="line">            SET STUDENT_TBL.STUDENT_NAME = #&#123;studentName&#125;,   </span><br><span class="line">                STUDENT_TBL.STUDENT_SEX = #&#123;studentSex&#125;,  </span><br><span class="line">                STUDENT_TBL.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,  </span><br><span class="line">                STUDENT_TBL.CLASS_ID = #&#123;classEntity.classID&#125;  </span><br><span class="line">         WHERE STUDENT_TBL.STUDENT_ID = #&#123;studentID&#125;;     </span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>一个简单的delete：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 删除学生 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;StudentEntity&quot;</span>&gt;</span>  </span><br><span class="line">        DELETE FROM STUDENT_TBL WHERE STUDENT_ID = #&#123;studentID&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>update、delete语句属性配置细节：</p><table><thead><tr><th>属性</th><th>描述</th><th>取值</th><th>默认</th></tr></thead><tbody><tr><td>id</td><td>在这个模式下唯一的标识符，可被其它语句引用</td><td></td><td></td></tr><tr><td>parameterType</td><td>传给此语句的参数的完整类名或别名</td><td></td><td></td></tr><tr><td>flushCache</td><td>如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false</td><td>true</td><td>false</td></tr><tr><td>useCache</td><td>如果设为true，则语句的结果集将被缓存。select 语句默认设为false</td><td>true</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>true</td><td>false</td></tr><tr><td>timeout</td><td>设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>未设置</td></tr><tr><td>fetchSize</td><td>设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定</td><td>正整数</td><td>驱动器决定</td></tr><tr><td>statementType, statement，preparedstatement，callablestatement。</td><td></td><td></td><td></td></tr><tr><td>预准备语句、可调用语句</td><td>STATEMENT</td><td></td><td></td></tr><tr><td>PREPARED</td><td></td><td></td><td></td></tr><tr><td>CALLABLE</td><td>PREPARED</td><td></td><td></td></tr></tbody></table><h4 id="sql">sql</h4><p>Sql元素用来定义一个可以复用的SQL 语句段，供其它语句调用。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 复用sql语句  查询student表所有字段 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentAll&quot;</span>&gt;</span>  </span><br><span class="line">        SELECT ST.STUDENT_ID,  </span><br><span class="line">                   ST.STUDENT_NAME,  </span><br><span class="line">                   ST.STUDENT_SEX,  </span><br><span class="line">                   ST.STUDENT_BIRTHDAY,  </span><br><span class="line">                   ST.CLASS_ID  </span><br><span class="line">              FROM STUDENT_TBL ST  </span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>这样，在select的语句中就可以直接引用使用了，将上面select语句改成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生，根据id --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectStudentAll&quot;</span>/&gt;</span>  </span><br><span class="line">            WHERE ST.STUDENT_ID = #&#123;studentID&#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h4 id="parameters">parameters</h4><p>上面很多地方已经用到了参数，比如查询、修改、删除的条件，插入，修改的数据等，MyBatis可以使用的基本数据类型和Java的复杂数据类型。</p><p>基本数据类型，String，int，date等。</p><p>但是使用基本数据类型，只能提供一个参数，所以需要使用Java实体类，或Map类型做参数类型。通过#{}可以直接得到其属性。</p><p><strong>基本类型参数</strong></p><p>根据入学时间，检索学生列表：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，根据入学时间  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentListByDate&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;Date&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT *  </span><br><span class="line">      FROM STUDENT_TBL ST LEFT JOIN CLASS_TBL CT ON ST.CLASS_ID = CT.CLASS_ID  </span><br><span class="line">     WHERE CT.CLASS_YEAR = #&#123;classYear&#125;;      </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListByClassYear(StringUtil.parse(<span class="string">&quot;2007-9-1&quot;</span>));  </span><br><span class="line"><span class="keyword">for</span> (StudentEntity entityTemp : studentList) &#123;  </span><br><span class="line">    System.out.println(entityTemp.toString());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>Java实体类型参数</strong></p><p>根据姓名和性别，检索学生列表。使用实体类做参数：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，like姓名、=性别，参数entity类型 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentListWhereEntity&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;StudentEntity&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT * from STUDENT_TBL ST  </span><br><span class="line">        WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName&#125;),&#x27;%&#x27;)  </span><br><span class="line">          AND ST.STUDENT_SEX = #&#123;studentSex&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentEntity entity = <span class="keyword">new</span> StudentEntity();  </span><br><span class="line">entity.setStudentName(<span class="string">&quot;李&quot;</span>);  </span><br><span class="line">entity.setStudentSex(<span class="string">&quot;男&quot;</span>);  </span><br><span class="line">List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereEntity(entity);  </span><br><span class="line"><span class="keyword">for</span> (StudentEntity entityTemp : studentList) &#123;  </span><br><span class="line">    System.out.println(entityTemp.toString());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>Map参数</strong></p><p>根据姓名和性别，检索学生列表。使用Map做参数：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，=性别，参数map类型 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentListWhereMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT * from STUDENT_TBL ST  </span><br><span class="line">     WHERE ST.STUDENT_SEX = #&#123;sex&#125;  </span><br><span class="line">          AND ST.STUDENT_SEX = #&#123;sex&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();  </span><br><span class="line">map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;女&quot;</span>);  </span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李&quot;</span>);  </span><br><span class="line">List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereMap(map);  </span><br><span class="line"><span class="keyword">for</span> (StudentEntity entityTemp : studentList) &#123;  </span><br><span class="line">    System.out.println(entityTemp.toString());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>多参数的实现</strong></p><p>如果想传入多个参数，则需要在接口的参数上添加@Param注解。给出一个实例：</p><p>接口写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;StudentEntity&gt; <span class="title">getStudentListWhereParam</span><span class="params">(<span class="meta">@Param(value = &quot;name&quot;)</span> String name, <span class="meta">@Param(value = &quot;sex&quot;)</span> String sex, <span class="meta">@Param(value = &quot;birthday&quot;)</span> Date birthdar, <span class="meta">@Param(value = &quot;classEntity&quot;)</span> ClassEntity classEntity)</span></span>;  </span><br></pre></td></tr></table></figure><p>SQL写法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询学生list，like姓名、=性别、=生日、=班级，多参数方式 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentListWhereParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT * from STUDENT_TBL ST  </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line">            ST.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;),&#x27;%&#x27;)  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex!= null and sex!= &#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line">            AND ST.STUDENT_SEX = #&#123;sex&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday!=null&quot;</span>&gt;</span>  </span><br><span class="line">            AND ST.STUDENT_BIRTHDAY = #&#123;birthday&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classEntity!=null and classEntity.classID !=null and classEntity.classID!=&#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line">            AND ST.CLASS_ID = #&#123;classEntity.classID&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>进行查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereParam(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,StringUtil.parse(<span class="string">&quot;1985-05-28&quot;</span>), classMapper.getClassByID(<span class="string">&quot;20000002&quot;</span>));  </span><br><span class="line"><span class="keyword">for</span> (StudentEntity entityTemp : studentList) &#123;  </span><br><span class="line">    System.out.println(entityTemp.toString());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>字符串代入法</strong></p><p>默认的情况下，使用#{}语法会促使MyBatis 生成PreparedStatement 属性并且使用PreparedStatement 的参数（=？）来安全的设置值。尽量这些是快捷安全，也是经常使用的。但有时候你可能想直接未更改的字符串代入到SQL 语句中。比如说，对于ORDER BY，你可能会这样使用：ORDER BY ${columnName}但MyBatis 不会修改和规避掉这个字符串。</p><p>注意：这样地接收和应用一个用户输入到未更改的语句中，是非常不安全的。这会让用户能植入破坏代码，所以，要么要求字段不要允许客户输入，要么你直接来检测他的合法性 。</p><h4 id="cache缓存">cache缓存</h4><p>MyBatis 包含一个强在的、可配置、可定制的缓存机制。MyBatis 3 的缓存实现有了许多改进，既强劲也更容易配置。默认的情况，缓存是没有开启，除了会话缓存以外，它可以提高性能，且能解决全局依赖。开启二级缓存，你只需要在SQL 映射文件中加入简单的一行：</p><blockquote><cache/></blockquote><p>这句简单的语句的作用如下：</p><ol><li>所有在映射文件里的select 语句都将被缓存。</li><li>所有在映射文件里insert,update 和delete 语句会清空缓存。</li><li>缓存使用“最近很少使用”算法来回收</li><li>缓存不会被设定的时间所清空。</li><li>每个缓存可以存储1024 个列表或对象的引用（不管查询出来的结果是什么）。</li><li>缓存将作为“读/写”缓存，意味着获取的对象不是共享的且对调用者是安全的。不会有其它的调用</li><li>者或线程潜在修改。</li></ol><p>例如，创建一个FIFO 缓存让60 秒就清空一次，存储512 个对象结果或列表引用，并且返回的结果是只读。因为在不用的线程里的两个调用者修改它们可能会导致引用冲突。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">size</span>=<span class="string">&quot;512&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>还可以在不同的命名空间里共享同一个缓存配置或者实例。在这种情况下，你就可以使用cache-ref 来引用另外一个缓存。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liming.manager.data.StudentMapper&quot;</span>/&gt;</span>  </span><br></pre></td></tr></table></figure><p>Cache 语句属性配置细节：</p><table><thead><tr><th>属性</th><th>说明</th><th>取值</th><th>默认值</th></tr></thead><tbody><tr><td>eviction</td><td>缓存策略：</td><td></td><td></td></tr><tr><td>LRU - 最近最少使用法：移出最近较长周期内都没有被使用的对象。</td><td></td><td></td><td></td></tr><tr><td>FIFI- 先进先出：移出队列里较早的对象</td><td></td><td></td><td></td></tr><tr><td>SOFT - 软引用：基于软引用规则，使用垃圾回收机制来移出对象</td><td></td><td></td><td></td></tr><tr><td>WEAK - 弱引用：基于弱引用规则，使用垃圾回收机制来强制性地移出对象</td><td>LRU</td><td></td><td></td></tr><tr><td>FIFI</td><td></td><td></td><td></td></tr><tr><td>SOFT</td><td></td><td></td><td></td></tr><tr><td>WEAK</td><td>LRU</td><td></td><td></td></tr><tr><td>flushInterval</td><td>代表一个合理的毫秒总计时间。默认是不设置，因此使用无间隔清空即只能调用语句来清空。</td><td>正整数</td><td>不设置</td></tr><tr><td>size</td><td>缓存的对象的大小</td><td>正整数</td><td>1024</td></tr><tr><td>readOnly</td><td></td><td></td><td></td></tr><tr><td>只读缓存将对所有调用者返回同一个实例。因此都不能被修改，这可以极大的提高性能。可写的缓存将通过序列化来返回一个缓存对象的拷贝。这会比较慢，但是比较安全。所以默认值是false。</td><td>true</td><td>false</td><td>false</td></tr></tbody></table><h3 id="mybatis中的sql标签">mybatis中的sql标签</h3><h4 id="if">if</h4><p>if标签通常用于where语句中，通过判断参数值来决定是否使用某个查询条件，它也经常用于UPDATE语句中判断是否更新某一个字段，还可以再INSERT语句中用来判断是否插入某个字段的值。</p><h5 id="在where条件中使用if">在where条件中使用if</h5><p>用法：含义就是当if满足时，就执行标签体中的内容。</p><p>需求：准备如下数据表，当只输入用户名的时候，就根据这个用户名进行模糊查询匹配的用户；当只输入邮箱时，就根据邮箱完全匹配用户胡；当两者都同时输入时，就需要用这两个条件去查询匹配的用户。</p><p>表格：</p><p><img src="https://img2020.cnblogs.com/blog/1435948/202003/1435948-20200329155126983-923390020.png" alt=""></p><p>贴下关键代码：</p><p>（1）controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/selectByUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SysUser&gt; <span class="title">selectByUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SysUser sysUser=<span class="keyword">new</span> SysUser();</span><br><span class="line">        sysUser.setUserName(<span class="string">&quot;tes&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userService.selectByUser(sysUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：这里只传入了userName。而userEmail为null</p><p>（2）service实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> List&lt;SysUser&gt; <span class="title">selectByUser</span><span class="params">(SysUser sysUser)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         <span class="keyword">return</span> userMapper.selectByUser(sysUser);</span><br><span class="line"><span class="number">4</span>     &#125;</span><br></pre></td></tr></table></figure><p>（3）mapper接口</p><p><code>List&lt;SysUser&gt; selectByUser(SysUser sysUser);</code></p><p>（4）mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.dao.SysUser&quot;</span>&gt;</span>`       </span><br><span class="line">    select id,        </span><br><span class="line">    user_name userName,</span><br><span class="line">    user_password userPassword,</span><br><span class="line">    user_email userEmail,</span><br><span class="line">    user_info userInfo,</span><br><span class="line">    head_img headImg,</span><br><span class="line">    created_time createTime</span><br><span class="line">    from sys_user</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and user_name like concat(&#x27;%&#x27;,#&#123;userName&#125;,&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and user_email=#&#123;userEmail&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：1.if标签内有一个必填的属性test,test的值是一个符合OGNL要求的判断表达式，表达式的结果可以认为是ture或者false.<br>2.当有多个判断条件时，可以使用and或者or进行搭配。<br>3.上面两个if，它们是平级的关系，只要有满足if条件的,if标签内的 and user_x=… 这一句就会接在where语句后面。如果不满足，就不会有。<br>4.这里写了一个where 1=1 是为了保证当2个if语句都没有的时候，不会直接以where结束，这样sql语句就会报错。<br>这种写法where1=1不美观，后面可以采用where标签来拯救它。</p><p>（5）实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">package</span> com.example.demo.dao;</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> java.sql.Date;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 8      * 用户ID</span></span><br><span class="line"><span class="comment"> 9      */</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">private</span> Long id;</span><br><span class="line"><span class="number">11</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">12      * 用户名</span></span><br><span class="line"><span class="comment">13      */</span></span><br><span class="line"><span class="number">14</span>     <span class="keyword">private</span> String userName;</span><br><span class="line"><span class="number">15</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">16      * 密码</span></span><br><span class="line"><span class="comment">17      */</span></span><br><span class="line"><span class="number">18</span>     <span class="keyword">private</span> String userPassword;</span><br><span class="line"><span class="number">19</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">20      * 邮箱</span></span><br><span class="line"><span class="comment">21      */</span></span><br><span class="line"><span class="number">22</span>     <span class="keyword">private</span> String userEmail;</span><br><span class="line"><span class="number">23</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">24      * 简介</span></span><br><span class="line"><span class="comment">25      */</span></span><br><span class="line"><span class="number">26</span>     <span class="keyword">private</span> String userInfo;</span><br><span class="line"><span class="number">27</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">28      * 头像</span></span><br><span class="line"><span class="comment">29      */</span></span><br><span class="line"><span class="number">30</span>     <span class="keyword">private</span> <span class="keyword">byte</span>[] headImg;</span><br><span class="line"><span class="number">31</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">32      * 创建时间</span></span><br><span class="line"><span class="comment">33      */</span></span><br><span class="line"><span class="number">34</span>     <span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="number">35</span> </span><br><span class="line"><span class="number">36</span>     <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">37</span>         <span class="keyword">return</span> id;</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">45</span>         <span class="keyword">return</span> userName;</span><br><span class="line"><span class="number">46</span>     &#125;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="number">49</span>         <span class="keyword">this</span>.userName = userName;</span><br><span class="line"><span class="number">50</span>     &#125;</span><br><span class="line"><span class="number">51</span> </span><br><span class="line"><span class="number">52</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getUserPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">53</span>         <span class="keyword">return</span> userPassword;</span><br><span class="line"><span class="number">54</span>     &#125;</span><br><span class="line"><span class="number">55</span> </span><br><span class="line"><span class="number">56</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserPassword</span><span class="params">(String userPassword)</span> </span>&#123;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">this</span>.userPassword = userPassword;</span><br><span class="line"><span class="number">58</span>     &#125;</span><br><span class="line"><span class="number">59</span> </span><br><span class="line"><span class="number">60</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getUserEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">61</span>         <span class="keyword">return</span> userEmail;</span><br><span class="line"><span class="number">62</span>     &#125;</span><br><span class="line"><span class="number">63</span> </span><br><span class="line"><span class="number">64</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserEmail</span><span class="params">(String userEmail)</span> </span>&#123;</span><br><span class="line"><span class="number">65</span>         <span class="keyword">this</span>.userEmail = userEmail;</span><br><span class="line"><span class="number">66</span>     &#125;</span><br><span class="line"><span class="number">67</span> </span><br><span class="line"><span class="number">68</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">69</span>         <span class="keyword">return</span> userInfo;</span><br><span class="line"><span class="number">70</span>     &#125;</span><br><span class="line"><span class="number">71</span> </span><br><span class="line"><span class="number">72</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line"><span class="number">73</span>         <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line"><span class="number">74</span>     &#125;</span><br><span class="line"><span class="number">75</span> </span><br><span class="line"><span class="number">76</span>     <span class="keyword">public</span> <span class="keyword">byte</span>[] getHeadImg() &#123;</span><br><span class="line"><span class="number">77</span>         <span class="keyword">return</span> headImg;</span><br><span class="line"><span class="number">78</span>     &#125;</span><br><span class="line"><span class="number">79</span> </span><br><span class="line"><span class="number">80</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeadImg</span><span class="params">(<span class="keyword">byte</span>[] headImg)</span> </span>&#123;</span><br><span class="line"><span class="number">81</span>         <span class="keyword">this</span>.headImg = headImg;</span><br><span class="line"><span class="number">82</span>     &#125;</span><br><span class="line"><span class="number">83</span> </span><br><span class="line"><span class="number">84</span>     <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">85</span>         <span class="keyword">return</span> createTime;</span><br><span class="line"><span class="number">86</span>     &#125;</span><br><span class="line"><span class="number">87</span> </span><br><span class="line"><span class="number">88</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Date createTime)</span> </span>&#123;</span><br><span class="line"><span class="number">89</span>         <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line"><span class="number">90</span>     &#125;</span><br><span class="line"><span class="number">91</span> &#125;</span><br></pre></td></tr></table></figure><p>采用postman模拟请求，会得到三条和名字模糊匹配的记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 [</span><br><span class="line"> 2     &#123;</span><br><span class="line"> 3         &quot;id&quot;: 3,</span><br><span class="line"> 4         &quot;userName&quot;: &quot;test1&quot;,</span><br><span class="line"> 5         &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line"> 6         &quot;userEmail&quot;: &quot;test1@mybatis.tk&quot;,</span><br><span class="line"> 7         &quot;userInfo&quot;: &quot;test1&quot;,</span><br><span class="line"> 8         &quot;headImg&quot;: null,</span><br><span class="line"> 9         &quot;createTime&quot;: &quot;2020-03-04&quot;</span><br><span class="line">10     &#125;,</span><br><span class="line">11     &#123;</span><br><span class="line">12         &quot;id&quot;: 1001,</span><br><span class="line">13         &quot;userName&quot;: &quot;test&quot;,</span><br><span class="line">14         &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line">15         &quot;userEmail&quot;: &quot;test@mybatis.tk&quot;,</span><br><span class="line">16         &quot;userInfo&quot;: &quot;管理员&quot;,</span><br><span class="line">17         &quot;headImg&quot;: null,</span><br><span class="line">18         &quot;createTime&quot;: &quot;2020-03-19&quot;</span><br><span class="line">19     &#125;,</span><br><span class="line">20     &#123;</span><br><span class="line">21         &quot;id&quot;: 1002,</span><br><span class="line">22         &quot;userName&quot;: &quot;test1&quot;,</span><br><span class="line">23         &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line">24         &quot;userEmail&quot;: &quot;test1@mybatis.tk&quot;,</span><br><span class="line">25         &quot;userInfo&quot;: &quot;test1&quot;,</span><br><span class="line">26         &quot;headImg&quot;: null,</span><br><span class="line">27         &quot;createTime&quot;: &quot;2020-03-25&quot;</span><br><span class="line">28     &#125;,</span><br><span class="line">29     &#123;</span><br><span class="line">30         &quot;id&quot;: 1003,</span><br><span class="line">31         &quot;userName&quot;: &quot;test1&quot;,</span><br><span class="line">32         &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line">33         &quot;userEmail&quot;: &quot;test1@mybatis.tk&quot;,</span><br><span class="line">34         &quot;userInfo&quot;: &quot;test1&quot;,</span><br><span class="line">35         &quot;headImg&quot;: null,</span><br><span class="line">36         &quot;createTime&quot;: &quot;2020-03-29&quot;</span><br><span class="line">37     &#125;,</span><br><span class="line">38     &#123;</span><br><span class="line">39         &quot;id&quot;: 1004,</span><br><span class="line">40         &quot;userName&quot;: &quot;test1&quot;,</span><br><span class="line">41         &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line">42         &quot;userEmail&quot;: &quot;test1@mybatis.tk&quot;,</span><br><span class="line">43         &quot;userInfo&quot;: &quot;test1&quot;,</span><br><span class="line">44         &quot;headImg&quot;: null,</span><br><span class="line">45         &quot;createTime&quot;: &quot;2020-03-29&quot;</span><br><span class="line">46     &#125;</span><br><span class="line">47 ]</span><br></pre></td></tr></table></figure><h5 id="在UPDATE更新列中使用if标签">在UPDATE更新列中使用if标签</h5><p>需求：只更新发生变化的字段。</p><p>（1）controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="meta">@PostMapping(&quot;/updateBySelective&quot;)</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">int</span> <span class="title">updateBySelective</span><span class="params">(SysUser sysUser)</span></span>&#123;</span><br><span class="line"><span class="number">3</span>         sysUser.setUserName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="number">4</span>         sysUser.setId(<span class="number">1L</span>);</span><br><span class="line"><span class="number">5</span>         <span class="keyword">return</span> userService.updateBySelective(sysUser);</span><br><span class="line"><span class="number">6</span>     &#125;</span><br></pre></td></tr></table></figure><p>（2）service实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBySelective</span><span class="params">(SysUser sysUser)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         <span class="keyword">return</span> userMapper.updateBySelective(sysUser);</span><br><span class="line"><span class="number">4</span>     &#125;</span><br></pre></td></tr></table></figure><p>（3）mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">int</span> <span class="title">updateBySelective</span><span class="params">(SysUser sysUser)</span></span>;</span><br></pre></td></tr></table></figure><p>（4）mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBySelective&quot;</span>&gt;</span></span><br><span class="line">        update sys_user</span><br><span class="line">        set</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_name=#&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userPassword!=null and userPassword!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_password=#&#123;userPassword&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_email=#&#123;userEmail&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userInfo!=null and userInfo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_info=#&#123;userInfo&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;headImg!=null&quot;</span>&gt;</span></span><br><span class="line">            head_img=#&#123;headImg,jdbcType=BLOB&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime!=null&quot;</span>&gt;</span></span><br><span class="line">            created_time=#&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：1.这里 id=#{id}是为了防止所有if都不满足的时候语法错误。即使if中有个别满足的，也不能省去，否则sql语法错误。<br>这种写法不美观，仍然然可以通过where标签和set标签来解决。</p><p><img src="https://img2020.cnblogs.com/blog/1435948/202003/1435948-20200329162456705-455078904.png" alt=""></p><h5 id="在INSERT动态插入列中使用if标签">在INSERT动态插入列中使用if标签</h5><p>需求：如果某一列的参数值不为空，就使用传入的值；如果传入参数为空，就使用数据库中默认的值（通常为空），而不使用传入的空值。</p><p>（1）controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@PostMapping(&quot;/insertUser&quot;)</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span>        SysUser sysUser=<span class="keyword">new</span> SysUser();</span><br><span class="line"><span class="number">5</span>        sysUser.setUserName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="number">6</span>        sysUser.setUserEmail(<span class="string">&quot;aa.@qq.com&quot;</span>);</span><br><span class="line"><span class="number">7</span>        sysUser.setUserInfo(<span class="string">&quot;作家&quot;</span>);</span><br><span class="line"><span class="number">8</span>        <span class="keyword">return</span> userService.insertUser(sysUser);</span><br><span class="line"><span class="number">9</span>     &#125;</span><br></pre></td></tr></table></figure><p>（2）service实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(SysUser sysUser)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         <span class="keyword">return</span> userMapper.insertUser(sysUser);</span><br><span class="line"><span class="number">4</span>     &#125;</span><br></pre></td></tr></table></figure><p>（3）mapper接口</p><p><code>int insertUser(SysUser sysUser);</code></p><p>（4）mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into sys_user(</span><br><span class="line">    user_name,user_password,user_email,</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userInfo!=null and userInfo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        user_info,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    head_img,created_time)</span><br><span class="line">    values(</span><br><span class="line">    #&#123;userName&#125;,#&#123;userPassword&#125;,#&#123;userEmail&#125;,</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userInfo!=null and userInfo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        #&#123;userInfo&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    #&#123;headImg,jdbcType=BLOB&#125;,#&#123;createTime,jdbcType=TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="choose-when、otherwise）">choose(when、otherwise）</h4><p>if标签只能实现if功能，没有else功能。于是可以通过本节的组合来实现if…else的功能。choose中农包含when和otherwise两个标签，一个choose中至少有一个when，有0个或1个otherwise.</p><p>我的理解：when就相当于java中的else if，而otherwise就相当于java中的else。</p><p>需求：准备如下表。当ID有值的时候就优先采用ID进行查询匹配用户；如果ID没有值，那就采用用户名进行查询匹配的用户。</p><p><img src="https://img2020.cnblogs.com/blog/1435948/202003/1435948-20200329164526213-1738106582.png" alt=""></p><p>（1）controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@PostMapping(&quot;/selectByIdOrName&quot;)</span></span><br><span class="line"><span class="number">2</span>     <span class="function">SysUser <span class="title">selectByIdOrName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">3</span>         SysUser sysUser=<span class="keyword">new</span> SysUser();</span><br><span class="line"><span class="number">4</span>         sysUser.setId(<span class="number">1L</span>);</span><br><span class="line"><span class="number">5</span>         sysUser.setUserName(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line"><span class="number">6</span>         <span class="keyword">return</span> userService.selectByIdOrName(sysUser);</span><br><span class="line"><span class="number">7</span>     &#125;</span><br></pre></td></tr></table></figure><p>（2）service实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@Override</span></span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> SysUser <span class="title">selectByIdOrName</span><span class="params">(SysUser sysUser)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         <span class="keyword">return</span> userMapper.selectByIdOrName(sysUser);</span><br><span class="line"><span class="number">4</span>     &#125;</span><br></pre></td></tr></table></figure><p>（3）mapper接口</p><p><code>SysUser selectByIdOrName(SysUser sysUser);</code></p><p>（4）mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIdOrName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.dao.SysUser&quot;</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">    user_name userName,</span><br><span class="line">    user_password userPassword,</span><br><span class="line">    user_email userEmail,</span><br><span class="line">    user_info userInfo,</span><br><span class="line">    head_img headImg,</span><br><span class="line">    created_time createTime</span><br><span class="line">    from sys_user</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and user_name=#&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and 1=2</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>postman</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;userName&quot;: &quot;test1&quot;,</span><br><span class="line">    &quot;userPassword&quot;: &quot;123456&quot;,</span><br><span class="line">    &quot;userEmail&quot;: &quot;admin@mybatis.tk&quot;,</span><br><span class="line">    &quot;userInfo&quot;: &quot;管理员&quot;,</span><br><span class="line">    &quot;headImg&quot;: null,</span><br><span class="line">    &quot;createTime&quot;: &quot;2020-03-01&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="where、set、trim">where、set、trim</h4><h5 id="where">where</h5><p>修改之前的where 1=1例子，姓名模糊匹配，邮箱完全匹配查询。</p><p>修改之前：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.dao.SysUser&quot;</span>&gt;</span></span><br><span class="line">        select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        user_password userPassword,</span><br><span class="line">        user_email userEmail,</span><br><span class="line">        user_info userInfo,</span><br><span class="line">        head_img headImg,</span><br><span class="line">        created_time createTime</span><br><span class="line">        from sys_user</span><br><span class="line">        where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and user_name like concat(&#x27;%&#x27;,#&#123;userName&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and user_email=#&#123;userEmail&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接将xml文件改为如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.dao.SysUser&quot;</span>&gt;</span></span><br><span class="line">        select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        user_password userPassword,</span><br><span class="line">        user_email userEmail,</span><br><span class="line">        user_info userInfo,</span><br><span class="line">        head_img headImg,</span><br><span class="line">        created_time createTime</span><br><span class="line">        from sys_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_name like concat(&#x27;%&#x27;,#&#123;userName&#125;,&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_email=#&#123;userEmail&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：当if都不满足的时候，where中就没有元素，就不会存在之前缺少where 1=1造成sql错误的问题。</p><h5 id="set用法">set用法</h5><p>与where标签类似的，在update语句里也会碰到多个字段相关的问题。 在这种情况下，就可以使用set标签。<br>其效果与where标签类似，有数据的时候才进行设置。</p><p>还是之前的例子：</p><p>修改之前：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBySelective&quot;</span>&gt;</span></span><br><span class="line">        update sys_user</span><br><span class="line">        set</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_name=#&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userPassword!=null and userPassword!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_password=#&#123;userPassword&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_email=#&#123;userEmail&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userInfo!=null and userInfo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            user_info=#&#123;userInfo&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;headImg!=null&quot;</span>&gt;</span></span><br><span class="line">            head_img=#&#123;headImg,jdbcType=BLOB&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime!=null&quot;</span>&gt;</span></span><br><span class="line">            created_time=#&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改之后：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 1 <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line"> 2         update sys_user</span><br><span class="line"> 3         set</span><br><span class="line"> 4         <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;_parameter&quot;</span> <span class="attr">item</span>=<span class="string">&quot;val&quot;</span> <span class="attr">index</span>=<span class="string">&quot;key&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line"> 5             $&#123;key&#125;=#&#123;val&#125;</span><br><span class="line"> 6         <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> 7         where id=#&#123;id&#125;</span><br><span class="line"> 8     <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"> 9 </span><br><span class="line">10     <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBySelective&quot;</span>&gt;</span></span><br><span class="line">11         update sys_user</span><br><span class="line">12         <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">13             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">14                 user_name=#&#123;userName&#125;,</span><br><span class="line">15             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">16             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userPassword!=null and userPassword!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">17                 user_password=#&#123;userPassword&#125;,</span><br><span class="line">18             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">19             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">20                 user_email=#&#123;userEmail&#125;,</span><br><span class="line">21             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">22             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userInfo!=null and userInfo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">23                 user_info=#&#123;userInfo&#125;,</span><br><span class="line">24             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">25             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;headImg!=null&quot;</span>&gt;</span></span><br><span class="line">26                 head_img=#&#123;headImg,jdbcType=BLOB&#125;,</span><br><span class="line">27             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">28             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime!=null&quot;</span>&gt;</span></span><br><span class="line">29                 created_time=#&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">30             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">31             id=#&#123;id&#125;</span><br><span class="line">32         <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">33         where id=#&#123;id&#125;</span><br><span class="line">34     <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种只解决了逗号问题，不是很全面的解决问题，仍然需要</p><p>id=#{id}</p><h5 id="trim标签">trim标签</h5><p>where和set标签的功能都能通过trim标签实现。</p><p><img src="https://img2020.cnblogs.com/blog/1435948/202003/1435948-20200329171906958-413431918.png" alt=""></p><p>举例：</p><p>（1）还是之前的用户名模糊匹配，邮箱完全匹配的例子：（使用trim标签去除多余的and关键字）</p><p>修改mapper.xml文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.dao.SysUser&quot;</span>&gt;</span></span><br><span class="line">        select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        user_password userPassword,</span><br><span class="line">        user_email userEmail,</span><br><span class="line">        user_info userInfo,</span><br><span class="line">        head_img headImg,</span><br><span class="line">        created_time createTime</span><br><span class="line">        from sys_user</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName!=null and userName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_name like concat(&#x27;%&#x27;,#&#123;userName&#125;,&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userEmail!=null and userEmail!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and user_email=#&#123;userEmail&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果一样的。但是就不会多写where1=1，并且指定了prefix为where。</p><h4 id="foreach标签">foreach标签</h4><p>作用是：<br>foreach标签通常用于in 这样的语法里。</p><p>用法（接收一个List集合参数）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.myjava.pojo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span></span><br><span class="line">          SELECT * FROM product_</span><br><span class="line">            WHERE ID in</span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">                    #&#123;item&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="bind标签">bind标签</h4><p>bind标签就像是再做一次字符串拼接，网上也有说叫绑定，差不多意思，只是方便后续的使用。</p><p>用法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.myjava.pojo&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listProduct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Product&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;likename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + name + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">            select * from   product_  where name like #&#123;likename&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="sql片段标签">sql片段标签</h4><p>作用是：</p><p>通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。<br>这样既可以提高编码效率，还能有效简化代码，提高可读性。</p><p>用法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义sql片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;orderAndItem&quot;</span>&gt;</span></span><br><span class="line">    o.order_id,o.cid,o.address,o.create_date,o.orderitem_id,i.orderitem_id,i.product_id,i.count</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrderAndItemsByOid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line"><span class="comment">&lt;!--引用sql片段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;orderAndItem&quot;</span> /&gt;</span></span><br><span class="line">    from ordertable o</span><br><span class="line">    join orderitem i on o.orderitem_id = i.orderitem_id</span><br><span class="line">    where o.order_id = #&#123;orderId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="case语句的使用">case语句的使用</h3><p>CASE是一个控制流语句，其作用与IF-THEN-ELSE语句非常相似，可根据数据选择值。 CASE语句遍历条件并在满足第一个条件时返回值。 因此，一旦条件成立，它将短路，从而忽略后面的子句并返回结果。 正如我们在今天的博客中看到的那样，它可以用来测试条件和离散值。</p><p>基本语法<br>CASE语句有两种形式：第一种评估一个或多个条件，并返回第一个符合条件的结果。 如果没有条件是符合的，则返回ELSE子句部分的结果，如果没有ELSE部分，则返回NULL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN</span><br><span class="line">    <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>第二种CASE句法返回第一个<code>value = compare_value</code>比较结果为真的结果。 如果没有比较结果符合，则返回ELSE后的结果，如果没有ELSE部分，则返回NULL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> compare_value</span><br><span class="line">    <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN</span><br><span class="line">    <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题的额外美化</title>
      <link href="/2022/01/25/butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E7%BE%8E%E5%8C%96/"/>
      <url>/2022/01/25/butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="添加看板娘">添加看板娘</h2><p>输入如下命令获取 live2d：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>输入以下命令，下载相应的模型，将 haruto 更换成你想要的模型名称即可（本人就选haruto），更多模型选择请点击此处，各个模型的预览请访问<a href="https://huaji8.top/post/live2d-plugin-2.0/">原作者的博客</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>打开站点目录下的 <code>_config.yml</code>文件，添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">enable: true</span><br><span class="line">scriptFrom: local</span><br><span class="line">model: </span><br><span class="line">use: live2d-widget-model-koharu #模型选择</span><br><span class="line">display: </span><br><span class="line">position: right  #模型位置</span><br><span class="line">width: 150       #模型宽度</span><br><span class="line">height: 300      #模型高度</span><br><span class="line">mobile: </span><br><span class="line">show: false      #是否在手机端显示</span><br></pre></td></tr></table></figure><h2 id="图片懒加载">图片懒加载</h2><p>懒加载一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载</p><p><code>butterfly</code>主题整体采用预加载模式，这样可以在我们访问其他页面的时候会稍微快点。我们可以在这个基础上对图片进行懒加载，这样做效果就是html、css、js加载之后，图片再加载。既保证了网页的打开速度，也不会因图片的庞大体积而拖累了整个页面的加载。</p><h3 id="操作流程">操作流程</h3><p>首先安装图片懒加载插件：<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a></p><p>在Hexo根目录执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>然后在Hexo配置文件末尾加入以下代码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">onlypost:</span> <span class="literal">false</span>  <span class="comment"># 是否只对文章的图片做懒加载</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="comment"># eg ./images/loading.gif</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
      <url>/2022/01/24/java%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1>Java快速入门</h1><h2 id="java基本概念">java基本概念</h2><p>javaEE,javaSE</p><p>JDK,JRE</p><p>那JSR、JCP……又是啥？</p><p>JSR规范：Java Specification Request</p><p>JCP组织：Java Community Process</p><p>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</p><h2 id="Java程序基础">Java程序基础</h2><h3 id="Java程序基本结构">Java程序基本结构</h3><h3 id="变量和数据类型">变量和数据类型</h3><p>基本数据类型</p><p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p>int和float需要四个字节<br>char需要两个字节</p><h4 id="var关键字">var关键字</h4><p>如果想省略变量类型，可以使用var关键字</p><h3 id="整数运算">整数运算</h3><p>在Java的计算表达式中，运算优先级从高到低依次是：</p><ul><li>()</li><li>! ~ ++ –</li><li><ul><li>/ %</li></ul></li><li></li><li>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</li><li>&amp;</li><li>|</li><li>+= -= *= /=</li></ul><p>位运算</p><h4 id="类型自动提升与强制转型">类型自动提升与强制转型</h4><p>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int</p><h3 id="浮点数运算">浮点数运算</h3><p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p><p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型</p><p>整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：</p><p>NaN表示Not a Number<br>Infinity表示无穷大<br>-Infinity表示负无穷大</p><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。</p><h3 id="布尔运算">布尔运算</h3><p>关系运算符的优先级从高到低依次是：</p><ul><li>!</li><li><blockquote><p>，&gt;=，&lt;，&lt;=</p></blockquote></li><li>==，!=</li><li>&amp;&amp;</li><li>||</li></ul><p>注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一</p><h3 id="字符和字符串">字符和字符串</h3><p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可：</p><p>因为字符串使用双引号&quot;…&quot;表示开始和结束，那如果字符串本身恰好包含一个&quot;字符怎么表示？例如，“abc&quot;xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\：</p><blockquote><p>String s = “abc&quot;xyz”; // 包含7个字符: a, b, c, &quot;, x, y, z</p></blockquote><p>因为\是转义字符，所以，两个\表示一个\字符</p><p>&quot; 表示字符&quot;<br>’ 表示字符’<br>\ 表示字符<br>\n 表示换行符<br>\r 表示回车符<br>\t 表示Tab</p><p>\u#### 表示一个Unicode编码的字符</p><p>如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接</p><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 hello</span></span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空值">空值</h4><p>引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">null</span>; <span class="comment">// s1是null</span></span><br><span class="line">String s2; <span class="comment">// 没有赋初值值，s2也是null</span></span><br><span class="line">String s3 = s1; <span class="comment">// s3也是null</span></span><br><span class="line">String s4 = <span class="string">&quot;&quot;</span>; <span class="comment">// s4指向空字符串，不是null</span></span><br></pre></td></tr></table></figure><h3 id="数组类型">数组类型</h3><h2 id="流程控制">流程控制</h2><h3 id="输入和输出">输入和输出</h3><h4 id="输出">输出</h4><p>在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。</p><p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()</p><p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式</p><p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p><p>占位符说明<br>%d格式化输出整数<br>%x格式化输出十六进制整数<br>%f格式化输出浮点数<br>%e格式化输出科学计数法表示的浮点数<br>%s格式化字符串</p><p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p><h4 id="输入">输入</h4><p>我们先看一个从控制台读取一个字符串和一个整数的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if判断">if判断</h3><p>在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false：</p><p>要判断引用类型的变量内容是否相等，必须使用equals()方法：</p><h3 id="switch多重选择">switch多重选择</h3><p>使用 <code>switch</code>时，注意 <code>case</code>语句并没有花括号 <code>&#123;&#125;</code>，而且，<code>case</code>语句具有“穿透性”，漏写 <code>break</code>将导致意想不到的结果</p><p>使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应</p><h4 id="yield-2">yield</h4><p>大多数时候，在switch表达式内部，我们会返回简单的值。</p><p>但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while循环">while循环</h3><h3 id="do-while循环">do while循环</h3><h3 id="for循环">for循环</h3><p>很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种for each循环，它可以更简单地遍历数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break和continue">break和continue</h3><p>break语句可以跳出当前循环；</p><p>break语句通常配合if，在满足条件时提前结束整个循环；</p><p>break语句总是跳出最近的一层循环；</p><p>continue语句可以提前结束本次循环；</p><p>continue语句通常配合if，在满足条件时提前结束本次循环</p><h2 id="数组操作">数组操作</h2><h3 id="遍历数组">遍历数组</h3><p>使用for each循环打印也很麻烦。幸好Java标准库提供了 <code>Arrays.toString()</code>，可以快速打印数组内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序">数组排序</h3><p>一些排序算法</p><p>Java的标准库已经内置了排序功能，我们只需要调用JDK提供的 <code>Arrays.sort()</code>(升序)就可以排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须注意，对数组排序实际上修改了数组本身</p><h3 id="二维数组">二维数组</h3><p>ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下：<br>┌───┬───┬───┬───┐<br>┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │<br>ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘<br>├───┤      ┌───┬───┬───┬───┐<br>│░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │<br>├───┤      └───┴───┴───┴───┘<br>│░░░│──┐   ┌───┬───┬───┬───┐<br>└───┘  └──&gt;│ 9 │10 │11 │12 │<br>└───┴───┴───┴───┘</p><p>要打印一个二维数组,可以使用Java标准库的Arrays.deepToString()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="命令行参数">命令行参数</h3><p>Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。</p><p>这个命令行参数由JVM接收用户输入并传给main方法</p><p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号</p><h1>面向对象编程</h1><p>面向对象的三个基本特征：封装、继承、多态</p><h2 id="面向对象基础">面向对象基础</h2><p>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p><h3 id="方法">方法</h3><p>一个 <code>class</code>可以包含多个 <code>field</code>，例如，我们给 <code>Person</code>类就定义了两个 <code>field</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，直接把 <code>field</code>用 <code>public</code>暴露给外部可能会破坏封装性。</p><p>显然，直接操作 <code>field</code>，容易造成逻辑混乱。为了避免外部代码直接去访问 <code>field</code>，我们可以用 <code>private</code>修饰 <code>field</code>，拒绝外部访问.</p><p>把field从public改成private，外部代码不能访问这些field,那怎么才能给它赋值？怎么才能读取它的值？</p><p>所以我们需要使用 <code>方法（method）</code>来让外部代码可以间接修改 <code>field</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">        ming.setName(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 设置name</span></span><br><span class="line">        ming.setAge(<span class="number">12</span>); <span class="comment">// 设置age</span></span><br><span class="line">        System.out.println(ming.getName() + <span class="string">&quot;, &quot;</span> + ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid age value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然外部代码不能直接修改 <code>private</code>字段，但是，外部代码可以调用方法 <code>setName()</code>和 <code>setAge()</code>来间接修改 <code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错</p><p>调用方法的语法是 <code>实例变量.方法名(参数)</code>;。一个方法调用就是一个语句，所以不要忘了在末尾加 <code>;</code>。</p><p>方法返回值通过 <code>return</code>语句实现，如果没有返回值，返回类型设置为 <code>void</code>，可以省略 <code>return</code></p><h4 id="private方法">private方法</h4><p>有 <code>public</code>方法，自然就有 <code>private</code>方法。和 <code>private</code>字段一样，<code>private</code>方法不允许外部调用，那我们定义 <code>private</code>方法有什么用？</p><p>定义 <code>private</code>方法的理由是内部方法是可以调用 <code>private</code>方法的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">        ming.setBirth(<span class="number">2008</span>);</span><br><span class="line">        System.out.println(ming.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(<span class="keyword">int</span> birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用private方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcAge</span><span class="params">(<span class="keyword">int</span> currentYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>Person</code>类只定义了 <code>birth</code>字段，没有定义 <code>age</code>字段，获取 <code>age</code>时，通过方法 <code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心 <code>Person</code>实例在内部到底有没有 <code>age</code>字段。</p><h4 id="this变量">this变量</h4><p>在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。</p><p>如果没有命名冲突，可以省略this。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方</p><h3 id="构造方法">构造方法</h3><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句</p><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</p><p>也可以对字段直接进行初始化:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p><p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol><li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为 <code>10</code>，<code>double salary;</code>表示字段默认初始化为 <code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为 <code>null</code>；</li><li>执行构造方法的代码进行初始化。</li></ol><p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定</p><h4 id="多构造方法">多构造方法</h4><p>可以定义多个构造方法，在通过 <code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>new Person(&quot;Xiao Ming&quot;, 20);</code>，会自动匹配到构造方法 <code>public Person(String, int)</code>。</p><p>如果调用 <code>new Person(&quot;Xiao Ming&quot;);</code>，会自动匹配到构造方法 <code>public Person(String)</code>。</p><p>如果调用 <code>new Person()</code>;，会自动匹配到构造方法 <code>public Person()</code>。</p><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是 <code>this(…)</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载">方法重载</h3><p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。</p><p>这种方法名相同，但各自的参数不同，称为方法重载（Overload）。</p><p>注意：方法重载的返回值类型通常都是相同的。</p><p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p><p>举个例子，String类提供了多个重载方法indexOf()，可以查找子串：</p><ul><li>int indexOf(int ch)：根据字符的Unicode码查找；</li><li>int indexOf(String str)：根据字符串查找；</li><li>int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置；</li><li>int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。</li></ul><h3 id="继承">继承</h3><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让 <code>Student</code>从 <code>Person</code>继承时，<code>Student</code>就获得了 <code>Person</code>的所有功能，我们只需要为 <code>Student</code>编写新增的功能。</p><p>Java使用 <code>extends</code>关键字来实现继承</p><p>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p><p>在OOP的术语中，我们把 <code>Person</code>称为超类（super class），父类（parent class），基类（base class），把 <code>Student</code>称为子类（subclass），扩展类（extended class）</p><p>注意到我们在定义 <code>Person</code>的时候，没有写 <code>extends</code>。在Java中，没有明确写 <code>extends</code>的类，编译器会自动加上 <code>extends Object</code>。所以，任何类，除了 <code>Object</code>，都会继承自某个类。</p><p>下图是Person、Student的继承树：</p><p>┌───────────┐<br>│  Object   │<br>└───────────┘<br>▲<br>│<br>┌───────────┐<br>│  Person   │<br>└───────────┘<br>▲<br>│<br>┌───────────┐<br>│  Student  │<br>└───────────┘<br>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有 <code>Object</code>特殊，它没有父类。</p><h4 id="protected">protected</h4><p>继承有个特点，就是子类无法访问父类的private字段或者private方法。</p><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为 <code>protected</code>。用 <code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问.</p><h4 id="super">super</h4><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用 <code>super.fieldName</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="keyword">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这里使用 <code>super.name</code>，或者 <code>this.name</code>，或者 <code>name</code>，效果都是一样的。编译器会自动定位到父类的 <code>name</code>字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。</p><p>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句 <code>super()</code>;，所以，Student类的构造方法实际上是这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，Person类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用Person类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h4 id="阻止继承">阻止继承</h4><p>正常情况下，只要某个class没有 <code>final</code>修饰符，那么任何类都可以从该class继承。</p><p>从 <code>Java 15</code>开始，允许使用 <code>sealed</code>修饰class，并通过 <code>permits</code>明确写出能够从该class继承的子类名称。</p><p>例如，定义一个 <code>Shape</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="title">permits</span> <span class="title">Rect</span>, <span class="title">Circle</span>, <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述Shape类就是一个sealed类，它只允许指定的3个类继承它。</p><p><code>sealed</code>类在 <code>Java 15</code>中目前是预览状态，要启用它，必须使用参数 <code>--enable-preview</code>和 <code>--source 15</code>。</p><h4 id="向上转型">向上转型</h4><p>如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例</p><blockquote><p>Student s = new Student();</p></blockquote><p>如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例：</p><blockquote><p>Person p = new Person();</p></blockquote><p>现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？</p><blockquote><p>Person p = new Student(); // ???</p></blockquote><p>测试一下就可以发现，这种指向是允许的！</p><p>这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为 <code>向上转型（upcasting）</code>。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><p>注意到继承树是 <code>Student &gt; Person &gt; Object</code>，所以，可以把 <code>Student</code>类型转型为 <code>Person</code>，或者更高层次的 <code>Object</code></p><h4 id="向下转型">向下转型</h4><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是 <code>向下转型（downcasting）</code>。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Student(); <span class="comment">// upcasting, ok</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Student s1 = (Student) p1; <span class="comment">// ok</span></span><br><span class="line">Student s2 = (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure><p>如果测试上面的代码，可以发现：</p><p><code>Person</code>类型 <code>p1</code>实际指向 <code>Student</code>实例，<code>Person</code>类型变量 <code>p2</code>实际指向 <code>Person</code>实例。在向下转型的时候，把 <code>p1</code>转型为 <code>Student</code>会成功，因为 <code>p1</code>确实指向 <code>Student</code>实例，把 <code>p2</code>转型为 <code>Student</code>会失败，因为 <code>p2</code>的实际类型是 <code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报 <code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java提供了 <code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为 <code>null</code>，那么对任何 <code>instanceof</code>的判断都为 <code>false</code>。</p><h4 id="区分继承和组合">区分继承和组合</h4><p>在使用继承时，我们要注意逻辑一致性。</p><p>考察下面的Book类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。</p><p>究其原因，是因为 <code>Student</code>是 <code>Person</code>的一种，它们是 <code>is</code>关系，而 <code>Student</code>并不是 <code>Book</code>。实际上 <code>Student</code>和 <code>Book</code>的关系是 <code>has</code>关系。</p><p>具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，继承是is关系，组合是has关系。</p><h3 id="多态">多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为 <code>覆写（Override）</code>。</p><p>例如，在Person类中，我们定义了 <code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类Student中，覆写这个 <code>run()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Student.run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Override</code>和 <code>Overload</code>不同的是，如果方法参数不同，就是 <code>Overload</code>，<code>Overload</code>方法是一个新方法；如果方法参数相同，并且返回值也相同，就是 <code>Override</code>。</p><p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p><p>加上 <code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p><p>但是 <code>@Override</code>不是必需的。</p><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p><p>这个非常重要的特性在面向对象编程中称之为 <code>多态</code>。它的英文拼写非常复杂：<code>Polymorphic</code>。</p><h4 id="多态-2">多态</h4><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure><p>有童鞋会问，从上面的代码一看就明白，肯定调用的是 <code>Student</code>的 <code>run()</code>方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><p>我们还是来举栗子。</p><p>假设我们定义一种收入，需要给它报税，那么先定义一个Income类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">        total = total + income.getTax();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 <code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和 <code>Income</code>打交道，它完全不需要知道 <code>Salary</code>和 <code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从 <code>Income</code>派生，然后正确覆写 <code>getTax()</code>方法就可以。把新的类型传入 <code>totalTax()</code>，不需要修改任何代码。</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h4 id="覆写Object方法">覆写Object方法</h4><p>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</p><ul><li><code>toString()</code>：把instance输出为String；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。<br>在必要的情况下，我们可以覆写Object的这几个方法。</li></ul><h4 id="调用super">调用super</h4><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过 <code>super</code>来调用。</p><h4 id="final">final</h4><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 <code>final</code>。用 <code>final</code>修饰的方法不能被 <code>Override</code></p><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为 <code>final</code>。用 <code>final</code>修饰的类不能被继承</p><h3 id="抽象类">抽象类</h3><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为 <code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译 <code>Person</code>类，因为它包含抽象方法。</p><p>必须把 <code>Person</code>类本身也声明为 <code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：</p><blockquote><p>Person p = new Person(); // 编译错误</p></blockquote><p>抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法</p><p>当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person s = <span class="keyword">new</span> Student();</span><br><span class="line">Person t = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line">Person e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><p>尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="接口">接口</h3><p>在Java中，使用 <code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓 <code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 <code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。<br>当一个具体的 <code>class</code>去实现一个 <code>interface</code>时，需要使用 <code>implements</code>关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个 <code>interface</code>，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的接口特指 <code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class     interface</span><br></pre></td></tr></table></figure><p>继承     只能extends一个class可以implements多个interface<br>字段     可以定义实例字段     不能定义实例字段<br>抽象方法 可以定义抽象方法     可以定义抽象方法<br>非抽象方法 可以定义非抽象方法     可以定义default方法</p><h4 id="接口继承">接口继承</h4><p>一个 <code>interface</code>可以继承自另一个 <code>interface</code>。<code>interface</code>继承自 <code>interface</code>使用 <code>extends</code>，它相当于扩展了接口的方法。</p><h4 id="default方法">default方法</h4><p>在接口中，可以定义 <code>default</code>方法。例如，把 <code>Person</code>接口的 <code>run()</code>方法改为 <code>default</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写 <code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是 <code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为 <code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h3 id="静态字段和静态方法">静态字段和静态方法</h3><p>在一个 <code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用 <code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 定义静态字段number:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        Person hong = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        ming.number = <span class="number">88</span>;</span><br><span class="line">        System.out.println(hong.number);  <span class="comment">//  88</span></span><br><span class="line">        hong.number = <span class="number">99</span>;</span><br><span class="line">        System.out.println(ming.number);  <span class="comment">//  99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：<br>┌──────────────────┐<br>ming ──&gt;│Person instance   │<br>├──────────────────┤<br>│name = &quot;Xiao Ming&quot;│<br>│age = 12          │<br>│number ───────────┼──┐    ┌─────────────┐<br>└──────────────────┘  │    │Person class │<br>│    ├─────────────┤<br>├───&gt;│number = 99  │<br>┌──────────────────┐  │    └─────────────┘<br>hong ──&gt;│Person instance   │  │<br>├──────────────────┤  │<br>│name = &quot;Xiao Hong&quot;│  │<br>│age = 15          │  │<br>│number ───────────┼──┘<br>└──────────────────┘<br>虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。</p><p>推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）</p><h4 id="静态方法">静态方法</h4><p>有静态字段，就有静态方法。用static修饰的方法称为静态方法。</p><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。<br>因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。<br>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><p>静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。</p><h4 id="抽象的静态字段">抽象的静态字段</h4><p>因为 <code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为 <code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，因为 <code>interface</code>的字段只能是 <code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会自动把该字段变为 <code>public static final</code>类型。</p><h3 id="包">包</h3><h4 id="包作用域">包作用域</h4><p>位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域</p><h3 id="作用域">作用域</h3><h4 id="final-2">final</h4><p>Java还提供了一个 <code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用 <code>final</code>修饰 <code>class</code>可以阻止被继承</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法被继承:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>final</code>修饰 <code>method</code>可以阻止被子类覆写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无法被覆写:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>final</code>修饰 <code>field</code>可以阻止被重新赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>final</code>修饰局部变量可以阻止被重新赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。</p><p>一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。</p><h3 id="内部类">内部类</h3><h4 id="Inner-Class">Inner Class</h4><p>如果一个类定义在另一个类的内部，这个类就是 <code>Inner Class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Inner Class</code>的实例不能单独存在，必须依附于一个 <code>Outer Class</code>的实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，要实例化一个 <code>Inner</code>，我们必须首先创建一个 <code>Outer</code>的实例，然后，调用 <code>Outer</code>实例的 <code>new</code>来创建 <code>Inner</code>实例：</p><blockquote><p>Outer.Inner inner = outer.new Inner();</p></blockquote><p>这是因为Inner Class除了有一个 <code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用 <code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p><p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的 <code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的 <code>private</code>字段和方法。</p><p>观察Java编译器编译后的 <code>.class</code>文件可以发现，<code>Outer</code>类被编译为 <code>Outer.class</code>，而 <code>Inner</code>类被编译为 <code>Outer$Inner.class</code>。</p><h4 id="Anonymous-Class-匿名类">Anonymous Class(匿名类)</h4><p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asyncHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 <code>asyncHello()</code>方法，我们在方法内部实例化了一个 <code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了 <code>Runnable</code>接口的匿名类，并且通过 <code>new</code>实例化该匿名类，然后转型为 <code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名类和 <code>Inner Class</code>一样，可以访问 <code>Outer Class</code>的 <code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义 <code>Inner Class</code>可以少写很多代码。</p><p>观察Java编译器编译后的 <code>.class</code>文件可以发现，<code>Outer</code>类被编译为 <code>Outer.class</code>，而匿名类被编译为 <code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为 <code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p><p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码<br>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map1</code>是一个普通的 <code>HashMap</code>实例，但 <code>map2</code>是一个匿名类实例，只是该匿名类继承自 <code>HashMap</code>。<code>map3</code>也是一个继承自 <code>HashMap</code>的匿名类实例，并且添加了 <code>static</code>代码块来初始化数据。观察编译输出可发现 <code>Main$1.class</code>和 <code>Main$2.class</code>两个匿名类文件。</p><h4 id="Static-Nested-Class">Static Nested Class</h4><p>最后一种内部类和 <code>Inner Clas</code>s类似，但是使用 <code>static</code>修饰，称为静态内部类（Static Nested Class）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.StaticNested sn = <span class="keyword">new</span> Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>static</code>修饰的内部类和 <code>Inner Class</code>有很大的不同，它不再依附于 <code>Outer</code>的实例，而是一个完全独立的类，因此无法引用 <code>Outer.this</code>，但它可以访问 <code>Outer</code>的 <code>private</code>静态字段和静态方法。如果把 <code>StaticNested</code>移到 <code>Outer</code>之外，就失去了访问 <code>private</code>的权限。</p><h3 id="classpath和jar">classpath和jar</h3><h4 id="classpath">classpath</h4><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索 <code>class</code>。</p><p>因为Java是编译型语言，源码文件是 <code>.java</code>，而编译后的 <code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个 <code>abc.xyz.Hello</code>的类，应该去哪搜索对应的 <code>Hello.class</code>文件。</p><p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用 <code>;</code>分隔，带空格的目录用 <code>&quot;&quot;</code>括起来，可能长这样：</p><blockquote><p>C:\work\project1\bin;C:\shared;“D:\My Documents\project1\bin”</p></blockquote><p>在Linux系统上，用 <code>:</code>分隔，可能长这样：</p><blockquote><p>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</p></blockquote><p>现在我们假设classpath是.;C:\work\project1\bin;C:\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找：</p><ul><li>&lt;当前目录&gt;\abc\xyz\Hello.class</li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul><p>注意到 <code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><p><code>classpat</code>h的设定方法有两种：</p><ol><li>在系统环境变量中设置 <code>classpath</code>环境变量，不推荐；</li><li>在启动JVM时设置 <code>classpath</code>变量，推荐。</li></ol><p>我们强烈不推荐在系统环境变量中设置 <code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置 <code>classpath</code>才是推荐的做法。实际上就是给 <code>java</code>命令传入 <code>-classpat</code>h或 <code>-cp</code>参数：</p><blockquote><p>java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</p></blockquote><p>或者使用 <code>-cp</code>的简写：</p><blockquote><p>java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</p></blockquote><p>没有设置系统环境变量，也没有传入 <code>-cp</code>参数，那么JVM默认的classpath为 <code>.</code>，即当前目录：</p><blockquote><p>java abc.xyz.Hello</p></blockquote><p>上述命令告诉JVM只在当前目录搜索Hello.class。</p><p>在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。</p><p>通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？</p><p>有很多“如何设置classpath”的文章会告诉你把JVM自带的 <code>rt.jar</code>放入 <code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找 <code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p><div class="note info simple"><p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库</p></div><p>更好的做法是，不要设置 <code>classpath</code>！默认的当前目录.对于绝大多数情况都够用了。</p><p>假设我们有一个编译后的 <code>Hello.class</code>，它的包名是 <code>com.example</code>，当前目录是 <code>C:\work</code>，那么，目录结构必须如下：</p><p>C:\work<br>└─ com<br>└─ example<br>└─ Hello.class<br>运行这个Hello.class必须在当前目录下使用如下命令：</p><blockquote><p>C:\work&gt; java -cp . com.example.Hello</p></blockquote><p>JVM根据 <code>classpath</code>设置的.在当前目录下查找 <code>com.example.Hello</code>，即实际搜索文件必须位于 <code>com/example/Hello.class</code>。如果指定的 <code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p><h4 id="jar包">jar包</h4><p>如果有很多 <code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把 <code>package</code>组织的目录层级，以及各个目录下的所有文件（包括 <code>.class</code>文件和其他文件）都打成一个 <code>jar</code>文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的 <code>class</code>，就可以把jar包放到 <code>classpath</code>中：</p><blockquote><p>java -cp ./hello.jar abc.xyz.Hello</p></blockquote><p>这样JVM会自动在 <code>hello.jar</code>文件里去搜索某个类。</p><p>那么问题来了：如何创建jar包？</p><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从 <code>.zip</code>改为 <code>.jar</code>，一个jar包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><p>package_sample<br>└─ bin<br>├─ hong<br>│  └─ Person.class<br>│  ming<br>│  └─ Person.class<br>└─ mr<br>└─ jun<br>└─ Arrays.class<br>这里需要特别注意的是，jar包里的第一层目录，不能是 <code>bin</code>，而应该是 <code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l" alt=""></p><p>如果长这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l" alt=""></p><p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的 <code>class</code>，原因是 <code>hong.Person</code>必须按 <code>hong/Person.class</code>存放，而不是 <code>bin/hong/Person.class</code>。</p><p>jar包还可以包含一个特殊的 <code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定 <code>Main-Class</code>和其它信息。JVM会自动读取这个 <code>MANIFEST.MF</code>文件，如果存在 <code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><blockquote><p>java -jar hello.jar</p></blockquote><p>jar包还可以包含其它jar包，这个时候，就需要在 <code>MANIFEST.MF</code>文件里配置 <code>classpath</code>了。</p><p>在大型项目中，不可能手动编写 <code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如 <code>Maven</code>，可以非常方便地创建jar包。</p><h4 id="模块">模块</h4><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>什么是模块？这要从Java 9之前的版本说起。</p><p>我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫 <code>rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><blockquote><p>java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</p></blockquote><div class="note info simple"><p>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。<br>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出 <code>ClassNotFoundException</code>。</p></div><p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的 <code>rt.jar</code>分拆成了几十个模块，这些模块以 <code>.jmod</code>扩展名标识，可以在 <code>$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>这些 <code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块 <code>java.base</code>对应的文件就是 <code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的 <code>module-info.class</code>文件了。所有的模块都直接或间接地依赖 <code>java.base</code>模块，只有 <code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从 <code>Object</code>直接或间接继承而来。</p><p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h4 id="编写模块">编写模块</h4><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以 <code>oop-module</code>工程为例，它的目录结构如下：</p><p>oop-module<br>├── bin<br>├── <a href="http://build.sh">build.sh</a><br>└── src<br>├── com<br>│   └── itranswarp<br>│       └── sample<br>│           ├── Greeting.java<br>│           └── Main.java<br>└── module-info.java</p><p>其中，<code>bin</code>目录存放编译后的 <code>class</code>文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在 <code>src</code>目录下多了一个 <code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line"><span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>module</code>是关键字，后面的 <code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的 <code>requires xxx</code>;表示这个模块需要引用的其他模块名。除了 <code>java.base</code>可以被自动引入外，这里我们引入了一个 <code>java.xml</code>的模块。<br>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Greeting g = <span class="keyword">new</span> Greeting();</span><br><span class="line">System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 <code>requires java.xml;</code>从 <code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。<br>下面，我们用JDK提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到 <code>oop-module</code>，在当前目录下编译所有的 <code>.java</code>文件，并存放到 <code>bin</code>目录下，命令如下：</p><blockquote><p>$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</p></blockquote><p>如果编译成功，现在项目结构如下：<br>oop-module<br>├── bin<br>│   ├── com<br>│   │   └── itranswarp<br>│   │       └── sample<br>│   │           ├── Greeting.class<br>│   │           └── Main.class<br>│   └── module-info.class<br>└── src<br>├── com<br>│   └── itranswarp<br>│       └── sample<br>│           ├── Greeting.java<br>│           └── Main.java<br>└── module-info.java</p><p>注意到 <code>src</code>目录下的 <code>module-info.java</code>被编译到 <code>bin</code>目录下的 <code>module-info.class</code>。</p><p>下一步，我们需要把 <code>bin</code>目录下的所有 <code>class</code>文件先打包成 <code>jar</code>，在打包的时候，注意传入 <code>--main-class</code>参数，让这个jar包能自己定位main方法所在的类：</p><blockquote><p>$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</p></blockquote><p>现在我们就在当前目录下得到了 <code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令 <code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块：</p><blockquote><p>$ jmod create --class-path hello.jar hello.jmod</p></blockquote><p>于是，在当前目录下我们又得到了 <code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p><h4 id="运行模块">运行模块</h4><p>要运行一个jar，我们使用 <code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p><blockquote><p>$ java --module-path hello.jmod --module hello.world</p></blockquote><p>结果是一个错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure><p>原因是 <code>.jmod</code>不能被放入 <code>--module-path</code>中。换成 <code>.jar</code>就没问题了：</p><blockquote><p>$ java --module-path hello.jar --module hello.world<br>Hello, xml!</p></blockquote><p>那我们辛辛苦苦创建的 <code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p><h4 id="打包JRE">打包JRE</h4><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的 <code>rt.jar</code>拆成了几十个.<code>jmod模块</code>，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下：</p><blockquote><p>$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</p></blockquote><p>我们在 <code>--module-path</code>参数指定了我们自己的模块 <code>hello.jmod</code>，然后，在 <code>--add-modules</code>参数中指定了我们用到的3个模块 <code>java.base</code>、<code>java.xml</code>和 <code>hello.world</code>，用,分隔。最后，在 <code>--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己 <code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><blockquote><p>$ jre/bin/java --module hello.world<br>Hello, xml!</p></blockquote><p>要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h4 id="访问权限">访问权限</h4><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块 <code>hello.world</code>用到了模块 <code>java.xml</code>的一个类 <code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块 <code>java.xml</code>的 <code>module-info.java</code>中声明了若干导出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的 <code>hello.world</code>模块中的 <code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，模块进一步隔离了代码的访问权限。</p><h2 id="Java核心类">Java核心类</h2><h3 id="字符串和编码">字符串和编码</h3><h4 id="String">String</h4><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个 <code>class</code>。但是，Java编译器对String有特殊处理，即可以直接用 <code>&quot;...&quot;</code>来表示一个字符串：</p><blockquote><p>String s1 = “Hello!”;</p></blockquote><p>实际上字符串在String内部是通过一个 <code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><blockquote><p>String s2 = new String(new char[] {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘!’});</p></blockquote><p>因为 <code>String</code>太常用了，所以Java提供了 <code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><p>Java字符串的一个重要特点就是 <code>字符串不可变</code>。这种不可变性是通过内部的 <code>private final char[]</code>字段，以及没有任何修改 <code>char[]</code>的方法实现的。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(s);  <span class="comment">// Hello</span></span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        System.out.println(s);  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/one12138/p/11379840.html">关于字符串不可变的进一步参考</a></p><h4 id="字符串比较">字符串比较</h4><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用 <code>equals()</code>方法而不能用==。</p><p>我们看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);    <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2));  <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从表面上看，两个字符串用 <code>==</code>和 <code>equals()</code>比较都为 <code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然 <code>s1</code>和 <code>s2</code>的引用就是相同的。</p><p>所以，这种 <code>==</code>比较返回 <code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);        <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s2));   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：两个字符串比较，必须总是使用 <code>equals()</code>方法。</p><p>要忽略大小写比较，使用 <code>equalsIgnoreCase()</code>方法。</p><p>String类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p><blockquote><p>// 是否包含子串:<br>“Hello”.contains(“ll”); // true</p></blockquote><p>注意到 <code>contains()</code>方法的参数是 <code>CharSequence</code>而不是 <code>String</code>，因为 <code>CharSequence</code>是 <code>String</code>的父类。</p><p>搜索子串的更多的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>提取子串的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure><p>注意索引号是从0开始的。</p><h4 id="去除首尾空白字符">去除首尾空白字符</h4><p>使用 <code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><blockquote><p>&quot;  \tHello\r\n &quot;.trim(); // “Hello”</p></blockquote><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个 <code>strip()</code>方法也可以移除字符串首尾空白字符。它和 <code>trim()</code>不同的是，类似中文的空格字符 <code>\u3000</code>也会被移除：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure><p>String还提供了 <code>isEmpty()</code>和 <code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure><h4 id="替换子串">替换子串</h4><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure><p>另一种是通过正则表达式替换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure><p>上面的代码通过正则表达式，把匹配的子串统一替换为 <code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p><h4 id="分割字符串">分割字符串</h4><p>要分割字符串，使用 <code>split()</code>方法，并且传入的也是正则表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="拼接字符串">拼接字符串</h4><p>拼接字符串使用静态方法 <code>join()</code>，它用指定的字符串连接字符串数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure><h4 id="格式化字符串">格式化字符串</h4><p>字符串提供了 <code>formatted()</code>方法和 <code>format()静态方法</code>，可以传入其他参数，替换占位符，然后生成新的字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));    <span class="comment">//Hi Alice, your score is 80!</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));     <span class="comment">//Hi Bob, your score is 59.50!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p><ul><li>%s：显示字符串；</li><li>%d：显示整数；</li><li>%x：显示十六进制整数；</li><li>%f：显示浮点数。</li></ul><p>占位符还可以带格式，例如 <code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用 <code>%s</code>，因为 <code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p><h4 id="类型转换">类型转换</h4><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法 <code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为 <code>int</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure><p>把字符串转换为 <code>boolean</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>要特别注意，<code>Integer</code>有个 <code>getInteger(String)</code>方法，它不是将字符串转换为 <code>int</code>，而是把该字符串对应的系统变量转换为 <code>Integer</code>：</p><blockquote><p>Integer.getInteger(“java.version”); // 版本号，11</p></blockquote><h4 id="转换为char">转换为char[]</h4><p><code>String</code>和 <code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure><p>如果修改了 <code>char[]</code>数组，<code>String</code>并不会改变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        String s = <span class="keyword">new</span> String(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为通过 <code>new String(char[])</code>创建新的 <code>String</code>实例时，它并不会直接引用传入的 <code>char[]</code>数组，而是会复制一份，所以，修改外部的 <code>char[]</code>数组不会影响 <code>String</code>实例内部的 <code>char[]</code>数组，因为这是两个不同的数组。</p><p>从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><p>例如，下面的代码设计了一个 <code>Score类</code>保存一组学生的成绩：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        Score s = <span class="keyword">new</span> Score(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] scores;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Score</span><span class="params">(<span class="keyword">int</span>[] scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scores = scores;</span><br><span class="line">       <span class="comment">// this.scores = Arrays.copyOf(scores, scores.length);  方法一</span></span><br><span class="line">       <span class="comment">/**   方法二</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; scores.length; i++) &#123;</span></span><br><span class="line"><span class="comment">        this.scores[i]=scores[i]</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printScores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察两次输出，由于 <code>Score</code>内部直接引用了外部传入的 <code>int[]</code>数组，这会造成外部代码对 <code>int[]</code>数组的修改，影响到 <code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p><p>请修复 <code>Score</code>的构造方法，使得外部代码对数组的修改不影响 <code>Score</code>实例的 <code>int[]</code>字段。</p><h4 id="字符编码">字符编码</h4><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从 <code>0</code>到 <code>127</code>，最高位始终为 <code>0</code>，称为 <code>ASCII编码</code>。例如，字符 <code>'A'</code>的编码是 <code>0x41</code>，字符 <code>'1'</code>的编码是 <code>0x31</code>。</p><p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和 <code>ASCII</code>编码区分开。例如，汉字 <code>'中'</code>的 <code>GB2312</code>编码是 <code>0xd6d0</code>。</p><p>类似的，日文有 <code>Shift_JIS</code>编码，韩文有 <code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了 <code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在 <code>ASCII</code>、<code>GB2312</code>和 <code>Unicode</code>的编码：</p><p>英文字符 <code>'A'</code>的 <code>ASCII</code>编码和 <code>Unicode</code>编码：<br>┌────┐<br>ASCII:   │ 41 │<br>└────┘<br>┌────┬────┐<br>Unicode: │ 00 │ 41 │<br>└────┴────┘</p><p>英文字符的 <code>Unicode</code>编码就是简单地在前面添加一个 <code>00</code>字节。</p><p>中文字符’中’的 <code>GB2312</code>编码和 <code>Unicode</code>编码：<br>┌────┬────┐<br>GB2312:  │ d6 │ d0 │<br>└────┴────┘<br>┌────┬────┐<br>Unicode: │ 4e │ 2d │<br>└────┴────┘</p><p>GBK中文占两个字节，英文占一个字节。</p><p>那我们经常使用的 <code>UTF-8</code>又是什么编码呢？因为英文字符的 <code>Unicode</code>编码高字节总是 <code>00</code>，包含大量英文的文本会浪费空间，所以，出现了 <code>UTF-8</code>编码，它是一种 <code>变长编码</code>，用来把固定长度的 <code>Unicode编码</code>变成 <code>1～4字节的变长编码</code>。通过 <code>UTF-8</code>编码，英文字符 <code>'A'</code>的 <code>UTF-8</code>编码变为0x41，正好和 <code>ASCII码</code>一致，而中文 <code>'中'</code>的 <code>UTF-8</code>编码为3字节 <code>0xe4b8ad</code>。</p><p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为 <code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code>char</code>类型实际上就是两个字节的 <code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure><p>注意：转换编码后，就不再是 <code>char</code>类型，而是 <code>byte</code>类型表示的数组。</p><p>如果要把已知编码的 <code>byte[]</code>转换为 <code>String</code>，可以这样做：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure><p>始终牢记：Java的 <code>String</code>和 <code>char</code>在内存中总是以 <code>Unicode</code>编码表示。</p><h4 id="延伸阅读">延伸阅读</h4><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的 <code>String</code>总是以char[]存储，它的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而较新的JDK版本的 <code>String</code>则以 <code>byte[]</code>存储：如果String仅包含 <code>ASCII</code>字符，则每个 <code>byte</code>存储一个字符，否则，每两个 <code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的 <code>String</code>通常仅包含 <code>ASCII字符</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure><p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的 <code>public</code>方法签名是不变的。</p><h3 id="StringBuilder">StringBuilder</h3><p>Java编译器对 <code>String</code>做了特殊处理，使得我们可以直接用 <code>+</code>拼接字符串。</p><p>考察下面的循环代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC(垃圾收集 Garbage Collection)效率。</p><p>为了能高效拼接字符串，Java标准库提供了 <code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往 <code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code>还可以进行链式操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());  <span class="comment">//Hello, Mr Bob!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们查看 <code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的 <code>append()</code>方法会返回 <code>this</code>，这样，就可以不断调用自身的其他方法。</p><p>仿照 <code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Adder adder = <span class="keyword">new</span> Adder();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());  <span class="comment">//19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adder <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adder <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于普通的字符串 <code>+</code>操作，并不需要我们将其改写为 <code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的 <code>+</code>操作编码为 <code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者 <code>StringBuilder</code>操作。</p><p>你可能还听说过 <code>StringBuffer</code>，这是Java早期的一个 <code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作 <code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和 <code>StringBuffer</code>接口完全相同，现在完全没有必要使用 <code>StringBuffer</code>。</p><h3 id="StringJoiner">StringJoiner</h3><p>要高效拼接字符串，应该使用 <code>StringBuilder</code>。</p><p>很多时候，我们拼接的字符串像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个 <code>StringJoiner</code>来干这个事：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢着！用 <code>StringJoiner</code>的结果少了前面的 <code>&quot;Hello &quot;</code>和结尾的 <code>&quot;!&quot;</code>！遇到这种情况，需要给 <code>StringJoiner</code>指定“开头”和“结尾”：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String-join">String.join()</h4><p><code>String</code>还提供了一个静态方法 <code>join()</code>，这个方法在内部使用了 <code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用 <code>String.join()</code>更方便：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h3 id="包装类型">包装类型</h3><p>我们已经知道，Java的数据类型分两种：</p><p>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></p><p>引用类型：所有 <code>class</code>和 <code>interface</code>类型</p><p>引用类型可以赋值为 <code>null</code>，表示空，但基本类型不能赋值为 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>比如，想要把 <code>int</code>基本类型变成一个引用类型，我们可以定义一个 <code>Integer</code>类，它只包含一个实例字段 <code>int</code>，这样，<code>Integer</code>类就可以视为int的包装类 <code>（Wrapper Class）</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了 <code>Integer</code>类，我们就可以把 <code>int</code>和 <code>Integer</code>互相转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">null</span>;</span><br><span class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</span><br><span class="line"><span class="keyword">int</span> n3 = n2.intValue();</span><br></pre></td></tr></table></figure><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th>基本类型</th><th>对应的引用类型</th></tr></thead><tbody><tr><td>boolean</td><td>java.lang.Boolean</td></tr><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>char</td><td>java.lang.Character</td></tr></tbody></table><p>我们可以直接使用，并不需要自己去定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        Integer n3 = Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Auto-Boxing">Auto Boxing</h4><p>因为int和Integer可以互相转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer n = Integer.valueOf(i);</span><br><span class="line"><span class="keyword">int</span> x = n.intValue();</span><br></pre></td></tr></table></figure><p>所以，Java编译器可以帮助我们自动在int和Integer之间转型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><p>这种直接把 <code>int</code>变为 <code>Integer</code>的赋值写法，称为自动装箱 <code>（Auto Boxing）</code>，反过来，把 <code>Integer</code>变为 <code>int</code>的赋值写法，称为自动拆箱 <code>（Auto Unboxing）</code>。</p><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报 <code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;java.lang.Integer.intValue()&quot; because &quot;&lt;local1&gt;&quot; is null</span></span><br><span class="line"><span class="comment">at Main.main(Main.java:5)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="不变类">不变类</h4><p>所有的包装类型都是不变类。我们查看 <code>Integer</code>的源码可知，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，一旦创建了Integer对象，该对象就是不变的。</p><p>对两个 <code>Integer</code>实例进行比较要特别注意：绝对不能用 <code>==</code>比较，因为 <code>Integer</code>是引用类型，必须使用 <code>equals()</code>比较：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">127</span>;</span><br><span class="line">        Integer y = <span class="number">127</span>;</span><br><span class="line">        Integer m = <span class="number">99999</span>;</span><br><span class="line">        Integer n = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x == y: &quot;</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m == n: &quot;</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x.equals(y): &quot;</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m.equals(n): &quot;</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的 <code>Integer</code>返回 <code>true</code>，较大的两个相同的 <code>Integer</code>返回 <code>false</code>，这是因为 <code>Integer</code>是不变类，编译器把 <code>Integer x = 127;</code>自动变为 <code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为 <code>true</code>，但我们绝不能因为Java标准库的 <code>Integer</code>内部有缓存优化就用 <code>==</code>比较，必须用 <code>equals()</code>方法比较两个 <code>Integer</code>。</p><p>因为 <code>Integer.valueOf()</code>可能始终返回同一个 <code>Integer</code>实例，因此，在我们自己创建 <code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：Integer n = new Integer(100);</li><li>方法2：Integer n = Integer.valueOf(100);</li></ul><p>方法2更好，因为方法1总是创建新的 <code>Integer</code>实例，方法2把内部优化留给 <code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为 <code>静态工厂方法</code>。<code>Integer.valueOf()</code>就是 <code>静态工厂方法</code>，它尽可能地返回缓存的实例以节省内存。</p><div class="note info simple"><p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p></div><p>如果我们考察 <code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的 <code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p><h4 id="进制转换">进制转换</h4><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法 <code>parseInt()</code>可以把字符串解析成一个整数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure><p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br></pre></td></tr></table></figure><p>注意：上述方法的输出都是 <code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p><p>┌────────┬────────┬────────┬────────┐<br>│00000000│00000000│00000000│01100100│<br>└────────┴────────┴────────┴────────┘<br>我们经常使用的 <code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用 <code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p><p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p><p>Java的包装类型还定义了一些有用的静态变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure><p>最后，所有的整数和浮点数的包装类型都继承自 <code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="keyword">byte</span> b = num.byteValue();</span><br><span class="line"><span class="keyword">int</span> n = num.intValue();</span><br><span class="line"><span class="keyword">long</span> ln = num.longValue();</span><br><span class="line"><span class="keyword">float</span> f = num.floatValue();</span><br><span class="line"><span class="keyword">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure><h4 id="处理无符号整型">处理无符号整型</h4><p>在Java中，并没有 <code>无符号整型（Unsigned）</code>的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和 <code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>byte</code>的 <code>-1</code>的二进制表示是 <code>11111111</code>，以无符号整型转换后的 <code>int</code>就是 <code>255</code>。</p><p>类似的，可以把一个 <code>short</code>按 <code>unsigned</code>转换为 <code>int</code>，把一个 <code>int</code>按 <code>unsigned</code>转换为 <code>long</code>。</p><h3 id="JavaBean">JavaBean</h3><p>在Java中，有很多 <code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure><p>那么这种class被称为 <code>JavaBean</code>：</p><p>上面的字段是 <code>xyz</code>，那么读写方法名分别以 <code>get</code>和 <code>set</code>开头，并且后接大写字母开头的字段名 <code>Xyz</code>，因此两个读写方法名分别是 <code>getXyz()</code>和 <code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为 <code>isXyz()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="keyword">boolean</span> value)</span></span></span><br></pre></td></tr></table></figure><p>我们通常把一组对应的 <code>读方法（getter）</code>和 <code>写方法（setter）</code>称为 <code>属性（property）</code>。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p>只有 <code>getter</code>的属性称为 <code>只读属性（read-only）</code>，例如，定义一个 <code>age</code>只读属性：</p><ul><li>对应的读方法是<code>int getAge()</code></li><li>无对应的写方法<code>setAge(int)</code></li></ul><p>类似的，只有 <code>setter</code>的属性称为 <code>只写属性（write-only）</code>。</p><p>很明显，只读属性很常见，只写属性不常见。</p><p>属性只需要定义 <code>getter</code>和 <code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>getter</code>和 <code>setter</code>也是一种数据封装的方法。</p><h4 id="JavaBean的作用">JavaBean的作用</h4><p><code>JavaBean</code>主要用来传递数据，即把一组数据组合成一个J <code>avaBean</code>便于传输。此外，<code>JavaBean</code>可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>通过IDE，可以快速生成 <code>getter</code>和 <code>setter</code>。例如，在Eclipse中，先输入以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成 <code>getter</code>和 <code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p><h4 id="枚举JavaBean属性">枚举JavaBean属性</h4><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的 <code>Introspector</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              age</span></span><br><span class="line"><span class="comment">            public int Person.getAge()</span></span><br><span class="line"><span class="comment">            public void Person.setAge(int)</span></span><br><span class="line"><span class="comment">              class</span></span><br><span class="line"><span class="comment">            public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">            null</span></span><br><span class="line"><span class="comment">              name</span></span><br><span class="line"><span class="comment">            public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">            public void Person.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意 <code>class</code>属性是从 <code>Object</code>继承的 <code>getClass()</code>方法带来的</p><h3 id="枚举类">枚举类</h3><p>在Java中，我们可以通过static final来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的int表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MON = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THU = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRI = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAT = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量的时候，可以这么引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> work at home</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RED = <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREEN = <span class="string">&quot;g&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BLUE = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量的时候，可以这么引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String color = ...</span><br><span class="line"><span class="keyword">if</span> (Color.RED.equals(color)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是int常量还是String常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekday == <span class="number">6</span> || weekday == <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == Weekday.MON) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码编译和运行均不会报错，但存在两个问题：</p><p>注意到 <code>Weekday</code>定义的常量范围是 <code>0~6</code>，并不包含7，编译器无法检查不在枚举中的int值；<br>定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</p><h4 id="enum">enum</h4><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到定义枚举类是通过关键字 <code>enum</code>实现的，我们只需依次列出枚举的常量名。</p><p>和int定义的常量相比，使用 <code>enum</code>定义枚举有如下好处：</p><p>首先，<code>enum</code>常量本身带有类型信息，即 <code>Weekday.SUN</code>类型是 <code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> day = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p><p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个 <code>Weekday</code>枚举类型的变量赋值为 <code>Color</code>枚举类型的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Weekday x = Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line">Weekday y = Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure><p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p><h4 id="enum的比较">enum的比较</h4><p>使用 <code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用 <code>equals()</code>方法，如果使用 <code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用 <code>equals()</code>方法，但 <code>enum</code>类型可以例外。</p><p>这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用 <code>==</code>比较：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enum类型">enum类型</h4><p>通过 <code>enum</code>定义的枚举类，和其他的 <code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是 <code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li><li>例如，我们定义的<code>Color</code>枚举类：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器编译出的class大概就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，编译后的 <code>enum</code>类和普通 <code>class</code>并没有任何区别。但是我们自己无法按定义普通 <code>class</code>那样来定义 <code>enum</code>，必须使用 <code>enum</code>关键字，这是Java语法规定的。</p><p>因为 <code>enum</code>是一个 <code>class</code>，每个枚举的值都是 <code>class</code>实例，因此，这些实例有一些方法：</p><h5 id="name">name()</h5><p>返回常量名，例如：</p><blockquote><p>String s = <a href="http://Weekday.SUN.name">Weekday.SUN.name</a>(); // “SUN”</p></blockquote><h5 id="ordinal">ordinal()</h5><p>返回定义的常量的顺序，从0开始计数，例如：</p><blockquote><p>int n = Weekday.MON.ordinal(); // 1</p></blockquote><p>改变枚举常量定义的顺序就会导致 <code>ordinal()</code>返回值发生变化。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的 <code>ordinal</code>就是不同的。如果在代码中编写了类似 <code>if(x.ordinal()==1)</code>这样的语句，就要保证 <code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p><p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和 <code>int</code>转换，使用 <code>ordinal()</code>不是非常方便？比如这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String task = Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure><p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠 <code>ordinal()</code>的返回值。因为 <code>enum</code>本身是 <code>class</code>，所以我们可以定义 <code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个 <code>int</code>值。</p><p>注意：枚举类的字段也可以是非 <code>final</code>类型，即可以在运行期修改，但是不推荐这样做！</p><p>默认情况下，对枚举常量调用 <code>toString()</code>会返回和 <code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而 <code>name()</code>则不行。我们可以给 <code>Weekday</code>添加 <code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆写 <code>toString()</code>的目的是在输出时更有可读性。</p><p>注意：判断枚举常量的名字，要始终使用 <code>name()</code>方法，绝不能调用 <code>toString()</code>！</p><h4 id="switch">switch</h4><p>最后，枚举类可以应用在 <code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比 <code>int</code>、<code>String</code>类型更适合用在 <code>switch</code>语句中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录类">记录类</h3><p>使用 <code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol><li>定义<code>class</code>时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个 <code>Point</code>类，有 <code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证不变类的比较，还需要正确覆写 <code>equals()</code>和 <code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写 <code>equals()</code>和 <code>hashCode()</code>，这里演示 <code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p><h4 id="record">record</h4><p>从Java 14开始，引入了新的 <code>Record</code>类。我们定义 <code>Record</code>类时，使用关键字 <code>record</code>。把上述 <code>Point</code>类改写为 <code>Record</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 456</span></span><br><span class="line"><span class="comment">// Point[x=123, y=456]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>仔细观察 <code>Point</code>的定义：</p><blockquote><p>public record Point(int x, int y) {}</p></blockquote><p>把上述定义改写为class，相当于以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了用 <code>final</code>修饰 <code>class</code>以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写 <code>toString()</code>、<code>equals()</code>和 <code>hashCode()</code>方法。</p><p>换句话说，使用 <code>record</code>关键字，可以一行写出一个不变类。</p><p>和 <code>enum</code>类似，我们自己不能直接从 <code>Record</code>派生，只能通过 <code>record</code>关键字由编译器实现继承。</p><h4 id="构造方法-2">构造方法</h4><p>编译器默认按照 <code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p><p>假设 <code>Point</code>类的 <code>x</code>、<code>y</code>不允许负数，我们就得给 <code>Point</code>的构造方法加上检查逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到方法 <code>public Point &#123;...&#125;</code>被称为 <code>Compact Constructor</code>，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为 <code>record</code>的 <code>Point</code>仍然可以添加静态方法。一种常用的静态方法是 <code>of()</code>方法，用来创建 <code>Point</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以写出更简洁的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> z = Point.of();</span><br><span class="line"><span class="keyword">var</span> p = Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure><h3 id="BigInteger">BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是 <code>64位long</code>型整数。使用 <code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了 <code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个 <code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>对 <code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p>和 <code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把 <code>BigInteger</code>转换成 <code>long</code>型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p><code>BigInteger</code>和 <code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自 <code>Number</code>类。因为 <code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为byte：byteValue()</li><li>转换为short：shortValue()</li><li>转换为int：intValue()</li><li>转换为long：longValue()</li><li>转换为float：floatValue()</li><li>转换为double：doubleValue()</li></ul><p>因此，通过上述方法，可以把 <code>BigInteger</code>转换成基本类型。如果 <code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用 <code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出 <code>ArithmeticException</code>异常。</p><p>如果 <code>BigInteger</code>的值甚至超过了 <code>float</code>的最大范围（3.4x1038），那么返回的 <code>float</code>是  <code>Infinity</code></p><h3 id="BigDecimal">BigDecimal</h3><p>和 <code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用 <code>scale()</code>表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通过 <code>BigDecimal</code>的 <code>stripTrailingZeros()</code>方法，可以将一个 <code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的 <code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个 <code>BigDecimal</code>的 <code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个 <code>BigDecimal</code>设置它的 <code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><p>还可以对 <code>BigDecimal</code>做除法的同时求余数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>divideAndRemainder()</code>方法时，返回的数组包含两个 <code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个 <code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="比较BigDecimal">比较BigDecimal</h4><p>在比较两个 <code>BigDecimal</code>的值是否相等时，要特别注意，使用 <code>equals()</code>方法不但要求两个 <code>BigDecimal</code>的值相等，还要求它们的 <code>scale()相</code>等：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>必须使用 <code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。</p><p>总是使用 <code>compareTo()</code>比较两个 <code>BigDecimal</code>的值，不要使用 <code>equals()</code>！</p><p>如果查看 <code>BigDecimal</code>的源码，可以发现，实际上一个 <code>BigDecimal</code>是通过一个 <code>BigInteger</code>和一个 <code>scale</code>来表示的，即 <code>BigInteger</code>表示一个完整的整数，而 <code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从 <code>Number</code>继承的，也是不可变对象。</p><h3 id="常用工具类">常用工具类</h3><h4 id="Math">Math</h4><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><p>计算xy次方：</p><blockquote><p>Math.pow(2, 10); // 2的10次方=1024</p></blockquote><p>计算√x：</p><blockquote><p>Math.sqrt(2); // 1.414…</p></blockquote><p>计算ex次方：</p><blockquote><p>Math.exp(2); // 7.389…</p></blockquote><p>计算以e为底的对数：</p><blockquote><p>Math.log(4); // 1.386…</p></blockquote><p>计算以10为底的对数：</p><blockquote><p>Math.log10(100); // 2</p></blockquote><p>三角函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p><code>Math</code>还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是0 &lt;= x &lt; 1：</p><blockquote><p>Math.random(); // 0.53907… 每次都不一样</p></blockquote><p>如果我们要生成一个区间在 <code>[MIN, MAX)</code>的随机数，可以借助 <code>Math.random()</code>实现，计算如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="keyword">double</span> min = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">double</span> y = x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="keyword">long</span> n = (<span class="keyword">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些童鞋可能注意到Java标准库还提供了一个 <code>StrictMath</code>，它提供了和 <code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如 <code>x86</code>和 <code>ARM</code>）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而 <code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用 <code>Math</code>就足够了。</p><h4 id="Random">Random</h4><p><code>Random</code>用来创建 <code>伪随机数</code>。所谓 <code>伪随机数</code>，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用 <code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。</p><p>这是因为我们创建 <code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建 <code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面我们使用的 <code>Math.random()</code>实际上内部调用了 <code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p><h4 id="SecureRandom">SecureRandom</h4><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>无法指定种子，它使用 <code>RNG（random number generator）</code>算法。JDK的 <code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureRandom sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> SecureRandom(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用 <code>SecureRandom</code>来产生安全的随机数。</p><p>需要使用安全随机数的时候，必须使用 <code>SecureRandom</code>，绝不能使用 <code>Random</code>！</p><h1>异常处理</h1><h2 id="Java的异常">Java的异常</h2><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> code = processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用 <code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种 <code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Java的异常是 <code>class</code>，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            ┌───────────┐</span><br><span class="line">            │  Object   │</span><br><span class="line">            └───────────┘</span><br><span class="line">                  ▲</span><br><span class="line">                  │</span><br><span class="line">            ┌───────────┐</span><br><span class="line">            │ Throwable │</span><br><span class="line">            └───────────┘</span><br><span class="line">                  ▲</span><br><span class="line">        ┌─────────┴─────────┐</span><br><span class="line">        │                   │</span><br><span class="line">  ┌───────────┐       ┌───────────┐</span><br><span class="line">  │   Error   │       │ Exception │</span><br><span class="line">  └───────────┘       └───────────┘</span><br><span class="line">        ▲                   ▲</span><br><span class="line">┌───────┘              ┌────┴──────────┐</span><br><span class="line">│                      │               │</span><br></pre></td></tr></table></figure><p>┌─────────────────┐    ┌─────────────────┐┌───────────┐<br>│OutOfMemoryError │… │RuntimeException ││IOException│…<br>└─────────────────┘    └─────────────────┘└───────────┘<br>▲<br>┌───────────┴─────────────┐<br>│                         │<br>┌─────────────────────┐ ┌─────────────────────────┐<br>│NullPointerException │ │IllegalArgumentException │…<br>└─────────────────────┘ └─────────────────────────┘</p><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自 <code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和 <code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而 <code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定:</p><ul><li>必须捕获的异常，包括 <code>Exception</code>及其子类，但不包括 <code>RuntimeException</code>及其子类，这种类型的异常称为 <code>Checked Exception</code>。</li><li>不需要捕获的异常，包括 <code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><h4 id="捕获异常">捕获异常</h4><p>捕获异常使用 <code>try...catch</code>语句，把可能发生异常的代码放到 <code>try &#123;...&#125;</code>中，然后使用 <code>catch</code>捕获对应的 <code>Exception</code>及其子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">        <span class="comment">//[-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不捕获 <code>UnsupportedEncodingException</code>，会出现编译失败的问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main.java:11: error: unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</span></span><br><span class="line"><span class="comment">//         return s.getBytes(&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//                          ^</span></span><br><span class="line"><span class="comment">// 1 error</span></span><br><span class="line"><span class="comment">// error: compilation failed</span></span><br></pre></td></tr></table></figure><p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是 <code>return s.getBytes(&quot;GBK&quot;);</code>。意思是说，像 <code>UnsupportedEncodingException</code>这样的 <code>Checked Exception</code>，必须被捕获。</p><p>这是因为 <code>String.getBytes(String)</code>方法定义是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法定义的时候，使用 <code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p><p>在 <code>toGBK()</code>方法中，因为调用了 <code>String.getBytes(String)</code>方法，就必须捕获 <code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用 <code>throws</code>表示 <code>toGBK()</code>方法可能会抛出 <code>UnsupportedEncodingException</code>，就可以让 <code>toGBK()</code>方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java:6: error: unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</span></span><br><span class="line"><span class="comment">//         byte[] bs = toGBK(&quot;中文&quot;);</span></span><br><span class="line"><span class="comment">//                          ^</span></span><br><span class="line"><span class="comment">// 1 error</span></span><br><span class="line"><span class="comment">// error: compilation failed</span></span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用 <code>return s.getBytes(&quot;GBK&quot;)</code>;的问题，而是 <code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在 <code>main()</code>方法中，调用 <code>toGBK()</code>，没有捕获它声明的可能抛出的 <code>UnsupportedEncodingException</code>。</p><p>修复方法是在 <code>main()</code>方法中捕获异常并处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要是方法声明的 <code>Checked Exception</code>，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在 <code>main()</code>方法中捕获，不会出现漏写 <code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获 <code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何 <code>try</code>代码，可以直接把 <code>main()</code>方法定义为 <code>throws Exception</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">        <span class="comment">// [-42, -48, -50, -60]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>main()</code>方法声明了可能抛出 <code>Exception</code>，也就声明了可能抛出所有的 <code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>还有一些童鞋喜欢在 <code>toGBK()</code>内部“消化”异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>所有异常都可以调用 <code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><h2 id="捕获异常-2">捕获异常</h2><p>在Java中，凡是可能抛出异常的语句，都可以用 <code>try ... catch</code>捕获。把可能发生异常的语句放在 <code>try &#123; ... &#125;</code>中，然后使用catch捕获对应的 <code>Exception</code>及其子类。</p><h4 id="多catch语句">多catch语句</h4><p>可以使用多个 <code>catch</code>语句，每个 <code>catch</code>分别捕获对应的 <code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配 <code>catch</code>语句，匹配到某个 <code>catch</code>后，执行 <code>catch</code>代码块，然后不再继续匹配。</p><p>简单地说就是：多个 <code>catch</code>语句只有一个能被执行。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的，因为它是 <code>IOException</code>的子类。当抛出 <code>UnsupportedEncodingException</code>异常时，会被 <code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p><p>因此，正确的写法是把子类放到前面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally语句">finally语句</h4><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以把执行语句写若干遍：正常执行的放到 <code>try</code>中，每个 <code>catch</code>再写一遍。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无论是否发生异常，都会执行 <code>System.out.println(&quot;END&quot;);</code>这条语句。</p><p>那么如何消除这些重复的代码？Java的 <code>try ... catch</code>机制还提供了 <code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意finally有几个特点：</p><ol><li>finally语句不是必须的，可写可不写；</li><li>finally总是最后执行。</li></ol><p>如果没有发生异常，就正常执行 <code>try &#123; ... &#125;</code>语句块，然后执行 <code>finally</code>。如果发生了异常，就中断执行 <code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的 <code>catch</code>语句块，最后执行 <code>finally</code>。</p><p>可见，<code>finally</code>是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有 <code>catch</code>，只使用 <code>try ... finally</code>结构。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为方法声明了可能抛出的异常，所以可以不写 <code>catch</code>。</p><h4 id="捕获多种异常">捕获多种异常</h4><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条 <code>catch</code>子句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为处理 <code>IOException</code>和 <code>NumberFormatException</code>的代码是相同的，所以我们可以把它两用|合并到一起：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常">抛出异常</h2><h3 id="异常的传播">异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个 <code>try ... catch</code>被捕获为止：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            process1(); <span class="comment">//4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();    <span class="comment">//11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException  // 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.NumberFormatException: null</span></span><br><span class="line"><span class="comment">// at java.lang.Integer.parseInt(Integer.java:542)</span></span><br><span class="line"><span class="comment">// at java.lang.Integer.parseInt(Integer.java:615)</span></span><br><span class="line"><span class="comment">// at Main.process2(Main.java:15)</span></span><br><span class="line"><span class="comment">// at Main.process1(Main.java:11)</span></span><br><span class="line"><span class="comment">// at Main.main(Main.java:4)</span></span><br></pre></td></tr></table></figure><p>通过 <code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="keyword">null</span></span><br><span class="line">at java.lang.Integer.parseInt(Integer.java:<span class="number">542</span>)</span><br><span class="line">at java.lang.Integer.parseInt(Integer.java:<span class="number">615</span>)</span><br><span class="line">at Main.process2(Main.java:<span class="number">15</span>)</span><br><span class="line">at Main.process1(Main.java:<span class="number">11</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在 <code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li>main()调用process1()；</li><li>process1()调用process2()；</li><li>process2()调用Integer.parseInt(String)；</li><li>Integer.parseInt(String)调用Integer.parseInt(String, int)。</li></ol><p>查看 <code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常-2">抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考 <code>Integer.parseInt()</code>方法，抛出异常分两步：</p><ol><li>创建某个Exception的实例；</li><li>用throw语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在 <code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>process2()</code>抛出 <code>NullPointerException</code>后，被 <code>process1()</code>捕获，然后抛出 <code>IllegalArgumentException()</code>。</p><p>如果在 <code>main()</code>中捕获 <code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常 <code>NullPointerException</code>的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的 <code>Exception</code>实例传进去，新的 <code>Exception</code>就可以持有原始 <code>Exception</code>信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印出的异常栈类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:<span class="number">20</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>注意到 <code>Caused by: Xxx</code>，说明捕获的 <code>IllegalArgumentException</code>并不是造成问题的根源，根源在于 <code>NullPointerException</code>，是在 <code>Main.process2()</code>方法抛出的。</p><p>在代码中获取原始异常可以使用 <code>Throwable.getCause()</code>方法。如果返回 <code>null</code>，说明已经是“根异常”了。</p><p>如果我们在 <code>try</code>或者 <code>catch</code>语句块中抛出异常，<code>finally</code>语句会执行</p><h3 id="异常屏蔽">异常屏蔽</h3><p>如果在执行 <code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">at Main.main(Main.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>这说明 <code>finally</code>抛出异常后，原来在 <code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为 <code>“被屏蔽”的异常（Suppressed Exception）</code>。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用 <code>origin</code>变量保存原始异常，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally</code>抛出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>catch</code>和 <code>finally</code>都抛出了异常时，虽然 <code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:<span class="number">11</span>)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">652</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>通过 <code>Throwable.getSuppressed()</code>可以获取所有的 <code>Suppressed Exception</code>。</p><p>绝大多数情况下，在 <code>finally</code>中不要抛出异常。因此，我们通常不需要关心 <code>Suppressed Exception</code></p><h2 id="自定义异常">自定义异常</h2><p>Java标准库定义的常用异常包括：</p><p>Exception<br>│<br>├─ RuntimeException<br>│  │<br>│  ├─ NullPointerException<br>│  │<br>│  ├─ IndexOutOfBoundsException<br>│  │<br>│  ├─ SecurityException<br>│  │<br>│  └─ IllegalArgumentException<br>│     │<br>│     └─ NumberFormatException<br>│<br>├─ IOException<br>│  │<br>│  ├─ UnsupportedCharsetException<br>│  │<br>│  ├─ FileNotFoundException<br>│  │<br>│  └─ SocketException<br>│<br>├─ ParseException<br>│<br>├─ GeneralSecurityException<br>│<br>├─ SQLException<br>│<br>└─ TimeoutException</p><p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p><p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个 <code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code>需要从一个适合的 <code>Exception</code>派生，通常建议从 <code>RuntimeException</code>派生：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从 <code>BaseException</code>派生：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义的 <code>BaseException</code>应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄 <code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h2 id="NullPointerException">NullPointerException</h2><p>在所有的 <code>RuntimeException</code>异常中，Java程序员最熟悉的恐怕就是 <code>NullPointerException</code>了。</p><p><code>NullPointerException</code>即空指针异常，俗称 <code>NPE</code>。如果一个对象为 <code>null</code>，调用其方法或访问其字段就会产生 <code>NullPointerException</code>，这个异常通常是由JVM抛出的，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;&lt;local1&gt;&quot; is null</span></span><br><span class="line"><span class="comment">// at Main.main(Main.java:5)</span></span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，<code>Null Pointer</code>更确切地说是 <code>Null Reference</code>，不过两者区别不大。</p><h3 id="处理NullPointerException">处理NullPointerException</h3><p>如果遇到 <code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code>是一种代码逻辑错误，遇到 <code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用 <code>catch</code>来隐藏这种编码错误</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例: 捕获NullPointerException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    transferMoney(from, to, amount);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的编码习惯可以极大地降低 <code>NullPointerException</code>的产生，例如：</p><p>成员变量在定义时初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用空字符串 <code>&quot;&quot;</code>而不是默认的 <code>null</code>可避免很多 <code>NullPointerException</code>，编写业务逻辑时，用空字符串 <code>&quot;&quot;</code>表示未填写比 <code>null</code>安全得多。</p><p>返回空字符串 <code>&quot;&quot;</code>、空数组而不是 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为 <code>null</code>。</p><p>如果调用方一定要根据 <code>null</code>判断，比如返回 <code>null</code>表示文件不存在，那么考虑返回 <code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过 <code>Optional.isPresent()</code>判断是否有结果。</p><h3 id="定位NullPointerException">定位NullPointerException</h3><p>如果产生了 <code>NullPointerException</code>，例如，调用 <code>a.b.c.x()</code>时产生了 <code>NullPointerException</code>，原因可能是：</p><ul><li>a是null；</li><li>a.b是null；</li><li>a.b.c是null；</li></ul><p>确定到底是哪个对象是 <code>null</code>以前只能打印这样的日志：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure><p>从Java 14开始，如果产生了 <code>NullPointerException</code>，JVM可以给出详细的信息告诉我们null对象到底是谁。我们来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;&lt;local1&gt;.address.city&quot; is null</span></span><br><span class="line"><span class="comment">// at Main.main(Main.java:5)</span></span><br></pre></td></tr></table></figure><p>可以在 <code>NullPointerException</code>的详细信息中看到类似 <code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是 <code>city</code>字段为 <code>null</code>，这样我们就能快速定位问题所在。</p><p>这种增强的 <code>NullPointerException</code>详细信息是 <code>Java 14</code>新增的功能，但默认是关闭的，我们可以给JVM添加一个 <code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><blockquote><p>java -XX:+ShowCodeDetailsInExceptionMessages Main.java</p></blockquote><h2 id="使用断言">使用断言</h2><p><code>断言（Assertion）</code>是一种调试程序的方式。在Java中，使用 <code>assert</code>关键字来实现断言。</p><p>我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 <code>assert x &gt;= 0;</code>即为断言，断言条件 <code>x &gt;= 0</code>预期为 <code>true</code>。如果计算结果为false，则断言失败，抛出 <code>AssertionError</code>。</p><p>使用 <code>assert</code>语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code>会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p><p>实际上并不是这样，因为在运行时默认是关闭 <code>assert</code>的，因为开启 <code>assert</code>校验，也会损耗一定的性能，并且如果在关键部分的校验使用了 <code>assert</code>验证，但是忘记开启 <code>assert</code>功能，那么肯定会造成重大的失误，所以在生产环境下的代码，是不建议使用 <code>assert</code>功能的，一般都是在测试类里面使用的比较多。</p><p>Java断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在程序中使用 <code>assert</code>时，例如，一个简单的断言：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言 <code>x</code>必须大于 <code>0</code>，实际上 <code>x</code>为 <code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code>的值。</p><p>这是因为JVM默认关闭断言指令，即遇到 <code>assert</code>语句就自动忽略了，不执行。</p><p>要执行 <code>assert</code>语句，必须给Java虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -ea Main.java</span><br></pre></td></tr></table></figure><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对 <code>com.itranswarp.sample.Main</code>这个类启用断言。</p><p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个 <code>.</code>），表示对 <code>com.itranswarp.sample</code>这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解 <code>JUnit</code>的使用。</p><h2 id="使用JDK-Logging">使用JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码改好了怎么办？当然是删除没有用的 <code>System.out.println()</code>语句了。</p><p>如果改代码又改出问题怎么办？再加上 <code>System.out.println()</code>。</p><p>反复这么搞几次，很快大家就发现使用 <code>System.out.println()</code>非常麻烦。</p><p>怎么办？</p><p>解决方法是使用日志。</p><p>那什么是日志？日志就是 <code>Logging</code>，它的目的是为了取代 <code>System.out.println()</code>。</p><p>输出日志，而不是用 <code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写&quot;ERROR: &quot; + var；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li><li>可以……</li></ol><p>因为Java标准库内置了日志包 <code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Feb <span class="number">19</span>, <span class="number">2022</span> <span class="number">2</span>:<span class="number">49</span>:<span class="number">26</span> AM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p><p>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的 <code>Logging</code>定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是 INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用Java标准库内置的Logging有以下局限：</p><p><code>Logging</code>系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置；</p><p>配置不太方便，需要在JVM启动时传递参数 <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java标准库内置的 <code>Logging</code>使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p><h2 id="使用Commons-Logging">使用Commons Logging</h2><p>和Java标准库提供的日志不同，<code>Commons Logging</code>是一个第三方日志库，它是由 <code>Apache</code>创建的日志模块。</p><p><code>Commons Logging</code>的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，<code>Commons Loggin</code>自动搜索并使用 <code>Log4j</code>（<code>Log4j</code>是另一个流行的日志系统），如果没有找到 <code>Log4j</code>，再使用 <code>JDK Logging</code>。</p><p>使用 <code>Commons Logging</code>只需要和两个类打交道，并且只有两步：</p><p>第一步，通过 <code>LogFactory</code>获取 <code>Log</code>类的实例； 第二步，使用 <code>Log</code>实例的方法打日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，肯定会得到编译错误，类似 <code>error: package org.apache.commons.logging does not exist</code>（找不到 <code>org.apache.commons.logging</code>这个包）。因为 <code>Commons Logging</code>是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到 <code>commons-logging-1.2.jar</code>这个文件，再把Java源码 <code>Main.java</code>放到一个目录下，例如 <code>work</code>目录：</p><p>work<br>│<br>├─ commons-logging-1.2.jar<br>│<br>└─ Main.java</p><p>然后用 <code>javac</code>编译 <code>Main.java</code>，编译的时候要指定 <code>classpath</code>，不然编译器找不到我们引用的 <code>org.apache.commons.logging</code>包。编译命令如下：</p><blockquote><p>javac -cp commons-logging-1.2.jar Main.java</p></blockquote><p>如果编译成功，那么当前目录下就会多出一个 <code>Main.class</code>文件：</p><p>work<br>│<br>├─ commons-logging-1.2.jar<br>│<br>├─ Main.java<br>│<br>└─ Main.class</p><p>现在可以执行这个 <code>Main.class</code>，使用java命令，也必须指定 <code>classpath</code>，命令如下：</p><blockquote><p>java -cp .;commons-logging-1.2.jar Main</p></blockquote><p>注意到传入的 <code>classpath</code>有两部分：一个是 <code>.</code>，一个是 <code>commons-logging-1.2.jar</code>，用 <code>;</code>分割。<code>.</code>表示当前目录，如果没有这个 <code>.</code>，JVM不会在当前目录搜索 <code>Main.class</code>，就会报错。</p><p>如果在Linux或macOS下运行，注意classpath的分隔符不是 <code>;</code>，而是 <code>:</code>：</p><blockquote><p>java -cp .:commons-logging-1.2.jar Main</p></blockquote><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">15</span>:<span class="number">31</span> PM Main main</span><br><span class="line">INFO: start...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">7</span>:<span class="number">15</span>:<span class="number">31</span> PM Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure><p><code>Commons Logging</code>定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是 <code>INFO</code>。</p><p>使用 <code>Commons Logging</code>时，如果在静态方法中引用 <code>Log</code>，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例方法中引用 <code>Log</code>，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到实例变量log的获取方式是 <code>LogFactory.getLog(getClass())</code>，虽然也可以用 <code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该 <code>log</code>实例。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java类的动态特性，子类获取的log字段实际上相当于 <code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，<code>Commons Logging</code>的日志方法，例如 <code>info()</code>，除了标准的 <code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Log4j">使用Log4j</h2><p>前面介绍了 <code>Commons Logging</code>，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 <code>Log4j</code>。</p><p><code>Log4j</code>是一种非常流行的日志框架，最新版本是2.x。</p><p><code>Log4j</code>是一个组件化设计的日志系统，它的架构大致如下：</p><p><a href="http://log.info">log.info</a>(“User signed in.”);<br>│<br>│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │<br>│   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br>│<br>│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │<br>│   └──────────┘    └──────────┘    └──────────┘    └──────────┘<br>│<br>│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐<br>└──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │<br>└──────────┘    └──────────┘    └──────────┘    └──────────┘</p><p>当我们使用 <code>Log4j</code>输出一条日志时，<code>Log4j</code>自动通过不同的 <code>Appender</code>把同一条日志输出到不同的目的地。例如：</p><ul><li><code>console</code>：输出到屏幕；</li><li><code>file</code>：输出到文件；</li><li><code>socket</code>：通过网络输出到远程计算机；</li><li><code>jdbc</code>：输出到数据库</li></ul><p>在输出日志的过程中，通过 <code>Filter</code>来过滤哪些 <code>log</code>需要被输出，哪些 <code>log</code>不需要被输出。例如，仅输出 <code>ERROR</code>级别的日志。</p><p>最后，通过 <code>Layout</code>来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心 <code>Log4j</code>的 <code>API</code>，而是通过配置文件来配置它。</p><p>以 <code>XML配置</code>为例，使用 <code>Log4j</code>的时候，我们把一个 <code>log4j2.xml</code>的文件放到 <code>classpath</code>下就可以让 <code>Log4j</code>读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然配置 <code>Log4j</code>比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是 <code>INFO</code>级别的日志，会自动输出到屏幕，而 <code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p><p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载 <code>Log4j</code>，解压后，把以下3个jar包放到 <code>classpath</code>中：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为 <code>Commons Logging</code>会自动发现并使用 <code>Log4j</code>，所以，把上一节下载的 <code>commons-logging-1.2.jar</code>也放到 <code>classpath</code>中。</p><p>要打印日志，只需要按 <code>Commons Logging</code>的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">03</span> <span class="number">12</span>:09:<span class="number">45.880</span> [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure><h2 id="使用SLF4J和Logback">使用SLF4J和Logback</h2><p>前面介绍了 <code>Commons Logging</code>和 <code>Log4j</code>这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>有的童鞋可能还听说过 <code>SLF4J</code>和 <code>Logback</code>。这两个东东看上去也像日志，它们又是啥？</p><p>其实 <code>SLF4J</code>类似于 <code>Commons Logging</code>，也是一个日志接口，而 <code>Logback</code>类似于 <code>Log4j</code>，是一个日志的实现。</p><p>为什么有了 <code>Commons Logging</code>和 <code>Log4j</code>，又会蹦出来 <code>SLF4J</code>和 <code>Logback</code>？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对 <code>Commons Logging</code>的接口不满意，有人就搞了 <code>SLF4J</code>。因为对 <code>Log4j</code>的性能不满意，有人就搞了 <code>Logback</code>。</p><p>我们先来看看 <code>SLF4J</code>对 <code>Commons Logging</code>的接口有何改进。在 <code>Commons Logging</code>中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以 <code>SLF4J</code>的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，<code>SLF4J</code>的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用 <code>SLF4J</code>？它的接口实际上和 <code>Commons Logging</code>几乎一模一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 <code>Commons Logging</code>和 <code>SLF4J</code>的接口：</p><table><thead><tr><th>Commons Logging</th><th>SLF4J</th></tr></thead><tbody><tr><td>org.apache.commons.logging.Log</td><td>org.slf4j.Logger</td></tr><tr><td>org.apache.commons.logging.LogFactory</td><td>org.slf4j.LoggerFactory</td></tr></tbody></table><p>不同之处就是 <code>Log</code>变成了 <code>Logger</code>，<code>LogFactory</code>变成了 <code>LoggerFactory</code>。</p><p>使用 <code>SLF4J</code>和 <code>Logback</code>和前面讲到的使用 <code>Commons Logging</code>加 <code>Log4j</code>是类似的，先分别下载<a href="https://www.slf4j.org/download.html">SLF4J</a>和<a href="https://logback.qos.ch/download.html">Logback</a>，然后把以下jar包放到 <code>classpath</code>下：</p><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><p>然后使用 <code>SLF4J</code>的 <code>Logger</code>和 <code>LoggerFactory</code>即可。和 <code>Log4j</code>类似，我们仍然需要一个 <code>Logback</code>的配置文件，把 <code>logback.xml</code>放到 <code>classpath</code>下，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">15</span>:<span class="number">25.328</span> [main] INFO  com.itranswarp.learnjava.Main - Start process...</span><br></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从 <code>Commons Logging</code>加 <code>Log4j</code>转向了 <code>SLF4J</code>加 <code>Logback</code>。</p><h1>反射</h1><p>反射就是 <code>Reflection</code>，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得 <code>Person</code>类，只有一个 <code>Object</code>实例，比如这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？有童鞋会说：强制转型啊！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用 <code>Person</code>类。不然，去掉 <code>import</code>语句，你看能不能编译通过？</p><p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="Class类">Class类</h2><p>除了int等基本类型外，Java的其他类型全部都是 <code>class</code>（包括 <code>interface</code>）。例如：</p><ul><li>String</li><li>Object</li><li>Runnable</li><li>Exception</li><li>…</li></ul><p>仔细思考，我们可以得出结论：<code>class</code>（包括 <code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而 <code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种 <code>class</code>类型时，将其加载进内存。</p><p>每加载一种 <code>class</code>，JVM就为其创建一个 <code>Class</code>类型的实例，并关联起来。注意：这里的 <code>Class</code>类型是一个名叫 <code>Class</code>的 <code>class</code>。它长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>String</code>类为例，当JVM加载 <code>String</code>类时，它首先读取 <code>String.class</code>文件到内存，然后，为 <code>String</code>类创建一个 <code>Class</code>实例并关联起来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure><p>这个 <code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现 <code>Class</code>类的构造方法是 <code>private</code>，只有JVM能创建 <code>Class</code>实例，我们自己的Java程序是无法创建 <code>Class</code>实例的。</p><p>所以，JVM持有的每个 <code>Class</code>实例都指向一个数据类型（<code>class</code>或 <code>interface</code>）：</p><p>┌───────────────────────────┐<br>│      Class Instance       │──────&gt; String<br>├───────────────────────────┤<br>│name = “java.lang.String”  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      Class Instance       │──────&gt; Random<br>├───────────────────────────┤<br>│name = “java.util.Random”  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      Class Instance       │──────&gt; Runnable<br>├───────────────────────────┤<br>│name = &quot;java.lang.Runnable&quot;│<br>└───────────────────────────┘<br>一个 <code>Class</code>实例包含了该class的所有完整信息：</p><p>┌───────────────────────────┐<br>│      Class Instance       │──────&gt; String<br>├───────────────────────────┤<br>│name = “java.lang.String”  │<br>├───────────────────────────┤<br>│package = “java.lang”      │<br>├───────────────────────────┤<br>│super = “java.lang.Object” │<br>├───────────────────────────┤<br>│interface = CharSequence…│<br>├───────────────────────────┤<br>│field = value[],hash,…   │<br>├───────────────────────────┤<br>│method = indexOf()…      │<br>└───────────────────────────┘</p><p>由于JVM为每个加载的 <code>class</code>创建了对应的 <code>Class</code>实例，并在实例中保存了该 <code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code>实例，我们就可以通过这个 <code>Class</code>实例获取到该实例对应的 <code>class</code>的所有信息。</p><p>这种通过 <code>Class</code>实例获取 <code>class</code>信息的方法称为反射 <code>（Reflection)</code>。</p><p>如何获取一个 <code>class</code>的 <code>Class</code>实例？有三个方法：</p><p>方法一：直接通过一个 <code>class</code>的静态变量 <code>class</code>获取：</p><blockquote><p>Class cls = String.class;</p></blockquote><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 <code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个 <code>class</code>的完整类名，可以通过静态方法 <code>Class.forName()</code>获取：</p><blockquote><p>Class cls = Class.forName(“java.lang.String”);</p></blockquote><p>因为 <code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的 <code>Class</code>实例是同一个实例。可以用 <code>==</code>比较两个 <code>Class</code>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下 <code>Class</code>实例比较和 <code>instanceof</code>的差别：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用 <code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code>判断 <code>class实例</code>可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用 <code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 <code>class</code>的时候，我们才使用 <code>==</code>判断 <code>class</code>实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个Object实例时，我们可以通过反射获取该 <code>Object</code>的 <code>class</code>信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从 <code>Class</code>实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br></pre></td></tr></table></figure><p>注意到数组（例如 <code>String[]</code>）也是一种类，而且不同于 <code>String.class</code>，它的类名是 <code>[Ljava.lang.String</code>;。此外，JVM为每一种基本类型如 <code>int</code>也创建了 <code>Class</code>实例，通过 <code>int.class</code>访问。</p><p>如果获取到了一个 <code>Class</code>实例，我们就可以通过该 <code>Class</code>实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于 <code>new String()</code>。通过 <code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用 <code>public</code>的无参数构造方法。带参数的构造方法，或者非 <code>public</code>的构造方法都无法通过 <code>Class.newInstance()</code>被调用。</p><h3 id="动态加载">动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>Main.java</code>时，由于用到了 <code>Main</code>，因此，JVM首先会把 <code>Main.class</code>加载到内存。然而，并不会加载 <code>Person.class</code>，除非程序执行到 <code>create()</code>方法，JVM发现需要加载Person类时，才会首次加载 <code>Person.class</code>。如果没有执行 <code>create()</code>方法，那么 <code>Person.class</code>根本就不会被加载。</p><p>这就是JVM动态加载 <code>class</code>的特性。</p><p>动态加载 <code>class</code>的特性对于Java程序非常重要。利用JVM动态加载 <code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，<code>Commons Logging</code>总是优先使用 <code>Log4j</code>，只有当 <code>Log4j</code>不存在时，才使用JDK的 <code>logging</code>。利用JVM动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问字段">访问字段</h2><p>对任意的一个 <code>Object</code>实例，只要我们获取了它的 <code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过 <code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个<code>public</code>的<code>field</code>（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个<code>field</code>（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有<code>public</code>的<code>field</code>（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有<code>field</code>（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码首先获取 <code>Student</code>的 <code>Class</code>实例，然后，分别获取 <code>public</code>字段、继承的 <code>public</code>字段以及 <code>private</code>字段，打印出的 <code>Field</code>类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.grade</span><br></pre></td></tr></table></figure><p>一个 <code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的<code>bit</code>表示不同的含义。</li></ul><p>以 <code>String</code>类的 <code>value</code>字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="获取字段值">获取字段值</h3><p>利用反射拿到字段的一个 <code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个 <code>Person</code>实例，我们可以先拿到 <code>name</code>字段对应的 <code>Field</code>，再获取这个实例的 <code>name</code>字段的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先获取 <code>Class</code>实例，再获取 <code>Field</code>实例，然后，用 <code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个 <code>IllegalAccessException</code>，这是因为 <code>name</code>被定义为一个 <code>private</code>字段，正常情况下，<code>Main</code>类无法访问 <code>Person</code>类的 <code>private</code>字段。要修复错误，可以将 <code>private</code>改为 <code>public</code>，或者，在调用 <code>Object value = f.get(p);</code>前，先写一句：</p><blockquote><p>f.setAccessible(true);</p></blockquote><p>调用 <code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是 <code>public</code>，一律允许访问。</p><p>可以试着加上上述语句，再运行代码，就可以打印出 <code>private</code>字段的值。</p><p>有童鞋会问：如果使用反射可以获取 <code>private</code>字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过 <code>p.name</code>来访问 <code>Person</code>的 <code>name</code>字段，编译器会根据 <code>public</code>、<code>protected</code>和 <code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在 <code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code>。例如，某个 <code>SecurityManager</code>可能不允许对 <code>java</code>和 <code>javax</code>开头的 <code>package</code>的类调用 <code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="设置字段值">设置字段值</h3><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的 <code>name</code>字段从 <code>Xiao Ming</code>变成了 <code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非 <code>public</code>字段，需要首先调用 <code>setAccessible(true)</code>。</p><h2 id="调用方法">调用方法</h2><p>我们已经能通过 <code>Class</code>实例获取所有 <code>Field</code>对象，同样的，可以通过 <code>Class</code>实例获取所有 <code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取 <code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 <code>Student</code>的 <code>Class</code>实例，然后，分别获取 <code>public</code>方法、继承的 <code>public</code>方法以及 <code>private</code>方法，打印出的 <code>Method</code>类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个 <code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：“getScore”；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个<code>Class</code>实例，例如：String.class；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个<code>Class</code>数组，例如：{String.class, int.class}；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法-2">调用方法</h3><p>当我们获取到一个 <code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用 <code>substring</code>方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>Method</code>实例调用 <code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法">调用静态方法</h3><p>如果获取到的 <code>Method</code>表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code>方法传入的第一个参数永远为 <code>null</code>。我们以 <code>Integer.parseInt(String)</code>为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用非public方法">调用非public方法</h3><p>和 <code>Field</code>类似，对于 <code>非public</code>方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code>。为了调用 <code>非public</code>方法，我们通过 <code>Method.setAccessible(true)</code>允许其调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在 <code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code>。例如，某个 <code>SecurityManager</code>可能不允许对 <code>java</code>和 <code>javax</code>开头的 <code>package</code>的类调用 <code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="多态-3">多态</h3><p>我们来考察这样一种情况：一个 <code>Person</code>类定义了 <code>hello()</code>方法，并且它的子类 <code>Student</code>也覆写了 <code>hello()</code>方法，那么，从 <code>Person.class</code>获取的 <code>Method</code>，作用于 <code>Student</code>实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是 <code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="调用构造方法">调用构造方法</h2><p>我们通常使用 <code>new</code>操作符创建新的实例：</p><blockquote><p>Person p = new Person();</p></blockquote><p>如果通过反射来创建新的实例，可以调用 <code>Class</code>提供的 <code>newInstance()</code>方法：</p><blockquote><p>Person p = Person.class.newInstance();</p></blockquote><p>调用 <code>Class.newInstance()</code>的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过 <code>Class.newInstance()</code>来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了 <code>Constructor</code>对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code>对象和 <code>Method</code>非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>Class</code>实例获取 <code>Constructor</code>的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意 <code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非 <code>public</code>的 <code>Constructor</code>时，必须首先通过 <code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h2 id="获取继承关系">获取继承关系</h2><p>当我们获取到某个 <code>Class</code>对象时，实际上就获取到了一个类的类型：</p><blockquote><p>Class cls = String.class; // 获取到String的Class</p></blockquote><p>还可以用实例的 <code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取Class的方法是通过 <code>Class.forName(&quot;&quot;)</code>，传入 <code>Class</code>的完整类名获取：</p><blockquote><p>Class s = Class.forName(“java.lang.String”);</p></blockquote><p>这三种方式获取的 <code>Class</code>实例都是同一个实例，因为JVM对每个加载的 <code>Class</code>只创建一个 <code>Class</code>实例来表示它的类型。</p><h3 id="获取父类的Class">获取父类的Class</h3><p>有了 <code>Class</code>实例，我们还可以获取它的父类的 <code>Class</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，<code>Integer</code>的父类类型是 <code>Number</code>，<code>Number</code>的父类是 <code>Object</code>，<code>Object</code>的父类是 <code>null</code>。除 <code>Object</code>外，其他任何非 <code>interface</code>的 <code>Class</code>都必定存在一个父类类型</p><h3 id="获取interface">获取interface</h3><p>由于一个类可能实现一个或多个接口，通过 <code>Class</code>我们就可以查询到实现的接口类型。例如，查询 <code>Integer</code>实现的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码可知，<code>Integer</code>实现的接口有：</p><ul><li>java.lang.Comparable</li><li>java.lang.constant.Constable</li><li>java.lang.constant.ConstantDesc</li></ul><p>要特别注意： <code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integer</code>的父类是 <code>Number</code>，<code>Number</code>实现的接口是 <code>java.io.Serializable</code>。</p><p>此外，对所有 <code>interface</code>的 <code>Class</code>调用 <code>getSuperclass()</code>返回的是 <code>null</code>，获取接口的父接口要用 <code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); <span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); <span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何 <code>interface</code>，那么 <code>getInterfaces()</code>返回空数组。</p><h3 id="继承关系">继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用 <code>instanceof</code>操作符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个 <code>Class</code>实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h2 id="动态处理">动态处理</h2><p>我们来比较Java的 <code>class</code>和 <code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）；</li><li>不能实例化<code>interface</code>。</li></ul><p>所有 <code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p><blockquote><p>CharSequence cs = new StringBuilder();</p></blockquote><p>有没有可能不编写实现类，直接在运行期创建某个 <code>interface</code>的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个 <code>interface</code>的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>还有一种方式是动态代码，我们仍然先定义了接口 <code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个 <code>Proxy.newProxyInstance()</code>创建了一个 <code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public abstract void Hello.morning(java.lang.String)</span></span><br><span class="line"><span class="comment">// Good morning, Bob</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在运行期动态创建一个 <code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h1>注解</h1><p>本节我们将介绍Java程序的一种特殊“注释”——<code>注解（Annotation）</code></p><h2 id="使用注解">使用注解</h2><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><h3 id="注解的作用">注解的作用</h3><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><p>Java的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li>@Override：让编译器检查该方法是否正确地实现了覆写；</li><li>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入 <code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理 <code>.class</code>文件使用的注解，比如有些工具会在加载 <code>class</code>的时候，对 <code>class</code>做动态修改，实现一些特殊的功能。这类注解会被编译进入 <code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了 <code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p><p>此外，大部分注解会有一个名为 <code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了 <code>value</code>参数。</p><p>如果只写注解，相当于全部使用默认值。</p><p>举个栗子，对以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Check</code>就是一个注解。第一个 <code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个 <code>@Check(value=99)</code>只定义了一个 <code>value</code>参数，它实际上和 <code>@Check(99)</code>是完全一样的。最后一个 <code>@Check</code>表示所有参数都使用默认值。</p><h2 id="定义注解">定义注解</h2><p>Java语言使用 <code>@interface</code>语法来定义 <code>注解（Annotation）</code>，它的格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的参数类似无参数方法，可以用 <code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为 <code>value</code>。</p><h3 id="元注解">元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为 <code>元注解（meta annotation）</code>。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="Target">@Target</h4><p>最常用的元注解是 <code>@Target</code>。使用 <code>@Target</code>可以定义 <code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解 <code>@Report</code>可用在方法上，我们必须添加一个 <code>@Target(ElementType.METHOD)</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义注解 <code>@Report</code>可用在方法或字段上，可以把 <code>@Target</code>注解参数变为数组 <code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <code>@Target</code>定义的 <code>value</code>是 <code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p><h4 id="Retention">@Retention</h4><p>另一个重要的元注解 <code>@Retention</code>定义了 <code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p>如果 <code>@Retention</code>不存在，则该 <code>Annotation</code>默认为 <code>CLASS</code>。因为通常我们自定义的 <code>Annotation</code>都是 <code>RUNTIME</code>，所以，务必要加上 <code>@Retention(RetentionPolicy.RUNTIME</code>)这个元注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repeatable">@Repeatable</h4><p>使用 <code>@Repeatable</code>这个元注解可以定义 <code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 <code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个@Report注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inherited">@Inherited</h4><p>用 <code>@Inherited</code>定义子类是否可继承父类定义的 <code>Annotation</code>。<code>@Inherited</code>仅针对 <code>@Target(ElementType.TYPE)</code>类型的 <code>annotation</code>有效，并且仅针对 <code>class</code>的继承，对 <code>interface</code>的继承无效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候，如果一个类用到了 <code>@Report</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则它的子类默认也定义了该注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何定义Annotation">如何定义Annotation</h3><p>我们总结一下定义Annotation的步骤：</p><p>第一步，用@interface定义注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把最常用的参数定义为 <code>value()</code>，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置 <code>@Target</code>和 <code>@Retention</code>，<code>@Retention</code>一般设置为 <code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写 <code>@Inherited</code>和 <code>@Repeatable</code>。</p><h2 id="处理注解">处理注解</h2><p>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</p><ul><li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有 <code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p><p>因此，我们只讨论如何读取RUNTIME类型的注解。</p><p>因为注解定义后也是一种 <code>class</code>，所有的注解都继承自 <code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p><p>Java提供的使用反射API读取 <code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于 <code>Class</code>、<code>Field</code>、<code>Method</code>或 <code>Constructor</code>：</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.getAnnotation(Class)</span><br><span class="line">Field.getAnnotation(Class)</span><br><span class="line">Method.getAnnotation(Class)</span><br><span class="line">Constructor.getAnnotation(Class)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">int</span> type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure><p>使用 <code>反射API</code>读取 <code>Annotation</code>有两种方法。方法一是先判断 <code>Annotation</code>是否存在，如果存在，就直接读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是直接读取 <code>Annotation</code>，如果 <code>Annotation</code>不存在，将返回 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取方法、字段和构造方法的 <code>Annotation</code>和 <code>Class</code>类似。但要读取方法参数的 <code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要读取方法参数的注解，我们先用反射获取 <code>Method</code>实例，然后读取方法参数的所有注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line">Method m = ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        Range r = (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        NotNull n = (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用注解-2">使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，<code>JUnit</code>是一个测试框架，它会自动运行所有标记为 <code>@Test</code>的方法。</p><p>我们来看一个 <code>@Range</code>注解，我们希望用它来定义一个 <code>String</code>字段的规则：字段长度满足 <code>@Range</code>的参数定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某个JavaBean中，我们可以使用该注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查 <code>Person</code>实例的 <code>String</code>字段长度是否满足 <code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们通过 <code>@Range</code>注解，配合 <code>check()</code>方法，就可以完成 <code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p><h1>泛型</h1><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p><h2 id="什么是泛型">什么是泛型</h2><p>在讲解什么是泛型之前，我们先观察Java标准库提供的 <code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上 <code>ArrayList</code>内部就是一个 <code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述 <code>ArrayList</code>存储 <code>String</code>类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">很容易出现ClassCastException，因为容易“误转型”：</span><br><span class="line"></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以为 <code>String</code>单独编写一种 <code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringArrayList list = <span class="keyword">new</span> StringArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p>问题暂时解决。</p><p>然而，新的问题是，如果要存储 <code>Integer</code>，还需要为 <code>Integer</code>单独编写一种ArrayList：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，还需要为其他所有class单独编写一种ArrayList：</p><ul><li>LongArrayList</li><li>DoubleArrayList</li><li>PersonArrayList</li><li>…</li></ul><p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p><p>为了解决新的问题，我们必须把 <code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code>可以是任何 <code>class</code>。这样一来，我们就实现了：编写一次模版，可以创建任意类型的 <code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如 <code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的 <code>ArrayList&lt;类型&gt;</code>：</p><blockquote><p>ArrayList<code>&lt;String&gt;</code> strList = new ArrayList<code>&lt;String&gt;</code>();</p></blockquote><p>由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h3 id="向上转型-2">向上转型</h3><p>在Java标准库中的 <code>ArrayList&lt;T&gt;</code>实现了 <code>List&lt;T&gt;</code>接口，它可以向上转型为 <code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>即类型 <code>ArrayList&lt;T&gt;</code>可以向上转型为 <code>List&lt;T&gt;</code>。</p><p>要特别注意：不能把 <code>ArrayList&lt;Integer&gt;</code>向上转型为 <code>ArrayList&lt;Number&gt;</code>或 <code>List&lt;Number&gt;</code>。</p><p>这是为什么呢？假设 <code>ArrayList&lt;Integer&gt;</code>可以向上转型为 <code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> Float(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line">Integer n = integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure><p>我们把一个 <code>ArrayList&lt;Integer&gt;</code>转型为 <code>ArrayList&lt;Number&gt;</code>类型后，这个 <code>ArrayList&lt;Number&gt;</code>就可以接受Float类型，因为Float是Number的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和 <code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是 <code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受Float类型， 所以在获取Integer的时候将产生 <code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把 <code>ArrayList&lt;Integer&gt;</code>转型为 <code>ArrayList&lt;Number&gt;</code>。</p><h2 id="使用泛型">使用泛型</h2><p>使用 <code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是 <code>Object</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把 <code>&lt;T&gt;</code>当作 <code>Object</code>使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型 <code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型 <code>List&lt;String&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们定义泛型类型 <code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型 <code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br><span class="line">Number first = list.get(<span class="number">0</span>);</span><br><span class="line">Number second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><blockquote><p>List<code>&lt;Number&gt;</code> list = new ArrayList<code>&lt;Number&gt;</code>();</p></blockquote><p>编译器看到泛型类型 <code>List&lt;Number&gt;</code>就可以自动推断出后面的 <code>ArrayList&lt;T&gt;</code>的泛型类型必须是 <code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型接口">泛型接口</h3><p>除了 <code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现 <code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接对 <code>String</code>数组进行排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(ss);</span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 <code>String</code>本身已经实现了 <code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的 <code>Person</code>类型试试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将 <code>Person</code>转型为 <code>Comparable</code>。我们修改代码，让 <code>Person</code>实现 <code>Comparable&lt;T&gt;</code>接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Alice,88, Bob,61, Lily,75]</span></span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按 <code>name</code>进行排序。</p><p>也可以修改比较逻辑，例如，按 <code>score</code>从高到低排序。请自行修改测试。</p><h2 id="编写泛型">编写泛型</h2><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如 <code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是 <code>String</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，把特定类型 <code>String</code>替换为 <code>T</code>，并申明 <code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练后即可直接从T开始编写。</p><h3 id="静态方法-2">静态方法</h3><p>编写泛型类时，要特别注意，泛型类型 <code>&lt;T&gt;</code>不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。</p><p>有些同学在网上搜索发现，可以在 <code>static</code>修饰符后面加一个 <code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这个 <code>&lt;T&gt;</code>和 <code>Pair&lt;T&gt;</code>类型的 <code>&lt;T&gt;</code>已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的 <code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h3 id="多个泛型类型">多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;<code>T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><blockquote><p>Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(“test”, 123);</p></blockquote><p>Java标准库的 <code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h2 id="擦拭法">擦拭法</h2><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>例如，我们编写了一个泛型类 <code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li><li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为 <code>Object</code>处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如 <code>int</code>，因为实际类型是 <code>Object</code>，<code>Object</code>类型无法持有基本类型：</p><p>局限二：无法取得带泛型的Class。观察以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是Object，我们对Pair<code>&lt;String&gt;</code>和Pair<code>&lt;Integer&gt;</code>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</p><p>换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<code>&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在 <code>Pair&lt;String&gt;.class</code>，而是只有唯一的 <code>Pair.class</code>。</p><p>局限四：不能实例化 <code>T</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建 <code>new Pair&lt;String&gt;()</code>和创建n <code>ew Pair&lt;Integer&gt;()</code>就全部成了Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化 <code>T</code>类型，我们必须借助额外的 <code>Class&lt;T&gt;</code>参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助 <code>Class&lt;T&gt;</code>参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code>。例如：</p><blockquote><p>Pair<code>&lt;String&gt;</code> pair = new Pair&lt;&gt;(String.class);</p></blockquote><p>因为传入了 <code>Class&lt;String&gt;</code>的实例，所以我们借助 <code>String.class</code>就可以实例化 <code>String</code>类型。</p><h3 id="不恰当的覆写方法">不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的 <code>equals(T t)</code>方法实际上会被擦拭成 <code>equals(Object t)</code>，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与 <code>Object.equals(Object)</code>的冲突就可以成功编译：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">same</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承">泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code>，子类的类型是 <code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类 <code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p><blockquote><p>IntPair ip = new IntPair(1, 2);</p></blockquote><p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code>的T类型，即给定一个变量 <code>Pair&lt;Integer&gt; p</code>，无法从 <code>p</code>中获取到 <code>Integer</code>类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型T（对 <code>IntPair</code>来说，也就是 <code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道 <code>IntPair</code>只能存取 <code>Integer</code>这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Java引入了泛型，所以，只用Class来标识类型已经不够了。实际上，Java的类型系统结构如下：<br>┌────┐<br>│Type│<br>└────┘<br>▲<br>│<br>┌────────────┬────────┴─────────┬───────────────┐<br>│            │                  │               │<br>┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐<br>│Class││ParameterizedType││GenericArrayType││WildcardType│<br>└─────┘└─────────────────┘└────────────────┘└────────────┘</p><h2 id="extends通配符">extends通配符</h2><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是 <code>Pair&lt;Number&gt;</code>的子类。</p><p>假设我们定义了 <code>Pair&lt;T&gt;</code>：</p><blockquote><p>public class Pair<code>&lt;T&gt;</code> { … }</p></blockquote><p>然后，我们又针对 <code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是 <code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><blockquote><p>int sum = PairHelper.add(new Pair<code>&lt;Number&gt;</code>(1, 2));</p></blockquote><p>注意：传入的类型是 <code>Pair&lt;Number&gt;</code>，实际参数类型是 <code>(Integer, Integer)</code>。</p><p>既然实际参数是 <code>Integer</code>类型，试试传入 <code>Pair&lt;Integer&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，会得到一个编译错误：</p><blockquote><p>incompatible types: Pair<code>&lt;Integer&gt;</code> cannot be converted to Pair<code>&lt;Number&gt;</code></p></blockquote><p>原因很明显，因为 <code>Pair&lt;Integer&gt;</code>不是 <code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型 <code>Pair&lt;Integer&gt;</code>。</p><p>但是从 <code>add()</code>方法的代码可知，传入 <code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p><blockquote><p>Number first = p.getFirst();<br>Number last = p.getLast();</p></blockquote><p>实际类型是 <code>Integer</code>，引用类型是 <code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入 <code>Pair&lt;Number&gt;</code>。</p><p>有没有办法使得方法参数接受 <code>Pair&lt;Integer&gt;</code>？办法是有的，这就是使用 <code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为 <code>Number</code>或 <code>Number</code>子类的 <code>Pair</code>类型。我们把代码改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，给方法传入 <code>Pair&lt;Integer&gt;</code>类型时，它符合参数 <code>Pair&lt;? extends Number&gt;</code>类型。这种使用 <code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型 <code>T</code>的上界限定在 <code>Number</code>了。</p><p>除了可以传入 <code>Pair&lt;Integer&gt;</code>类型，我们还可以传入 <code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为 <code>Double</code>和 <code>BigDecimal</code>都是Number的子类。</p><p>如果我们考察对 <code>Pair&lt;? extends Number&gt;</code>类型调用 <code>getFirst()</code>方法，实际的方法签名变成了：</p><blockquote><? extends Number> getFirst();</blockquote><p>即返回值是 <code>Number</code>或 <code>Number</code>的子类，因此，可以安全赋值给 <code>Number</code>类型的变量：</p><blockquote><p>Number x = p.getFirst();</p></blockquote><p>然后，我们不可预测实际类型就是 <code>Integer</code>，例如，下面的代码是无法通过编译的：</p><blockquote><p>Integer x = p.getFirst();</p></blockquote><p>这是因为实际的返回类型可能是 <code>Integer</code>，也可能是 <code>Double</code>或者其他类型，编译器只能确定类型一定是 <code>Number</code>的子类（包括 <code>Number</code>类型本身），但具体类型无法确定。</p><p>我们再来考察一下 <code>Pair&lt;T&gt;</code>的 <code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        p.setFirst(<span class="keyword">new</span> Integer(first.intValue() + <span class="number">100</span>));</span><br><span class="line">        p.setLast(<span class="keyword">new</span> Integer(last.intValue() + <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，我们会得到一个编译错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">incompatible types: Integer cannot be converted to CAP#<span class="number">1</span></span><br><span class="line">where CAP#<span class="number">1</span> is a fresh type-variable:</span><br><span class="line">    CAP#<span class="number">1</span> extends Number from capture of ? extends Number</span><br></pre></td></tr></table></figure><p>编译错误发生在 <code>p.setFirst()</code>传入的参数是Integer类型。有些童鞋会问了，既然p的定义是 <code>Pair&lt;? extends Number&gt;</code>，那么 <code>setFirst(? extends Number)</code>为什么不能传入Integer？</p><p>原因还在于擦拭法。如果我们传入的 <code>p</code>是 <code>Pair&lt;Double&gt;</code>，显然它满足参数定义 <code>Pair&lt;? extends Number</code>&gt;，然而，<code>Pair&lt;Double&gt;</code>的setFirst()显然无法接受Integer类型。</p><p>这就 <code>是&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名 <code>setFirst(? extends Number)</code>无法传递任何Number的子类型给 <code>setFirst(? extends Number)</code>。</p><p>这里唯一的例外是可以给方法参数传入 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.setFirst(<span class="keyword">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure><h3 id="extends通配符的作用">extends通配符的作用</h3><p>如果我们考察Java标准库的 <code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 获取个数</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 根据索引获取指定元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>; <span class="comment">// 添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span></span>; <span class="comment">// 删除一个已有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们定义一个方法来处理列表的每个元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">        Integer n = list.get(i);</span><br><span class="line">        sum = sum + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们定义的方法参数类型是 <code>List&lt;? extends Integer&gt;</code>而不是 <code>List&lt;Integer&gt;</code>？从方法内部代码看，传入 <code>List&lt;? extends Integer&gt;</code>或者 <code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到 <code>List&lt;? extends Integer&gt;</code>的限制：</p><ul><li>允许调用<code>get()</code>方法获取Integer的引用；</li><li>不允许调用<code>set(? extends Integer)</code>方法并传入任何Integer的引用（null除外）。</li></ul><p>因此，方法参数类型 <code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取 <code>List</code>的元素，不会修改 <code>List</code>的元素（因为无法调用 <code>add(? extends Integer)、remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数 <code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用 <code>set(null)</code>除外）。</p><h3 id="使用extends限定T类型">使用extends限定T类型</h3><p>在定义泛型类型 <code>Pair&lt;T&gt;</code>的时候，也可以使用extends通配符来限定T的类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>现在，我们只能定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Number&gt; p1 = <span class="keyword">null</span>;</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Pair&lt;Double&gt; p3 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>因为 <code>Number</code>、<code>Integer</code>和 <code>Double</code>都符合 <code>&lt;T extends Number&gt;</code>。</p><p>非 <code>Number</code>类型将无法通过编译：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br><span class="line">Pair&lt;Object&gt; p2 = <span class="keyword">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>因为 <code>String</code>、<code>Object</code>都不符合 <code>&lt;T extends Number&gt;</code>，因为它们不是 <code>Number</code>类型或 <code>Number</code>的子类。</p><h1>集合</h1><p>本节我们将介绍Java的集合类型。集合类型也是Java标准库中被使用最多的类型。</p><h2 id="Java集合简介">Java集合简介</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。例如，5只小兔构成的集合：</p><p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</p><p>│   (_(\     (_/)     (_/)     (_/)      ((\   │<br>( -.-)    (•.•)     (&gt;.&lt;)     (^.^)     (=‘.’)<br>│  C(“)<em>(“)  (”)</em>(”)   (“)<em>(“)   (”)</em>(”)   O(_“)”)  │</p><p>└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘<br>在数学中，我们经常遇到集合的概念。例如：</p><ul><li><p>有限集合：</p><ul><li>一个班所有的同学构成的集合；</li><li>一个网站所有的商品构成的集合；</li><li>…</li></ul></li><li><p>无限集合：</p><ul><li>全体自然数集合：1，2，3，……</li><li>有理数集合；</li><li>实数集合；</li><li>…</li></ul></li></ul><p>为什么要在计算机中引入集合呢？这是为了便于处理一组类似的数据，例如：</p><ul><li>计算所有同学的总成绩和平均成绩；</li><li>列举所有的商品名称和价格；</li><li>……</li></ul><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line">String first = ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p><ul><li>数组初始化后大小不可变；</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表；</li><li>保证无重复元素的集合；</li><li>…</li></ul><h3 id="Collection">Collection</h3><p>Java标准库自带的 <code>java.util</code>包提供了集合类：<code>Collection</code>，它是除Map外所有其他集合类的根接口。Java的 <code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种通过键值（<code>key-value</code>）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li></ul><p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是 <code>List</code>，具体的实现类有 <code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><blockquote><p>List<code>&lt;String&gt;</code> list = new ArrayList&lt;&gt;(); // 只能放入String类型</p></blockquote><p>最后，Java访问集合总是通过统一的方式——迭代器（<code>Iterator</code>）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li></ul><h2 id="使用List">使用List</h2><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p><p><code>List</code>的行为和数组几乎完全相同：List内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从 <code>0</code>开始。</p><p>数组和 <code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组 <code>&#123;'A', 'B', 'C', 'D', 'E'&#125;</code>中删除索引为2的元素：</p><p>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>│   │<br>┌───┘   │<br>│   ┌───┘<br>│   │<br>▼   ▼<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ D │ E │   │   │<br>└───┴───┴───┴───┴───┴───┘<br>这个“删除”操作实际上是把 <code>'C'</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p><p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是 <code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个 <code>ArrayList</code>拥有5个元素，实际数组大小为6（即有一个空位）：</p><p>size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>当添加一个元素并指定索引到 <code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p><p>size=5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │   │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br>然后，往内部指定索引的数组位置添加一个元素，然后把 <code>size</code>加 <code>1</code>：</p><p>size=6<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p><p>size=6<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时 <code>size</code>加 <code>1</code>：</p><p>size=7<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。</p><p>我们考察 <code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>删除指定索引的元素：<code>E remove(int index)</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li></ul><p>但是，实现 <code>List</code>接口并非只能通过数组（即 <code>ArrayList</code>的实现方式）来实现，另一种 <code>LinkedList</code>通过“链表”也实现了 <code>List</code>接口。在 <code>LinkedList</code>中，它的内部每个元素都指向下一个元素：<br>┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>└───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br>我们来比较一下 <code>ArrayList</code>和 <code>LinkedList</code>：</p><p>|ArrayList|LinkedList|<br>|获取指定元素|速度很快|需要从头开始查找元素|<br>|添加元素到末尾|速度很快|速度很快|<br>|在指定位置添加/删除|需要移动元素|不需要移动元素|<br>|内存占用|少|较大|</p><p>通常情况下，我们总是优先使用 <code>ArrayList</code>。</p><h3 id="List的特点">List的特点</h3><p>使用List时，我们要关注List接口的规范。List接口允许我们添加重复的元素，即List内部的元素可以重复：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 允许重复添加元素，size=3</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List</code>还允许添加 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">        list.add(<span class="keyword">null</span>); <span class="comment">// size=2</span></span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=3</span></span><br><span class="line">        String second = list.get(<span class="number">1</span>); <span class="comment">// null</span></span><br><span class="line">        System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建List">创建List</h3><p>除了使用 <code>ArrayList</code>和 <code>LinkedList</code>，我们还可以通过 <code>List</code>接口提供的 <code>of()</code>方法，根据给定元素快速创建 <code>List</code>：</p><blockquote><p>List<code>&lt;Integer&gt;</code> list = List.of(1, 2, 5);</p></blockquote><p>但是 <code>List.of()</code>方法不接受 <code>null</code>值，如果传入 <code>null</code>，会抛出 <code>NullPointerException</code>异常。</p><h3 id="遍历List">遍历List</h3><p>和数组类型，我们要遍历一个 <code>List</code>，完全可以用 <code>for</code>循环根据索引配合·方法遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方式并不推荐，一是代码复杂，二是因为 <code>get(int)</code>方法只有 <code>ArrayList</code>的实现是高效的，换成 <code>LinkedList</code>后，索引越大，访问速度越慢。</p><p>所以我们要始终坚持使用迭代器 <code>Iterator</code>来访问 <code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由 <code>List</code>的实例调用 <code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个 <code>List</code>，并且不同的 <code>List</code>类型，返回的 <code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p><p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用 <code>Iterator</code>遍历 <code>List</code>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有童鞋可能觉得使用 <code>Iterator</code>访问 <code>List</code>的代码比使用索引更复杂。但是，要记住，通过 <code>Iterator</code>遍历 <code>List</code>永远是最高效的方式。并且，由于 <code>Iterator</code>遍历是如此常用，所以，Java的 <code>for each</code>循环本身就可以帮我们使用 <code>Iterator</code>遍历。把上面的代码再改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是我们编写遍历 <code>List</code>的常见代码。</p><p>实际上，只要实现了 <code>Iterable</code>接口的集合类都可以直接用 <code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把 <code>for each</code>循环变成 <code>Iterator</code>的调用，原因就在于 <code>Iterable</code>接口定义了一个 <code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个 <code>Iterator</code>实例。</p><h3 id="List和Array转换">List和Array转换</h3><p>把 <code>List</code>变为 <code>Array</code>有三种方法，第一种是调用 <code>toArray()</code>方法直接返回一个 <code>Object[]</code>数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        Object[] array = list.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会丢失类型信息，所以实际应用很少。</p><p>第二种方式是给 <code>toArray(T[])</code>传入一个类型相同的 <code>Array</code>，<code>List</code>内部自动把元素复制到传入的 <code>Array</code>中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个 <code>toArray(T[])</code>方法的泛型参数 <code>&lt;T&gt;</code>并不是 <code>List</code>接口定义的泛型参数 <code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入 <code>Number</code>类型的数组，返回的仍然是 <code>Number</code>类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Number[] array = list.toArray(<span class="keyword">new</span> Number[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于List的元素是 <code>Integer</code>，所以无法放入 <code>String</code>数组，这个方法会抛出 <code>ArrayStoreException</code>。</p><p>如果我们传入的数组大小和 <code>List</code>实际的  元素个数不一致怎么办？根据<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray%28T%5B%5D%29">List接口</a>的文档，我们可以知道：</p><p>如果传入的数组不够大，那么 <code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比 <code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充 <code>null</code>。</p><p>实际上，最常用的是传入一个“恰好”大小的数组：</p><blockquote><p>Integer[] array = list.toArray(new Integer[list.size()]);</p></blockquote><p>最后一种更简洁的写法是通过 <code>List</code>接口定义的 <code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p><blockquote><p>Integer[] array = list.toArray(Integer[]::new);</p></blockquote><p>这种函数式写法我们会在后续讲到。</p><p>反过来，把Array变为List就简单多了，通过 <code>List.of(T...)</code>方法最简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure><p>对于JDK 11之前的版本，可以使用 <code>Arrays.asList(T...)</code>方法把数组转换成List。</p><p>要注意的是，返回的List不一定就是 <code>ArrayList</code>或者 <code>LinkedList</code>，因为List只是一个接口，如果我们调用 <code>List.of()</code>，它返回的是一个只读List：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        list.add(<span class="number">999</span>); <span class="comment">// UnsupportedOperationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对只读 <code>List</code>调用 <code>add()</code>、<code>remove()</code>方法会抛出 <code>UnsupportedOperationException</code>。</p><h2 id="编写equals方法">编写equals方法</h2><p>我们知道 <code>List</code>是一种有序链表：<code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。</p><p>List还提供了 <code>boolean contains(Object o)</code>方法来判断 <code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回 <code>-1</code>。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;C&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;X&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;X&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们注意一个问题，我们往 <code>List</code>中添加的 <code>&quot;C&quot;</code>和调用 <code>contains(&quot;C&quot;)</code>传入的 <code>&quot;C&quot;</code>是不是同一个实例？</p><p>如果这两个 <code>&quot;C&quot;</code>不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> String(<span class="string">&quot;C&quot;</span>))); <span class="comment">// true or false?</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="keyword">new</span> String(<span class="string">&quot;C&quot;</span>))); <span class="comment">// 2 or -1?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们传入的是 <code>new String(&quot;C&quot;)</code>，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？</p><p>因为List内部并不是通过 <code>==</code>判断两个元素是否相等，而是使用 <code>equals()</code>方法判断两个元素是否相等，例如 <code>contains()</code>方法可以实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementData.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，要正确使用 <code>List</code>的 <code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写 <code>equals()</code>方法，否则，放进去的实例，查找不到。我们之所以能正常放入 <code>String</code>、<code>Integer</code>这些对象，是因为Java标准库定义的这些类已经正确实现了 <code>equals()</code>方法。</p><p>我们以 <code>Person</code>对象为例，测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，虽然放入了 <code>new Person(&quot;Bob&quot;)</code>，但是用另一个 <code>new Person(&quot;Bob&quot;)</code>查询不到，原因就是 <code>Person</code>类没有覆写 <code>equals()</code>方法。</p><h3 id="编写equals">编写equals</h3><p>如何正确编写 <code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p><ul><li>自反性（Reflexive）：对于非<code>null</code>的x来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>对称性（Symmetric）：对于非<code>null</code>的x和y来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>传递性（Transitive）：对于非<code>null</code>的x、y和z来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么x.equals(z)也必须为true；</li><li>一致性（Consistent）：对于非<code>null</code>的x和y来说，只要x和y状态不变，则<code>x.equals(y)</code>总是一致地返回true或者<code>false</code>；</li><li>对null的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><p>上述规则看上去似乎非常复杂，但其实代码实现 <code>equals()</code>方法是很简单的，我们以 <code>Person</code>类为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们要定义“相等”的逻辑含义。对于 <code>Person</code>类，如果 <code>name</code>相等，并且age相等，我们就认为两个 <code>Person</code>实例相等。</p><p>因此，编写 <code>equals()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于引用字段比较，我们使用 <code>equals()</code>，对于基本类型字段的比较，我们使用 <code>==</code>。</p><p>如果 <code>this.name</code>为 <code>null</code>，那么 <code>equals()</code>方法会报错，因此，需要继续改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">boolean</span> nameEquals = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; p.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nameEquals &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用 <code>Objects.equals()</code>静态方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们总结一下 <code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>使用 <code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断 <code>null</code>的麻烦。两个引用类型都是 <code>null</code>时它们也是相等的。</p><p>如果不调用 <code>List</code>的 <code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现 <code>equals()</code>方法。</p><h2 id="使用Map">使用Map</h2><p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生 <code>Student</code>实例的 <code>List</code>，要在 <code>List</code>中根据 <code>name</code>查找某个指定的 <code>Student</code>的分数，应该怎么办？</p><p>最简单的方法是遍历 <code>List</code>并判断 <code>name</code>是否相等，然后返回指定元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; list = ...</span><br><span class="line">Student target = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;Xiao Ming&quot;</span>.equals(s.name)) &#123;</span><br><span class="line">        target = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(target.score);</span><br></pre></td></tr></table></figure><p>这种需求其实非常常见，即通过一个键去查询对应的值。使用 <code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而 <code>Map</code>这种键值 <code>（key-value）</code>映射表的数据结构，作用就是能高效通过 <code>key</code>快速查找 <code>value</code>（元素）。</p><p>用 <code>Map</code>来实现根据 <code>name</code>查询某个 <code>Student</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">        Student target = map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        Student another = map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用 <code>put(K key, V value)</code>方法时，就把 <code>key</code>和 <code>value</code>做了映射并放入Map。当我们调用 <code>V get(K key)</code>时，就可以通过 <code>key</code>获取到对应的 <code>value</code>。如果 <code>key</code>不存在，则返回 <code>null</code>。和 <code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是 <code>HashMap</code>。</p><p>如果只是想查询某个 <code>key</code>是否存在，可以调用 <code>boolean containsKey(K key)</code>方法。</p><p>如果我们在存储Map映射关系的时候，对同一个 <code>key</code>调用两次 <code>put()</code>方法，分别放入不同的 <code>value</code>，会有什么问题呢？例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">789</span>); <span class="comment">// 再次放入apple作为key，但value变为789</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 789</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复放入 <code>key-value</code>并不会有任何问题，但是一个 <code>key</code>只能关联一个 <code>value</code>。在上面的代码中，一开始我们把 <code>key</code>对象 <code>&quot;apple&quot;</code>映射到 <code>Integer</code>对象 <code>123</code>，然后再次调用 <code>put()</code>方法把 <code>&quot;apple&quot;</code>映射到 <code>789</code>，这时，原来关联的 <code>value</code>对象 <code>123</code>就被“冲掉”了。实际上，<code>put()</code>方法的签名是 <code>V put(K key, V value)</code>，如果放入的 <code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的 <code>value</code>，否则，返回 <code>null</code>。</p><div class="note warning simple"><p>始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉.</p></div><p>此外，在一个 <code>Map</code>中，虽然 <code>key</code>不能重复，但 <code>value</code>是可以重复的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">123</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="遍历Map">遍历Map</h3><p>对 <code>Map</code>来说，要遍历 <code>key</code>可以使用 <code>for each</code>循环遍历 <code>Map</code>实例的 <code>keySet()</code>方法返回的 <code>Set</code>集合，它包含不重复的 <code>key</code>的集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时遍历 <code>key</code>和 <code>value</code>可以使用 <code>for each</code>循环遍历 <code>Map</code>对象的 <code>entrySet()</code>集合，它包含每一个 <code>key-value</code>映射：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>和 <code>List</code>不同的是，<code>Map</code>存储的是 <code>key-value</code>的映射关系，并且，它 <code>不保证顺序</code>。在遍历的时候，遍历的顺序既不一定是 <code>put()</code>时放入的 <code>key</code>的顺序，也不一定是 <code>key</code>的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以 <code>HashMap</code>为例，假设我们放入 <code>&quot;A&quot;，&quot;B&quot;，&quot;C&quot;</code>这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的</p><div class="note warning simple"><p>遍历Map时，不可假设输出的key是有序的！</p></div><h2 id="编写equals和hashCode">编写equals和hashCode</h2><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p><p>以HashMap为例，观察下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Jun&quot;</span>));</span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>); <span class="comment">// Person(&quot;Xiao Ming&quot;)</span></span><br><span class="line">map.get(<span class="string">&quot;x&quot;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><code>HashMap</code>之所以能根据 <code>key</code>直接拿到 <code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有 <code>value</code>，并根据key直接计算出 <code>value</code>应该存储在哪个索引：</p><p>┌───┐<br>0 │   │<br>├───┤<br>1 │ ●─┼───&gt; Person(“Xiao Ming”)<br>├───┤<br>2 │   │<br>├───┤<br>3 │   │<br>├───┤<br>4 │   │<br>├───┤<br>5 │ ●─┼───&gt; Person(“Xiao Hong”)<br>├───┤<br>6 │ ●─┼───&gt; Person(“Xiao Jun”)<br>├───┤<br>7 │   │<br>└───┘<br>如果 <code>key</code>的值为 <code>&quot;a&quot;</code>，计算得到的索引总是 <code>1</code>，因此返回 <code>value</code>为 <code>Person(&quot;Xiao Ming&quot;)</code>，如果 <code>key</code>的值为 <code>&quot;b&quot;</code>，计算得到的索引总是5，因此返回 <code>value</code>为 <code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取 <code>key</code>对应的 <code>value</code>。</p><p>当我们使用 <code>key</code>存取 <code>value</code>的时候，就会引出一个问题：</p><p>我们放入Map的key是字符串 <code>&quot;a&quot;</code>，但是，当我们获取 <code>Map</code>的 <code>value</code>时，传入的变量不一定就是放入的那个key对象。</p><p>换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String key1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(key1, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        String key2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.get(key2); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">        System.out.println(key1 == key2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(key1.equals(key2)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 <code>Map</code>的内部，对 <code>key</code>做比较是通过 <code>equals()</code>实现的，这一点和List查找元素需要正确覆写 <code>equals()</code>是一样的，即正确使用 <code>Map</code>必须保证：作为 <code>key</code>的对象必须正确覆写 <code>equals()</code>方法。</p><p>我们经常使用 <code>String</code>作为 <code>key</code>，因为 <code>String</code>已经正确覆写了 <code>equals()</code>方法。但如果我们放入的 <code>key</code>是一个自己写的类，就必须保证正确覆写了 <code>equals()</code>方法。</p><p>我们再思考一下 <code>HashMap</code>为什么能通过 <code>key</code>直接计算出 <code>value</code>存储的索引。相同的 <code>key</code>对象（使用 <code>equals()</code>判断时返回 <code>true</code>）必须要计算出相同的索引，否则，相同的 <code>key</code>每次取出的 <code>value</code>就不一定对。</p><p>通过 <code>key</code>计算索引的方式就是调用 <code>key</code>对象的 <code>hashCode()</code>方法，它返回一个int整数。<code>HashMap</code>正是通过这个方法直接定位 <code>key</code>对应的 <code>value</code>的索引，继而直接返回 <code>value</code>。</p><p>因此，正确使用 <code>Map</code>必须保证：</p><ol><li>作为 <code>key</code>的对象必须正确覆写 <code>equals()</code>方法，相等的两个 <code>key</code>实例调用 <code>equals()</code>必须返回true；</li><li>作为key的对象还必须正确覆写 <code>hashCode()</code>方法，且 <code>hashCode()</code>方法要严格遵循以下规范：</li></ol><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul><p>即对应两个实例 <code>a</code>和 <code>b</code>：</p><ul><li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li><li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li></ul><p>上述第一条规范是正确性，必须保证实现，否则 <code>HashMap</code>不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的 <code>hashCode()</code>，会造成 <code>Map</code>内部存储冲突，使存取的效率下降。</p><p>正确编写 <code>equals()</code>的方法我们已经在编写 <code>equals</code>方法一节中讲过了，以 <code>Person</code>类为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把需要比较的字段找出来：</p><ul><li>firstName</li><li>lastName</li><li>age</li></ul><p>然后，引用类型使用 <code>Objects.equals()</code>比较，基本类型使用==比较。</p><p>在正确实现 <code>equals()</code>的基础上，我们还需要正确实现 <code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的 <code>int</code>必须相同：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + age;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>String</code>类已经正确实现了 <code>hashCode()</code>方法，我们在计算 <code>Person</code>的 <code>hashCode()</code>时，反复使用 <code>31*h</code>，这样做的目的是为了尽量把不同的 <code>Person</code>实例的 <code>hashCode()</code>均匀分布到整个 <code>int</code>范围。</p><p>和实现 <code>equals()</code>方法遇到的问题类似，如果 <code>firstName</code>或 <code>lastName</code>为 <code>null</code>，上述代码工作起来就会抛 <code>NullPointerException</code>。为了解决这个问题，我们在计算 <code>hashCode()</code>的时候，经常借助 <code>Objects.hash()</code>来计算：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，编写 <code>equals()</code>和 <code>hashCode()</code>遵循的原则是：</p><p><code>equals()</code>用到的用于比较的每一个字段，都必须在 <code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在 <code>hashCode()</code>中计算。</p><p>另外注意，对于放入 <code>HashMap</code>的 <code>value</code>对象，没有任何要求。</p><h3 id="延伸阅读-2">延伸阅读</h3><p>既然 <code>HashMap</code>内部使用了数组，通过计算 <code>key</code>的 <code>hashCode()</code>直接定位 <code>value</code>所在的索引，那么第一个问题来了：<code>hashCode()</code>返回的 <code>int</code>范围高达 <code>±21亿</code>，先不考虑负数，<code>HashMap</code>内部使用的数组得有多大？</p><p>实际上 <code>HashMap</code>初始化时默认的数组大小只有 <code>16</code>，任何key，无论它的hashCode()有多大，都可以简单地通过：</p><blockquote><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15</p></blockquote><p>把索引确定在 <code>0～15</code>，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>第二个问题：如果添加超过 <code>16</code>个 <code>key-value</code>到 <code>HashMap</code>，数组不够用了怎么办？</p><p>添加超过一定数量的 <code>key-value</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。例如，对长度为32的数组计算 <code>hashCode()</code>对应的索引，计算方式要改为：</p><blockquote><p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31</p></blockquote><p>由于扩容会导致重新分布已有的 <code>key-value</code>，所以，频繁扩容对 <code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为 <code>10000</code>个 <code>key-value</code>的 <code>HashMap</code>，更好的方式是创建 <code>HashMap</code>时就指定容量：</p><blockquote><p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);</p></blockquote><p>虽然指定容量是 <code>10000</code>，但HashMap内部的数组长度总是 <code>2n</code>，因此，实际数组长度被初始化为比 <code>10000</code>大的 <code>16384（214）</code>。</p><p>最后一个问题：如果不同的两个key，例如&quot;a&quot;和&quot;b&quot;，它们的hashCode()恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求hashCode()尽量不相等），那么，当我们放入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br></pre></td></tr></table></figure><p>时，由于计算出的数组索引相同，后面放入的 <code>&quot;Xiao Hong&quot;</code>会不会把 <code>&quot;Xiao Ming&quot;</code>覆盖了？</p><p>当然不会！使用 <code>Map</code>的时候，只要 <code>key</code>不相同，它们映射的 <code>value</code>就互不干扰。但是，在 <code>HashMap</code>内部，确实可能存在不同的key，映射到相同的 <code>hashCode()</code>，即相同的数组索引上，肿么办？</p><p>我们就假设 <code>&quot;a&quot;</code>和 <code>&quot;b&quot;</code>这两个key最终计算出的索引都是5，那么，在 <code>HashMap</code>的数组中，实际存储的不是一个 <code>Person</code>实例，而是一个 <code>List</code>，它包含两个 <code>Entry</code>，一个是 <code>&quot;a&quot;</code>的映射，一个是 <code>&quot;b&quot;</code>的映射：</p><p>┌───┐<br>0 │   │<br>├───┤<br>1 │   │<br>├───┤<br>2 │   │<br>├───┤<br>3 │   │<br>├───┤<br>4 │   │<br>├───┤<br>5 │ ●─┼───&gt; <code>List&lt;Entry&lt;String, Person&gt;&gt;</code><br>├───┤<br>6 │   │<br>├───┤<br>7 │   │<br>└───┘<br>在查找的时候，例如：</p><blockquote><p>Person p = map.get(“a”);</p></blockquote><p><code>HashMap</code>内部通过 <code>&quot;a&quot;</code>找到的实际上是 <code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个 <code>List</code>，并找到一个 <code>Entry</code>，它的 <code>key</code>字段是 <code>&quot;a&quot;</code>，才能返回对应的 <code>Person</code>实例。</p><p>我们把不同的key具有相同的 <code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用 <code>List</code>存储 <code>hashCode()</code>相同的 <code>key-value</code>。显然，如果冲突的概率越大，这个 <code>List</code>就越长，<code>Map</code>的 <code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p><div class="note info simple"><p>如果两个对象不相等，则两个对象的 <code>hashCode()</code>尽量不要相等。</p></div><p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高</p><h2 id="使用EnumMap">使用EnumMap</h2><p>因为 <code>HashMap</code>是一种通过对 <code>key</code>计算 <code>hashCode()</code>，通过空间换时间的方式，直接定位到 <code>value</code>所在的内部数组的索引，因此，查找效率非常高。</p><p>如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种 <code>EnumMap</code>，它在内部以一个非常紧凑的数组存储 <code>value</code>，并且根据 <code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算 <code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p><p>我们以 <code>DayOfWeek</code>这个枚举类型为例，为它做一个“翻译”功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br><span class="line">        map.put(DayOfWeek.MONDAY, <span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.TUESDAY, <span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.WEDNESDAY, <span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.THURSDAY, <span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.FRIDAY, <span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SATURDAY, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SUNDAY, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>EnumMap</code>的时候，我们总是用 <code>Map</code>接口来引用它，因此，实际上把 <code>HashMap</code>和 <code>EnumMap</code>互换，在客户端看来没有任何区别。</p><h2 id="使用TreeMap">使用TreeMap</h2><p>我们已经知道，<code>HashMap</code>是一种以空间换时间的映射表，它的实现原理决定了内部的 <code>Key</code>是无序的，即遍历 <code>HashMap</code>的 <code>Key</code>时，其顺序是不可预测的（但每个 <code>Key</code>都会遍历一次且仅遍历一次）。</p><p>还有一种 <code>Map</code>，它在内部会对 <code>Key</code>进行排序，这种 <code>Map</code>就是 <code>SortedMap</code>。注意到 <code>SortedMap</code>是接口，它的实现类是 <code>TreeMap</code>。<br>┌───┐<br>│Map│<br>└───┘<br>▲<br>┌────┴─────┐<br>│          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>▲<br>│<br>┌─────────┐<br>│ TreeMap │<br>└─────────┘<br><code>SortedMap</code>保证遍历时以 <code>Key</code>的顺序来进行排序。例如，放入的 <code>Key</code>是 <code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是 <code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为 <code>String</code>默认按字母排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// apple, orange, pear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TreeMap</code>时，放入的Key必须实现 <code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了 <code>Comparable</code>接口，因此可以直接作为 <code>Key</code>使用。作为Value的对象则没有任何要求。</p><p>如果作为Key的class没有实现 <code>Comparable</code>接口，那么，必须在创建 <code>TreeMap</code>时同时指定一个自定义排序算法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果 <code>a&lt;b</code>，则返回负数，通常是 <code>-1</code>，如果 <code>a==b</code>，则返回 <code>0</code>，如果 <code>a&gt;b</code>，则返回正数，通常是 <code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p><p>从上述代码执行结果可知，打印的Key确实是按照Comparator定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个 <code>new Person(&quot;Bob&quot;)</code>作为Key，它会返回对应的Integer值2。</p><p>另外，注意到 <code>Person</code>类并未覆写 <code>equals()</code>和 <code>hashCode()</code>，因为 <code>TreeMap</code>不使用 <code>equals()</code>和 <code>hashCode()</code>。</p><p>我们来看一个稍微复杂的例子：这次我们定义了 <code>Student</code>类，并用分数 <code>score</code>进行排序，高分在前：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">77</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Student(<span class="string">&quot;Lily&quot;</span>, <span class="number">99</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>))); <span class="comment">// null?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    Student(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for</code>循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的 <code>Key：new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为null！</p><p>这是怎么肥四？难道 <code>TreeMap</code>有问题？遇到 <code>TreeMap</code>工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p><p>在这个例子中，<code>TreeMap</code>出现问题，原因其实出在这个 <code>Comparator</code>上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>p1.score</code>和 <code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在 <code>p1.score</code>和 <code>p2.score</code>相等的时候，它并没有返回0！这就是为什么 <code>TreeMap</code>工作不正常的原因：<code>TreeMap</code>在比较两个 <code>Key</code>是否相等时，依赖 <code>Key</code>的 <code>compareTo()</code>方法或者 <code>Comparator.compare()</code>方法。在两个 <code>Key</code>相等时，必须返回0。因此，修改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接借助 <code>Integer.compare(int, int)</code>也可以返回正确的比较结果。</p><h2 id="使用Properties">使用Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 上次最后打开的文件:</span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line"># 自动保存文件的时间间隔:</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure><p>配置文件的特点是，它的 <code>Key-Value</code>一般都是 <code>String-String</code>类型的，因此我们完全可以用 <code>Map&lt;String, String&gt;</code>来表示它。</p><p>因为配置文件非常常用，所以Java集合库提供了一个 <code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个Hashtable，但我们只需要用到 <code>Properties</code>自身关于读写配置的接口。</p><h3 id="读取配置文件">读取配置文件</h3><p>用 <code>Properties</code>读取配置文件非常简单。Java默认配置文件以 <code>.properties</code>为扩展名，每行以 <code>key=value</code>表示，以#课开头的是注释。以下是一个典型的配置文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure><p>可以从文件系统读取这个 <code>.properties</code>文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f = <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> java.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line">String filepath = props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line">String interval = props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure><p>可见，用 <code>Properties</code>读取配置文件，一共有三步：</p><ol><li>创建<code>Properties</code>实例；</li><li>调用<code>load()</code>读取文件；</li><li>调用<code>getProperty()</code>获取配置。</li></ol><p>调用 <code>getProperty()</code>获取配置时，如果 <code>key</code>不存在，将返回 <code>null</code>。我们还可以提供一个默认值，这样，当 <code>key</code>不存在的时候，就返回默认值。</p><p>也可以从 <code>classpath</code>读取 <code>.properties</code>文件，因为 <code>load(InputStream)</code>方法接收一个 <code>InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>试试从内存读取一个字节流:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String settings = <span class="string">&quot;# test&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;course=Java&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;</span><br><span class="line">        ByteArrayInputStream input = <span class="keyword">new</span> ByteArrayInputStream(settings.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.load(input);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;course: &quot;</span> + props.getProperty(<span class="string">&quot;course&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_date&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_file&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="string">&quot;auto_save&quot;</span>, <span class="string">&quot;60&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// course: Java</span></span><br><span class="line"><span class="comment">// last_open_date: 2019-08-07T12:35:01</span></span><br><span class="line"><span class="comment">// last_open_file: null</span></span><br><span class="line"><span class="comment">// auto_save: 60</span></span><br></pre></td></tr></table></figure><p>如果有多个 <code>.properties</code>文件，可以反复调用 <code>load()</code>读取，后读取的 <code>key-value</code>会覆盖已读取的 <code>key-value</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line">props.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面的代码演示了 <code>Properties</code>的一个常用用法：可以把默认配置文件放到 <code>classpath</code>中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p><p><code>Properties</code>设计的目的是存储 <code>String</code>类型的 <code>key－value</code>，但 <code>Properties</code>实际上是从 <code>Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了 <code>getProperty()</code>和 <code>setProperty()</code>方法外，还有从 <code>Hashtable</code>继承下来的 <code>get()</code>和 <code>put()</code>方法，这些方法的参数签名是 <code>Object</code>，我们在使用 <code>Properties</code>的时候，不要去调用这些从 <code>Hashtable</code>继承下来的方法。</p><h3 id="写入配置文件">写入配置文件</h3><p>如果通过 <code>setProperty()</code>修改了 <code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用 <code>store()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="编码">编码</h3><p>早期版本的Java规定 <code>.properties</code>文件编码是 <code>ASCII编码（ISO8859-1）</code>，如果涉及到中文就必须用 <code>name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的 <code>.properties</code>文件可以使用UTF-8编码了。</p><p>不过，需要注意的是，由于 <code>load(InputStream)</code>默认总是以 <code>ASCII编码</code>读取字节流，所以会导致读到乱码。我们需要用另一个重载方法 <code>load(Reader)</code>读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p>就可以正常读取中文。<code>InputStream</code>和 <code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。</p><h2 id="使用Set">使用Set</h2><p>我们知道，<code>Map</code>用于存储 <code>key-value</code>的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写 <code>equals()</code>方法，还要正确覆写 <code>hashCode()</code>方法。</p><p>如果我们只需要存储不重复的key，并不需要存储映射的 <code>value</code>，那么就可以使用 <code>Set</code>。</p><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><p>我们来看几个简单的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// false，添加失败，因为元素已存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true，元素存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;XYZ&quot;</span>)); <span class="comment">// false，元素不存在</span></span><br><span class="line">        System.out.println(set.remove(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// false，删除失败，因为元素不存在</span></span><br><span class="line">        System.out.println(set.size()); <span class="comment">// 2，一共两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>实际上相当于只存储 <code>key</code>、不存储value的Map。我们经常用Set用于去除重复元素。</p><p>因为放入 <code>Set</code>的元素和Map的key类似，都要正确实现 <code>equals()</code>和 <code>hashCode()</code>方法，否则该元素无法正确地放入Set。</p><p>最常用的Set实现类是 <code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对 <code>HashMap</code>的一个简单封装，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>接口并不保证有序，而 <code>SortedSet</code>接口则保证元素是有序的：</p><ul><li>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；</li><li>TreeSet是有序的，因为它实现了SortedSet接口。<br>用一张图表示：<br>┌───┐<br>│Set│<br>└───┘<br>▲<br>┌────┴─────┐<br>│          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>▲<br>│<br>┌─────────┐<br>│ TreeSet │<br>└─────────┘<br>我们来看<code>HashSet</code>的输出：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p><p>把 <code>HashSet</code>换成 <code>TreeSet</code>，在遍历 <code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TreeSet</code>和使用 <code>TreeMap</code>的要求一样，添加的元素必须正确实现 <code>Comparable接口</code>，如果没有实现 <code>Comparable</code>接口，那么创建 <code>TreeSet</code>时必须传入一个 <code>Comparator对象</code>。</p><h2 id="使用Queue">使用Queue</h2><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个 <code>先进先出（FIFO：First In First Out）</code>的 <code>有序表</code>。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p><ul><li>把元素添加到队列末尾；</li><li>从队列头部取出元素。</li></ul><p>超市的收银台就是一个队列：</p><p>在Java的标准库中，队列接口 <code>Queue</code>定义了以下几个方法：</p><ul><li><code>int size()</code>：获取队列长度；</li><li><code>boolean add(E)/boolean offer(E)</code>：添加元素到队尾；</li><li><code>E remove()/E poll()</code>：获取队首元素并从队列中删除；</li><li><code>E element()/E peek()</code>：获取队首元素但并不从队列中删除。</li></ul><p>对于具体的实现类，有的 <code>Queue</code>有最大队列长度限制，有的 <code>Queue</code>没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><p>||throw Exception|返回false或null|<br>||---------------|---------------|<br>|添加元素到队尾|add(E e)|boolean offer(E e)|<br>|取队首元素并删除|E remove()|E poll()|<br>|取队首元素但不删除|E element()|E peek()|</p><p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    q.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用 <code>offer()</code>方法来添加元素，当添加失败时，它不会抛异常，而是返回 <code>false</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">if</span> (q.offer(<span class="string">&quot;Apple&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要从 <code>Queue</code>中取出队首元素时，如果当前 <code>Queue</code>是一个空队列，调用 <code>remove()</code>方法，它会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = q.remove();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们调用 <code>poll()</code>方法来取出队首元素，当获取失败时，它不会抛异常，而是返回 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line">String s = q.poll();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，两套方法可以根据需要来选择使用。</p><p>注意：不要把 <code>null</code>添加到队列中，否则 <code>poll()</code>方法返回 <code>null</code>时，很难确定是取到了 <code>null</code>元素还是队列为空。</p><p>接下来我们以 <code>poll()</code>和 <code>peek()</code>为例来说说“获取并删除”与“获取但不删除”的区别。对于 <code>Queue</code>来说，每次调用 <code>poll()</code>，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 从队列取出元素:</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列是空的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <code>peek()</code>，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="comment">// 队首永远都是apple，因为peek()不会删除它:</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们还可以发现，<code>LinkedList</code>即实现了 <code>List接口</code>，又实现了 <code>Queue接口</code>，但是，在使用的时候，如果我们把它当作 <code>List</code>，就获取 <code>List</code>的引用，如果我们把它当作 <code>Queue</code>，就获取 <code>Queue</code>的引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p><h2 id="使用PriorityQueue">使用PriorityQueue</h2><p>我们知道，<code>Queue</code>是一个先进先出（FIFO）的队列。</p><p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p><p>可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个 <code>Queue</code>。</p><p>如果这时来了一个VIP客户，他的号码是 <code>V1</code>，虽然当前排队的是 <code>A10</code>、<code>A11</code>、<code>A12</code>……但是柜台下一个呼叫的客户号码却是 <code>V1</code>。</p><p>这个时候，我们发现，要实现“VIP插队”的业务，用 <code>Queue</code>就不行了，因为 <code>Queue</code>会严格按 <code>FIFO</code>的原则取出队首元素。我们需要的是优先队列：<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和 <code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对 <code>PriorityQueue</code>调用 <code>remove()</code>或 <code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用 <code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看 <code>PriorityQueue</code>的行为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>们放入的顺序是 <code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是 <code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，&quot;apple&quot;排在最前面，&quot;pear&quot;排在最后面。</p><p>因此，放入 <code>PriorityQueue</code>的元素，必须实现 <code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p><p>如果我们要放入的元素并没有实现 <code>Comparable</code>接口怎么办？<code>PriorityQueue</code>允许我们提供一个 <code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个 <code>PriorityQueue</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">            <span class="comment">// return Integer.parseInt(u1.number.substring(1))-Integer.parseInt(u2.number.substring(1));</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现PriorityQueue的关键在于提供的 <code>UserComparator</code>对象，它负责比较两个元素的大小（较小的在前）。<code>UserComparator</code>总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p><p>上面的 <code>UserComparator</code>的比较逻辑其实还是有问题的，它会把 <code>A10</code>排在 <code>A2</code>的前面，请尝试修复该错误。</p><h2 id="使用Deque">使用Deque</h2><p>我们知道，Queue是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫 <code>双端队列（Double Ended Queue）</code>，学名 <code>Deque</code>。</p><p>Java集合提供了接口 <code>Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><p>我们来比较一下Queue和Deque出队和入队的方法：</p><p>||Queue|Deque|<br>||-----|-----|<br>|添加元素到队尾|add(E e) / offer(E e)|addLast(E e) / offerLast(E e)|<br>|取队首元素并删除|E remove() / E poll()|E removeFirst() / E pollFirst()|<br>|取队首元素但不删除|E element() / E peek()|E getFirst() / E peekFirst()|<br>|添加元素到队首|无|addFirst(E e) / offerFirst(E e)|<br>|取队尾元素并删除|无|E removeLast() / E pollLast()|<br>|取队尾元素但不删除|无|E getLast() / E peekLast()|</p><p>对于添加元素到队尾的操作，<code>Queue</code>提供了 <code>add()/offer()</code>方法，而 <code>Deque</code>提供了 <code>addLast()/offerLast()</code>方法。添加元素到对首、取队尾元素的操作在 <code>Queue</code>中不存在，在 <code>Deque</code>中由 <code>addFirst()/removeLast()</code>等方法提供。</p><p>注意到 <code>Deque</code>接口实际上扩展自 <code>Queue</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>Queue</code>提供的 <code>add()/offer()</code>方法在Deque中也可以使用，但是，使用 <code>Deque</code>，最好不要调用 <code>offer()</code>，而是调用 <code>offerLast()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerLast(<span class="string">&quot;A&quot;</span>); <span class="comment">// A</span></span><br><span class="line">        deque.offerLast(<span class="string">&quot;B&quot;</span>); <span class="comment">// A &lt;- B</span></span><br><span class="line">        deque.offerFirst(<span class="string">&quot;C&quot;</span>); <span class="comment">// C &lt;- A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// C, 剩下A &lt;- B</span></span><br><span class="line">        System.out.println(deque.pollLast()); <span class="comment">// B, 剩下A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// A</span></span><br><span class="line">        System.out.println(deque.pollFirst()); <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接写 <code>deque.offer()</code>，我们就需要思考，<code>offer()</code>实际上是 <code>offerLast()</code>，我们明确地写上 <code>offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p><p>因此，使用 <code>Deque</code>，推荐总是明确调用 <code>offerLast()/offerFirst()</code>或者 <code>pollFirst()/pollLast()</code>方法。</p><p><code>Deque</code>是一个接口，它的实现类有 <code>ArrayDeque和LinkedList</code>。</p><p>我们发现 <code>LinkedList</code>真是一个全能选手，它即是 <code>List</code>，又是 <code>Queue</code>，还是 <code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法:</span></span><br><span class="line">LinkedList&lt;String&gt; d1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d1.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="comment">// 推荐的写法：</span></span><br><span class="line">Deque&lt;String&gt; d2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d2.offerLast(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h2 id="使用Stack">使用Stack</h2><p><code>栈（Stack）</code>是一种后进先出（<code>LIFO：Last In First Out</code>）的数据结构。</p><p>什么是 <code>LIFO</code>呢？我们先回顾一下 <code>Queue</code>的特点 <code>FIFO</code>：<br>────────────────────────<br>((\      ((\    ((\    ((\      ((<br>(=‘.’) ─&gt; (=‘.’)  (=‘.’)  (=‘.’) ─&gt; (=‘.’)<br>O(<em>“)”)   O(</em>“)”) O(<em>“)”) O(</em>“)”)   O(<em>“)”)<br>────────────────────────<br>所谓 <code>FIFO</code>，是最先进队列的元素一定最早出队列，而 <code>LIFO</code>是最后进 <code>Stack</code>的元素一定最早出 <code>Stack</code>。如何做到这一点呢？只需要把队列的一端封死：<br>───────────────────────────────┐<br>((\       ((\    ((\    ((\    ((\ │<br>(=‘.’) &lt;─&gt; (=‘.’)  (=‘.’)  (=‘.’)  (=‘.’)│<br>O(</em>“)”)    O(<em>“)”) O(</em>“)”) O(<em>“)”) O(</em>“)”)│<br>───────────────────────────────┘<br>因此，<code>Stack</code>是这样一种数据结构：只能不断地往 <code>Stack</code>中压入（<code>push</code>）元素，最后进去的必须最早弹出（<code>pop</code>）来：</p><p><code>Stack</code>只有入栈和出栈的操作：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>。</li></ul><p>在Java中，我们用 <code>Deque</code>可以实现 <code>Stack</code>的功能：</p><ul><li>把元素压栈：<code>push(E)/addFirst(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()/removeFirst()</code>；</li><li>取栈顶元素但不弹出：<code>peek()/peekFirst()</code>。</li></ul><p>为什么Java的集合类没有单独的 <code>Stack</code>接口呢？因为有个遗留类名字就叫 <code>Stack</code>，出于兼容性考虑，所以没办法创建 <code>Stack</code>接口，只能用 <code>Deque接口</code>来“模拟”一个 <code>Stack</code>了。</p><p>当我们把 <code>Deque</code>作为 <code>Stack</code>使用时，注意只调用 <code>push()/pop()/peek()</code>方法，不要调用 <code>addFirst()/removeFirst()/peekFirst()</code>方法，这样代码更加清晰。</p><h3 id="Stack的作用">Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">foo</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;F-&quot;</span> + bar(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p><p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发 <code>StackOverflowError</code>：</p><p>我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。</p><p>例如，我们要把一个int整数12500转换为十六进制表示的字符串，如何实现这个功能？</p><p>首先我们准备一个空栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后计算12500÷16=781…4，余数是 <code>4</code>，把余数 <code>4</code>压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算781÷16=48…13，余数是13，<code>13</code>的十六进制用字母 <code>D</code>表示，把余数 <code>D</code>压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>然后计算48÷16=3…0，余数是 <code>0</code>，把余数 <code>0</code>压栈：</p><p>│   │<br>│   │<br>│   │<br>│ 0 │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>最后计算3÷16=0…3，余数是3，把余数3压栈：</p><p>│   │<br>│ 3 │<br>│   │<br>│ 0 │<br>│   │<br>│ D │<br>│   │<br>│ 4 │<br>└───┘<br>当商是 <code>0</code>的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串 <code>30D4</code>，这就是十进制整数12500的十六进制表示的字符串。</p><h3 id="计算中缀表达式">计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：<code>1 + 2 * (9 - 5)</code>。</p><p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：<code>1 2 9 5 - * +</code>。</p><p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p><p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br>然后我们依次扫描后缀表达式1 2 9 5 - * +，遇到数字1，就直接扔到栈里：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 1 │<br>└───┘<br>紧接着，遇到数字2，9，5，也扔到栈里：</p><p>│   │<br>│ 5 │<br>│   │<br>│ 9 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到减号时，弹出栈顶的两个元素，并计算9-5=4，把结果4压栈：</p><p>│   │<br>│   │<br>│   │<br>│ 4 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到 <code>*</code>号时，弹出栈顶的两个元素，并计算2*4=8，把结果8压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 8 │<br>│   │<br>│ 1 │<br>└───┘<br>接下来遇到+号时，弹出栈顶的两个元素，并计算1+8=9，把结果9压栈：</p><p>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 9 │<br>└───┘<br>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果9。</p><h2 id="使用Iterator">使用Iterator</h2><p>Java的集合类都可以使用 <code>for each</code>循环，<code>List</code>、<code>Set</code>和 <code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个 <code>key</code>。以 <code>List</code>为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Java编译器并不知道如何遍历 <code>List</code>。上述代码能够编译通过，只是因为编译器把 <code>for each</code>循环通过 <code>Iterator</code>改写为了普通的 <code>for</code>循环：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     String s = it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这种通过 <code>Iterator</code>对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p><p>例如，我们虽然知道 <code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了 <code>get(int)</code>方法。虽然我们可以用for循环遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    Object value = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把 <code>ArrayList</code>换成 <code>LinkedList</code>，<code>get(int)</code>方法耗时会随着 <code>index</code>的增加而增加。如果把 <code>ArrayList</code>换成 <code>Set</code>，上述代码就无法编译，因为Set内部没有索引。</p><p>用 <code>Iterator</code>遍历就没有上述问题，因为 <code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的 <code>for each</code>循环自动转换为 <code>Iterator</code>遍历。</p><p>如果我们自己编写了一个集合类，想要使用 <code>for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现Iterable接口，该接口要求返回一个<code>Iterator</code>对象；</li><li>用<code>Iterator</code>对象迭代集合内部数据。</li></ul><p>这里的关键在于，集合类通过调用 <code>iterator()</code>方法，返回一个 <code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的 <code>Iterator</code>示例如下，它总是以倒序遍历集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>ReverseList</code>和 <code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按 <code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p><p>在编写 <code>Iterator</code>的时候，我们通常可以用一个内部类来实现 <code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类 <code>ReverseIterator</code>可以用 <code>ReverseList.this</code>获得当前外部类的 <code>this</code>引用，然后，通过这个 <code>this</code>引用就可以访问 <code>ReverseList</code>的所有字段和方法。</p><h2 id="使用Collections">使用Collections</h2><p><code>Collections</code>是JDK提供的工具类，同样位于 <code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p><div class="note warning simple"><p>注意Collections结尾多了一个s，不是Collection！</p></div><p>我们一般看方法名和参数就可以确认 <code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p><blockquote><p>public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) { … }</p></blockquote><p><code>addAll()</code>方法可以给一个 <code>Collection</code>类型的集合添加若干元素。因为方法签名是 <code>Collection</code>，所以我们可以传入 <code>List</code>，<code>Set</code>等各种集合类型。</p><h3 id="创建空集合">创建空集合</h3><p><code>Collections</code>提供了一系列方法来创建空集合：</p><ul><li>创建空List：<code>List&lt;T&gt; emptyList()</code></li><li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li><li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li></ul><p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p><p>此外，也可以用各个集合接口提供的 <code>of(T...)</code>方法创建空集合。例如，以下创建空 <code>List</code>的两个方法是等价的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of();</span><br><span class="line">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure><h3 id="创建单元素集合">创建单元素集合</h3><p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p><ul><li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li><li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li><li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li></ul><p>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p><p>此外，也可以用各个集合接口提供的 <code>of(T...)</code>方法创建单元素集合。例如，以下创建单元素 <code>List</code>的两个方法是等价的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Collections.singletonList(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure><p>实际上，使用 <code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(); <span class="comment">// empty list</span></span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 1 element</span></span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>); <span class="comment">// 2 elements</span></span><br><span class="line">List&lt;String&gt; list4 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 3 elements</span></span><br></pre></td></tr></table></figure><h3 id="排序-2">排序</h3><p><code>Collections</code>可以对 <code>List</code>进行排序。因为排序会直接修改List元素的位置，因此必须传入可变 <code>List</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌">洗牌</h3><p><code>Collections</code>提供了洗牌算法，即传入一个有序的 <code>List</code>，可以随机打乱 <code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 洗牌后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可变集合">不可变集合</h3><p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p><ul><li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        immutable.add(<span class="string">&quot;orange&quot;</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        mutable.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">        mutable = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全集合">线程安全集合</h3><p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p><ul><li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li></ul><p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p><h1>正则表达式</h1><p>正则表达式是一种用来匹配字符串的强有力的武器。Java内置了强大的正则表达式的支持。</p><h2 id="正则表达式简介">正则表达式简介</h2><p>在了解正则表达式之前，我们先看几个非常常见的问题：</p><ul><li>如何判断字符串是否是有效的电话号码？例如：<code>010-1234567</code>，<code>123ABC456</code>，<code>13510001000</code>等；</li><li>如何判断字符串是否是有效的电子邮件地址？例如：<code>test@example.com</code>，<code>test#example</code>等；</li><li>如何判断字符串是否是有效的时间？例如：<code>12:34</code>，<code>09:60</code>，<code>99:99</code>等。</li></ul><p>一种直观的想法是通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现。下面是判断手机号的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是11位？</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() != <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一位都是0~9：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仅仅做了非常粗略的判断，并未考虑首位数字不能为0等更详细的情况。</p><p>除了判断手机号，我们还需要判断电子邮件地址、电话、邮编等等：</p><ul><li>boolean isValidMobileNumber(String s) { … }</li><li>boolean isValidEmail(String s) { … }</li><li>boolean isValidPhoneNumber(String s) { … }</li><li>boolean isValidZipCode(String s) { … }</li><li>…</li></ul><p>为每一种判断逻辑编写代码实在是太繁琐了。有没有更简单的方法？</p><p>有！用正则表达式！</p><p>正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式 <code>\d&#123;11&#125;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p><p>正则表达式是一套标准，它可以用于任何语言。Java标准库的 <code>java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p><p>举个例子：要判断用户输入的年份是否是20##年，我们先写出规则如下：</p><p>一共有4个字符，分别是：<code>2</code>，<code>0``，0~9任意数字</code>，<code>0~9任意数字</code>。</p><p>对应的正则表达式就是：<code>20\d\d</code>，其中 <code>\d</code>表示任意一个数字。</p><p>把正则表达式转换为Java字符串就变成了 <code>20\\d\\d</code>，注意Java字符串用 <code>\\</code>表示 <code>\</code>。</p><p>最后，用正则表达式匹配一个字符串的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2019&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2100&quot;</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配规则">匹配规则</h2><p>正则表达式的匹配规则是从左到右按规则匹配。我们首先来看如何使用正则表达式来做精确匹配。</p><p>对于正则表达式abc来说，它只能精确地匹配字符串 <code>&quot;abc&quot;</code>，不能匹配 <code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p><p>如果正则表达式有特殊字符，那就需要用 <code>\</code>转义。例如，正则表达式 <code>a\&amp;c</code>，其中 <code>\&amp;</code>是用来匹配特殊字符 <code>&amp;</code>的，它能精确匹配字符串 <code>&quot;a&amp;c&quot;</code>，但不能匹配 <code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p><p>要注意正则表达式在Java代码中也是一个字符串，所以，对于正则表达式 <code>a\&amp;c</code>来说，对应的Java字符串是 <code>&quot;a\\&amp;c&quot;</code>，因为 <code>\</code>也是Java字符串的转义字符，两个 <code>\\</code>实际上表示的是一个 <code>\</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String re1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;Abc&quot;</span>.matches(re1));</span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(re1));</span><br><span class="line"></span><br><span class="line">        String re2 = <span class="string">&quot;a\\&amp;c&quot;</span>; <span class="comment">// 对应的正则是a\&amp;c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a-c&quot;</span>.matches(re2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a&amp;&amp;c&quot;</span>.matches(re2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>如果想匹配非ASCII字符，例如中文，那就用 <code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串 <code>&quot;a和c&quot;</code>，中文字符和的Unicode编码是548c。</p><h3 id="匹配任意字符">匹配任意字符</h3><p>精确匹配实际上用处不大，因为我们直接用 <code>String.equals()</code>就可以做到。大多数情况下，我们想要的匹配规则更多的是模糊匹配。我们可以用.匹配一个任意字符。</p><p>例如，正则表达式 <code>a.c</code>中间的 <code>.</code>可以匹配一个任意字符，例如，下面的字符串都可以被匹配：</p><ul><li><code>&quot;abc&quot;</code>，因为.可以匹配字符b；</li><li><code>&quot;a&amp;c&quot;</code>，因为.可以匹配字符&amp;；</li><li><code>&quot;acc&quot;</code>，因为.可以匹配字符c。</li></ul><p>但它不能匹配 <code>&quot;ac&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>，因为 <code>.</code>匹配一个字符且仅限一个字符。</p><h3 id="匹配数字">匹配数字</h3><p>用 <code>.</code>可以匹配任意字符，这个口子开得有点大。如果我们只想匹配 <code>0~9</code>这样的数字，可以用 <code>\d</code>匹配。例如，正则表达式 <code>00\d</code>可以匹配：</p><ul><li><code>&quot;007&quot;</code>，因为<code>\d</code>可以匹配字符7；</li><li><code>&quot;008&quot;</code>，因为<code>\d</code>可以匹配字符8。</li></ul><p>它不能匹配 <code>&quot;00A&quot;</code>，<code>&quot;0077&quot;</code>，因为\d仅限单个数字字符。</p><h3 id="匹配常用字符">匹配常用字符</h3><p>用 <code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p><ul><li><code>&quot;javac&quot;</code>，因为<code>\w</code>可以匹配英文字符c；</li><li><code>&quot;java9&quot;</code>，因为<code>\w</code>可以匹配数字字符9；。</li><li><code>&quot;java_&quot;</code>，因为<code>\w</code>可以匹配下划线_。</li></ul><p>它不能匹配 <code>&quot;java#&quot;</code>，<code>&quot;java &quot;</code>，因为 <code>\w</code>不能匹配 <code>#</code>、空格等字符。</p><h3 id="匹配空格字符">匹配空格字符</h3><p>用 <code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格，还包括tab字符（在Java中用\t表示）。例如，a\sc可以匹配：</p><ul><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配空格字符；</li><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配<code>tab</code>字符<code>\t</code>。</li></ul><p>它不能匹配 <code>&quot;ac&quot;</code>，<code>&quot;abc&quot;</code>等。</p><h3 id="匹配非数字">匹配非数字</h3><p>用 <code>\d</code>可以匹配一个数字，而 <code>\D</code>则匹配一个非数字。例如，<code>00\D</code>可以匹配：</p><ul><li><code>&quot;00A&quot;</code>，因为<code>\D</code>可以匹配非数字字符A；</li><li><code>&quot;00#&quot;</code>，因为<code>\D</code>可以匹配非数字字符#。</li></ul><p><code>00\d</code>可以匹配的字符串 <code>&quot;007&quot;</code>，<code>&quot;008&quot;</code>等，<code>00\D</code>是不能匹配的。</p><p>类似的，<code>\W</code>可以匹配 <code>\w</code>不能匹配的字符，<code>\S</code>可以匹配 <code>\s</code>不能匹配的字符，这几个正好是反着来的。</p><h3 id="重复匹配">重复匹配</h3><p>我们用 <code>\d</code>可以匹配一个数字，例如，<code>A\d</code>可以匹配 <code>&quot;A0&quot;</code>，<code>&quot;A1&quot;</code>，如果要匹配多个数字，比如 <code>&quot;A380&quot;</code>，怎么办？</p><p>修饰符 <code>*</code>可以匹配任意个字符，包括0个字符。我们用 <code>A\d*</code>可以匹配：</p><ul><li>A：因为<code>\d*</code>可以匹配0个数字；</li><li>A0：因为<code>\d*</code>可以匹配1个数字0；</li><li>A380：因为<code>\d*</code>可以匹配多个数字380。</li></ul><p>修饰符 <code>+</code>可以匹配至少一个字符。我们用 <code>A\d+</code>可以匹配：</p><ul><li><code>A0</code>：因为\d+可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为\d+可以匹配多个数字<code>380</code>。</li></ul><p>但它无法匹配 <code>&quot;A&quot;</code>，因为修饰符 <code>+</code>要求至少一个字符。</p><p>修饰符 <code>?</code>可以匹配 <code>0</code>个或一个字符。我们用 <code>A\d?</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字0。</li></ul><p>但它无法匹配 <code>&quot;A33&quot;</code>，因为修饰符 <code>?</code>超过1个字符就不能匹配了。</p><p>如果我们想精确指定n个字符怎么办？用修饰符 <code>&#123;n&#125;</code>就可以。<code>A\d&#123;3&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li></ul><p>如果我们想指定匹配 <code>n~m</code>个字符怎么办？用修饰符 <code>&#123;n,m&#125;</code>就可以。<code>A\d&#123;3,5&#125;</code>可以精确匹配：</p><p><code>A380</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>3</code>个数字 <code>380</code>；<br><code>A3800</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>4</code>个数字 <code>3800</code>；<br><code>A38000</code>：因为 <code>\d&#123;3,5&#125;</code>可以匹配 <code>5</code>个数字 <code>38000</code>。</p><p>如果没有上限，那么修饰符 <code>&#123;n,&#125;</code>就可以匹配至少n个字符</p><h2 id="复杂匹配规则">复杂匹配规则</h2><h3 id="匹配开头和结尾">匹配开头和结尾</h3><p>用正则表达式进行多行匹配时，我们用 <code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配 <code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p><h3 id="匹配指定范围">匹配指定范围</h3><p>如果我们规定一个7~8位数字的电话号码不能以 <code>0</code>开头，应该怎么写匹配规则呢？<code>\d&#123;7,8&#125;</code>是不行的，因为第一个 <code>\d</code>可以匹配到 <code>0</code>。</p><p>使用 <code>[...]</code>可以匹配范围内的字符，例如，<code>[123456789]</code>可以匹配 <code>1~9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p><p>把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写 <code>[1-9]</code>就可以。</p><p>要匹配大小写不限的十六进制数，比如 <code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p><ul><li><code>0-9</code>：字符<code>0~9</code>；</li><li><code>a-f</code>：字符<code>a~f</code>；</li><li><code>A-F</code>：字符<code>A~F</code>。</li></ul><p>如果要匹配6位十六进制数，前面讲过的{n}仍然可以继续配合使用：<code>[0-9a-fA-F]&#123;6&#125;</code>。</p><p><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写 <code>[^1-9]&#123;3&#125;</code>：</p><ul><li>可以匹配<code>&quot;ABC&quot;</code>，因为不包含字符<code>1~9</code>；</li><li>可以匹配<code>&quot;A00&quot;</code>，因为不包含字符<code>1~9</code>；</li><li>不能匹配<code>&quot;A01&quot;</code>，因为包含字符<code>1</code>；</li><li>不能匹配<code>&quot;A05&quot;</code>，因为包含字符<code>5</code>。</li></ul><h3 id="或规则匹配">或规则匹配</h3><p>用 <code>|</code>连接的两个正则规则是 <code>或</code>规则，例如，<code>AB|CD</code>表示可以匹配 <code>AB或CD</code>。</p><h3 id="使用括号">使用括号</h3><p>现在我们想要匹配字符串 <code>learn java</code>、<code>learn php</code>和 <code>learn go</code>怎么办？一个最简单的规则是 <code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用 <code>(...)</code>把子规则括起来表示成 <code>learn\\s(java|php|go)</code>。</p><h2 id="分组匹配">分组匹配</h2><p>我们前面讲到的 <code>(...)</code>可以用来把一个子规则括起来，这样写 <code>learn\s(java|php|go)</code>就可以更方便地匹配长字符串了。</p><p>实际上 <code>(...)</code>还有一个重要作用，就是分组匹配。</p><p>我们来看一下如何用正则匹配 <code>区号-电话号码</code>这个规则。利用前面讲到的匹配规则，写出来很容易：</p><blockquote><p>\d{3,4}-\d{6,8}</p></blockquote><p>虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：如何提取匹配的子串？</p><p>当然可以用 <code>String</code>提供的 <code>indexOf()</code>和 <code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取 <code>learn\s(java|php)</code>还得改代码。</p><p>正确的方法是用 <code>(...)</code>先把要提取的规则分组，把上述正则表达式变为 <code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。</p><p>现在问题又来了：匹配后，如何按括号提取子串？</p><p>现在我们没办法用 <code>String.matches()</code>这样简单的判断方法了，必须引入 <code>java.util.regex</code>包，用 <code>Pattern</code>对象匹配，匹配后获得一个 <code>Matcher</code>对象，如果匹配成功，就可以直接从 <code>Matcher.group(index)</code>返回子串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);</span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，会得到两个匹配上的子串 <code>010</code>和 <code>12345678</code>。</p><p>要特别注意，<code>Matcher.group(index)</code>方法的参数用 <code>1</code>表示第一个子串，<code>2</code>表示第二个子串。如果我们传入 <code>0</code>会得到什么呢？答案是 <code>010-12345678</code>，即整个正则匹配到的字符串。</p><h3 id="Pattern">Pattern</h3><p>我们在前面的代码中用到的正则表达式代码是 <code>String.matches()</code>方法，而我们在分组提取的代码中用的是 <code>java.util.regex</code>包里面的 <code>Pattern</code>类和 <code>Matcher</code>类。实际上这两种代码本质上是一样的，因为 <code>String.matches()</code>方法内部调用的就是 <code>Pattern</code>和 <code>Matcher</code>类的方法。</p><p>但是反复使用 <code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的 <code>Pattern</code>对象。完全可以先创建出一个 <code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            String whole = matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            String area = matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            String tel = matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Matcher</code>时，必须首先调用 <code>matches()</code>判断是否匹配成功，匹配成功后，才能调用 <code>group()</code>提取子串。</p><p>利用提取子串的功能，我们轻松获得了区号和号码两部分。</p><h2 id="非贪婪匹配">非贪婪匹配</h2><p>在介绍非贪婪匹配前，我们先看一个简单的问题：</p><p>给定一个字符串表示的数字，判断该数字末尾0的个数。例如：</p><ul><li><code>&quot;123000&quot;</code>：3个<code>0</code></li><li><code>&quot;10100&quot;</code>：2个<code>0</code></li><li><code>&quot;1001&quot;</code>：0个<code>0</code></li></ul><p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code>，Java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而打印的第二个子串是空字符串 <code>&quot;&quot;</code>。</p><p>实际上，我们期望分组匹配结果是：</p><table><thead><tr><th>input</th><th>\d+</th><th>0*</th></tr></thead><tbody><tr><td>123000</td><td>“123”</td><td>“000”</td></tr><tr><td>10100</td><td>“101”</td><td>“00”</td></tr><tr><td>1001</td><td>“1001”</td><td>“”</td></tr></tbody></table><p>但实际的分组匹配结果是这样的：</p><table><thead><tr><th>input</th><th>\d+</th><th>0*</th></tr></thead><tbody><tr><td>123000</td><td>“123000”</td><td>“”</td></tr><tr><td>10100</td><td>“10100”</td><td>“”</td></tr><tr><td>1001</td><td>“1001”</td><td>“”</td></tr></tbody></table><p>仔细观察上述实际匹配结果，实际上它是完全合理的，因为 <code>\d+</code>确实可以匹配后面任意个 <code>0</code>。</p><p>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的0包含进来。</p><p>要让 <code>\d+</code>尽量少匹配，让 <code>0*</code>尽量多匹配，我们就必须让 <code>\d+</code>使用非贪婪匹配。在规则 <code>\d+</code>后面加个 <code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，给定一个匹配规则，加上 <code>?</code>后就变成了非贪婪匹配。</p><p>我们再来看这个正则表达式 <code>(\d??)(9*)</code>，注意 <code>\d?</code>表示匹配 <code>0</code>个或 <code>1</code>个数字，后面第二个 <code>?</code>表示非贪婪匹配，因此，给定字符串 <code>&quot;9999&quot;</code>，匹配到的两个子串分别是 <code>&quot;&quot;</code>和 <code>&quot;9999&quot;</code>，因为对于 <code>\d?</code>来说，可以匹配 <code>1</code>个 <code>9</code>，也可以匹配 <code>0</code>个 <code>9</code>，但是因为后面的 <code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了 <code>0</code>个 <code>9</code>。</p><h2 id="搜索和替换">搜索和替换</h2><h3 id="分割字符串-2">分割字符串</h3><p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合 <code>,</code>和 <code>;</code>这些不规范的输入，直接提取出规范的字符串。</p><h3 id="搜索字符串">搜索字符串</h3><p>使用正则表达式还可以搜索字符串，我们来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们获取到 <code>Matcher</code>对象后，不需要调用 <code>matches()</code>方法（因为匹配整个串肯定返回 <code>false</code>），而是反复调用 <code>find()</code>方法，在整个串中搜索能匹配上 <code>\\wo\\w</code>规则的子串，并打印出来。这种方式比 <code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是 <code>o</code>，前后两个必须是字符 <code>[A-Za-z0-9_]</code>。</p><h3 id="替换字符串">替换字符串</h3><p>使用正则表达式替换字符串可以直接调用 <code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// regex</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p><h3 id="反向引用">反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个 <code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用 <code>replaceAll()</code>的时候，我们传入的第二个参数可以使用 <code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br></pre></td></tr></table></figure><p>它实际上把任何4字符单词的前后用 <code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于 <code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串 <code>([a-z]&#123;4&#125;)</code>替换了 <code>$1</code>。</p><h1>IO</h1><p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p><p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p><p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p><strong>InputStream / OutputStream</strong><br>IO流以byte（字节）为最小单位，因此也称为字节流。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p><p>╔════════════╗<br>║   Memory   ║<br>╚════════════╝<br>▲<br>│0x48<br>│0x65<br>│0x6c<br>│0x6c<br>│0x6f<br>│0x21<br>╔═══════════╗<br>║ Hard Disk ║<br>╚═══════════╝<br>这6个字节是按顺序读入的，所以是输入字节流。</p><p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p><p>╔════════════╗<br>║   Memory   ║<br>╚════════════╝<br>│0x21<br>│0x6f<br>│0x6c<br>│0x6c<br>│0x65<br>│0x48<br>▼<br>╔═══════════╗<br>║ Hard Disk ║<br>╚═══════════╝<br>在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流。</p><p><strong>Reader / Writer</strong><br>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照 <code>char</code>来读写显然更方便，这种流称为字符流。</p><p>Java提供了 <code>Reader</code>和 <code>Writer</code>表示字符流，字符流传输的最小数据单位是char。</p><p>例如，我们把 <code>char[]</code>数组 <code>Hi你好</code>这4个字符用 <code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符 <code>H</code>和 <code>i</code>各占一个字节，中文字符 <code>你好</code>各占3个字节：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x48</span><br><span class="line">0x69</span><br><span class="line">0xe4bda0</span><br><span class="line">0xe5a5bd</span><br></pre></td></tr></table></figure><p>反过来，我们用 <code>Reader</code>读取以 <code>UTF-8</code>编码的这8个字节，会从 <code>Reader</code>中得到 <code>Hi你好</code>这4个字符。</p><p>因此，<code>Reader</code>和 <code>Writer</code>本质上是一个能自动编解码的 <code>InputStream</code>和 <code>OutputStream</code>。</p><p>使用 <code>Reader</code>，数据源虽然是字节，但我们读入的数据都是 <code>char</code>类型的字符，原因是 <code>Reader</code>内部把读入的 <code>byte</code>做了解码，转换成了 <code>char</code>。使用 <code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是 <code>byte[]</code>数组，但是我们可以自己把二进制 <code>byte[]</code>数组按照某种编码转换为字符串。究竟使用 <code>Reader</code>还是 <code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用 <code>InputStream</code>，如果数据源是文本，使用 <code>Reader</code>更方便一些。<code>Writer</code>和 <code>OutputStream</code>是类似的。</p><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><p><strong>同步和异步</strong><br>Java标准库的包 <code>java.io</code>提供了同步IO，而 <code>java.nio</code>则是异步IO。上面我们讨论的 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和 <code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有 <code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和 <code>FileWriter</code>。</p><p>本节我们只讨论Java的同步IO，即输入/输出流的IO模型。</p><h2 id="File对象">File对象</h2><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p><blockquote><p>File f = new File(“C:\Windows\notepad.exe”);</p></blockquote><p>注意Windows平台使用 <code>\</code>作为路径分隔符，在Java字符串中需要用 <code>\\</code>表示一个\。Linux平台使用/作为路径分隔符：</p><blockquote><p>File f = new File(“/usr/bin/javac”);</p></blockquote><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">&quot;.\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">&quot;..\\sub\\javac&quot;</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure><p>可以用 <code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><p>File对象有3种形式表示的路径，一种是 <code>getPath()</code>，返回构造方法传入的路径，一种是 <code>getAbsolutePath()</code>，返回绝对路径，一种是 <code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p><p>什么是规范路径？我们看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对路径可以表示成 <code>C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把 <code>.</code>和 <code>..</code>转换成标准的绝对路径后的路径：<code>C:\Windows\notepad.exe</code>。</p><p>因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(File.separator); <span class="comment">// 根据当前平台打印&quot;\&quot;或&quot;/&quot;</span></span><br></pre></td></tr></table></figure><h3 id="文件和目录">文件和目录</h3><p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个 <code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个 <code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用 <code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p><p>例如，调用 <code>isFile()</code>，判断该 <code>File</code>对象是否是一个已存在的文件，调用 <code>isDirectory()</code>，判断该 <code>File</code>对象是否是一个已存在的目录：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\nothing&quot;</span>);</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f2.isFile());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line">        System.out.println(f3.isFile());</span><br><span class="line">        System.out.println(f3.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code>boolean canRead()</code>：是否可读；</li><li><code>boolean canWrite()</code>：是否可写；</li><li><code>boolean canExecute()</code>：是否可执行；</li><li><code>long length()</code>：文件字节大小。</li></ul><p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p><h3 id="创建和删除文件">创建和删除文件</h3><p>当File对象表示一个文件时，可以通过 <code>createNewFile()</code>创建一个新文件，用 <code>delete()</code>删除该文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/path/to/file&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，程序需要读写一些临时文件，File对象提供了 <code>createTempFile()</code>来创建一个临时文件，以及 <code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">&quot;tmp-&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// /tmp/tmp-10977568570339757949.txt</span></span><br></pre></td></tr></table></figure><h3 id="遍历文件和目录">遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.exe&quot;</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h3 id="Path">Path</h3><p>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;project&quot;</span>, <span class="string">&quot;study&quot;</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InputStream">InputStream</h2><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于 <code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p><blockquote><p>public abstract int read() throws IOException;</p></blockquote><p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。</p><p><code>FileInputStream</code>是 <code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个 <code>FileInputStream</code>的所有字节：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><p><code>InputStream</code>和 <code>OutputStream</code>都是通过 <code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成 <code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理 <code>IOException</code>。</p><p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，<code>InputStream</code>就没法正确地关闭，资源也就没法及时释放。</p><p>因此，我们需要用 <code>try ... finally</code>来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的 <code>try(resource)</code>的语法，只需要编写 <code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，编译器并不会特别地为 <code>InputStream</code>加上自动关闭。编译器只看 <code>try(resource = ...)</code>中的对象是否实现了 <code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上 <code>finally</code>语句并调用 <code>close()</code>方法。<code>InputStream</code>和 <code>OutputStrea</code>m都实现了这个接口，因此，都可以用在 <code>try(resource)</code>中。</p><h3 id="缓冲">缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个 <code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的 <code>int</code>值，而是返回实际读取了多少个字节。如果返回 <code>-1</code>，表示没有更多的数据了。</p><p>利用缓冲区一次读取多个字节的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞">阻塞</h3><p>在调用 <code>InputStream</code>的 <code>read()</code>方法读取数据时，我们说 <code>read()</code>方法是阻塞（<code>Blocking</code>）的。它的意思是，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="keyword">int</span> m = n;</span><br></pre></td></tr></table></figure><p>执行到第二行代码时，必须等 <code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定 <code>read()</code>方法调用到底要花费多长时间。</p><h3 id="InputStream实现类">InputStream实现类</h3><p>用FileInputStream可以从文件获取输入流，这是InputStream常用的一个实现类。此外，ByteArrayInputStream可以在内存中模拟一个InputStream：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code>实际上是把一个 <code>byte[]</code>数组在内存中变成一个 <code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个 <code>InputStream</code>。</p><p>举个栗子：我们想从文件中读取所有字节，并转换成char然后拼成一个字符串，可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">            &#125;</span><br><span class="line">            s = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试上面的程序，就真的需要在本地硬盘上放一个真实的文本文件。如果我们把代码稍微改造一下，提取一个 <code>readAsString()</code>的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\test\\README.txt&quot;</span>)) &#123;</span><br><span class="line">            s = readAsString(input);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个 <code>String readAsString(InputStream input)</code>方法进行测试就相当简单，因为不一定要传入一个真的 <code>FileInputStream</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            String s = readAsString(input);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向抽象编程原则的应用：接受 <code>InputStream</code>抽象类型，而不是具体的 <code>FileInputStream</code>类型，从而使得代码可以处理 <code>InputStream</code>的任意实现类。</p><h2 id="OutputStream">OutputStream</h2><p>和 <code>InputStream</code>相反 <code>，OutputStream</code>是Java标准库提供的最基本的输出流。</p><p>和 <code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是 <code>void write(int b)</code>，签名如下：</p><blockquote><p>public abstract void write(int b) throws IOException;</p></blockquote><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是 <code>int</code>参数，但只会写入一个字节，即只写入 <code>int最低8位</code>表示字节的部分（相当于 <code>b &amp; 0xff</code>）。</p><p>和 <code>InputStream</code>类似，<code>OutputStream</code>也提供了 <code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个 <code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p><p>为什么要有 <code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个 <code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以 <code>OutputStream</code>有个 <code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个 <code>flush()</code>方法，因为缓冲区写满了 <code>OutputStream</code>会自动调用它，并且，在调用 <code>close()</code>方法关闭 <code>OutputStream</code>之前，也会自动调用 <code>flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用 <code>flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过 <code>OutputStream</code>的 <code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用 <code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p>实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h3 id="FileOutputStream">FileOutputStream</h3><p>我们以 <code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用 <code>OutputStream</code>提供的重载方法 <code>void write(byte[])</code>来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用 <code>try(resource)</code>来保证 <code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞-2">阻塞</h3><p>和 <code>InputStream</code>一样，<code>OutputStream</code>的 <code>write()</code>方法也是阻塞的。</p><h3 id="OutputStream实现类">OutputStream实现类</h3><p>用 <code>FileOutputStream</code>可以从文件获取输出流，这是 <code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个 <code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayOutputStream</code>实际上是把一个 <code>byte[]</code>数组在内存中变成一个 <code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个 <code>OutputStream</code>。</p><p>同时操作多个 <code>AutoCloseable</code>资源时，在 <code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用 <code>;</code>隔开。例如，同时读写两个文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter模式">Filter模式</h2><p>Java的IO标准库提供的 <code>InputStream</code>根据来源可以包括：</p><ul><li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>如果我们要给 <code>FileInputStream</code>添加缓冲功能，则可以从 <code>FileInputStream</code>派生一个类：</p><blockquote><p>BufferedFileInputStream extends FileInputStream</p></blockquote><p>如果要给 <code>FileInputStream</code>添加计算签名的功能，类似的，也可以从 <code>FileInputStream</code>派生一个类：</p><blockquote><p>DigestFileInputStream extends FileInputStream</p></blockquote><p>如果要给 <code>FileInputStream</code>添加加密/解密功能，还是可以从 <code>FileInputStream</code>派生一个类：</p><blockquote><p>CipherFileInputStream extends FileInputStream</p></blockquote><p>如果要给 <code>FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生 <code>BufferedDigestFileInputStream</code>。如果要给 <code>FileInputStream</code>添加缓冲和加解密的功能，则需要派生 <code>BufferedCipherFileInputStream</code>。</p><p>我们发现，给 <code>FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：<br>┌─────────────────┐<br>│ FileInputStream │<br>└─────────────────┘<br>▲<br>┌───────────┬─────────┼─────────┬───────────┐<br>│           │         │         │           │<br>┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐<br>│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│<br>└───────────────────────┘│└─────────────────┘│└─────────────────────┘<br>│                   │<br>┌─────────────────────────────┐ ┌─────────────────────────────┐<br>│BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│<br>└─────────────────────────────┘ └─────────────────────────────┘</p><p>这还只是针对 <code>FileInputStream</code>设计，如果针对另一种 <code>InputStream</code>设计，很快会出现子类爆炸的情况。</p><p>因此，直接使用继承，为各种 <code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p><p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将 <code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础 <code>InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的 <code>InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的 <code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p><blockquote><p>InputStream file = new FileInputStream(“test.gz”);</p></blockquote><p>紧接着，我们希望 <code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用 <code>BufferedInputStream</code>包装这个 <code>InputStream</code>，得到的包装类型是 <code>BufferedInputStream</code>，但它仍然被视为一个 <code>InputStream</code>：</p><blockquote><p>InputStream buffered = new BufferedInputStream(file);</p></blockquote><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个 <code>GZIPInputStream</code>：</p><blockquote><p>InputStream gzip = new GZIPInputStream(buffered);</p></blockquote><p>无论我们包装多少次，得到的对象始终是 <code>InputStream</code>，我们直接用 <code>InputStream</code>来引用它，就可以正常读取：</p><p>┌─────────────────────────┐<br>│GZIPInputStream          │<br>│┌───────────────────────┐│<br>││BufferedFileInputStream││<br>││┌─────────────────────┐││<br>│││   FileInputStream   │││<br>││└─────────────────────┘││<br>│└───────────────────────┘│<br>└─────────────────────────┘</p><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为 <code>Filter模式</code>（或者 <code>装饰器模式</code>：<code>Decorator</code>）。它可以让我们通过少量的类来实现各种功能的组合：<br>┌─────────────┐<br>│ InputStream │<br>└─────────────┘<br>▲ ▲<br>┌────────────────────┐ │ │ ┌─────────────────┐<br>│  FileInputStream   │─┤ └─│FilterInputStream│<br>└────────────────────┘ │   └─────────────────┘<br>┌────────────────────┐ │     ▲ ┌───────────────────┐<br>│ByteArrayInputStream│─┤     ├─│BufferedInputStream│<br>└────────────────────┘ │     │ └───────────────────┘<br>┌────────────────────┐ │     │ ┌───────────────────┐<br>│ ServletInputStream │─┘     ├─│  DataInputStream  │<br>└────────────────────┘       │ └───────────────────┘<br>│ ┌───────────────────┐<br>└─│CheckedInputStream │<br>└───────────────────┘<br>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：<br>┌─────────────┐<br>│OutputStream │<br>└─────────────┘<br>▲ ▲<br>┌─────────────────────┐ │ │ ┌──────────────────┐<br>│  FileOutputStream   │─┤ └─│FilterOutputStream│<br>└─────────────────────┘ │   └──────────────────┘<br>┌─────────────────────┐ │     ▲ ┌────────────────────┐<br>│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│<br>└─────────────────────┘ │     │ └────────────────────┘<br>┌─────────────────────┐ │     │ ┌────────────────────┐<br>│ ServletOutputStream │─┘     ├─│  DataOutputStream  │<br>└─────────────────────┘       │ └────────────────────┘<br>│ ┌────────────────────┐<br>└─│CheckedOutputStream │<br>└────────────────────┘</p><h3 id="编写FilterInputStream">编写FilterInputStream</h3><p>我们也可以自己编写 <code>FilterInputStream</code>，以便可以把自己的 <code>FilterInputStream</code>“叠加”到任何一个 <code>InputStream</code>中。</p><p>下面的例子演示了如何编写一个 <code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在叠加多个 <code>FilterInputStream</code>，我们只需要持有最外层的 <code>InputStream</code>，并且，当最外层的 <code>InputStream</code>关闭时（在 <code>try(resource)</code>块的结束处自动关闭），内层的 <code>InputStream</code>的 <code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p><h2 id="操作Zip">操作Zip</h2><p><code>ZipInputStream</code>是一种 <code>FilterInputStream</code>，它可以直接读取zip包的内容：</p><p>┌───────────────────┐<br>│    InputStream    │<br>└───────────────────┘<br>▲<br>│<br>┌───────────────────┐<br>│ FilterInputStream │<br>└───────────────────┘<br>▲<br>│<br>┌───────────────────┐<br>│InflaterInputStream│<br>└───────────────────┘<br>▲<br>│<br>┌───────────────────┐<br>│  ZipInputStream   │<br>└───────────────────┘<br>▲<br>│<br>┌───────────────────┐<br>│  JarInputStream   │<br>└───────────────────┘</p><p>另一个 <code>JarInputStream</code>是从 <code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的 <code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p><h3 id="读取zip包">读取zip包</h3><p>我们来看看 <code>ZipInputStream</code>的基本用法。</p><p>我们要创建一个 <code>ZipInputStream</code>，通常是传入一个 <code>FileInputStream</code>作为数据源，然后，循环调用 <code>getNextEntry()</code>，直到返回 <code>null</code>，表示zip流结束。</p><p>一个 <code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用 <code>read()</code>方法不断读取，直到返回 <code>-1</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入zip包">写入zip包</h3><p><code>ZipOutputStream</code>是一种 <code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个 <code>ZipOutputStream</code>，通常是包装一个 <code>FileOutputStream</code>，然后，每写入一个文件前，先调用 <code>putNextEntry()</code>，然后用 <code>write()</code>写入 <code>byte[]</code>数据，写入完毕后调用 <code>closeEntry()</code>结束这个文件的打包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的 <code>name</code>要用相对路径。</p><h2 id="读取classpath资源">读取classpath资源</h2><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个.properties文件中读取配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String conf = <span class="string">&quot;C:\\conf\\default.properties&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(conf)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要正常执行，必须在C盘创建 <code>conf</code>目录，然后在目录里创建 <code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p><p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p><p>有没有路径无关的读取文件的方式呢？</p><p>我们知道，Java存放 <code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p><ul><li>配置文件，例如.properties；</li><li>图片文件，例如.jpg；</li><li>文本文件，例如.txt，.csv；</li><li>……</li></ul><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把 <code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以 <code>／</code>开头，我们先获取当前的 <code>Class</code>对象，然后调用 <code>getResourceAsStream()</code>就可以直接从 <code>classpath</code>读取任意的资源文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回 <code>null</code>。因此，我们需要检查返回的 <code>InputStream</code>是否为 <code>null</code>，如果为 <code>null</code>，表示资源文件在 <code>classpath</code>中没有找到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>这样读取配置文件，应用程序启动就更加灵活。</p><h2 id="序列化">序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个 <code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把 <code>byte[]</code>保存到文件中，或者把 <code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是 <code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的 <code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取 <code>byte[]</code>并把它“变回”Java对象。</p><p>我们来看看如何把一个Java对象序列化。</p><p>一个Java对象要能序列化，必须实现一个特殊的 <code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为 <code>“标记接口”（Marker Interface）</code>，实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h3 id="序列化-2">序列化</h3><p>把一个Java对象变为 <code>byte[]</code>数组，需要使用 <code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如 <code>int</code>，<code>boolean</code>，也可以写入 <code>String</code>（以UTF-8编码），还可以写入实现了 <code>Serializable</code>接口的 <code>Object</code>。</p><p>因为写入 <code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h3 id="反序列化">反序列化</h3><p>和 <code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取基本类型和 <code>String</code>类型外，调用 <code>readObject()</code>可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>对于 <code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义 <code>Person</code>类，所以无法反序列化。</p><p>对于 <code>InvalidClassException</code>，这种情况常见于序列化的 <code>Person</code>对象定义了一个 <code>int</code>类型的 <code>age</code>字段，但是反序列化时，<code>Person</code>类定义的 <code>age</code>字段被改成了 <code>long</code>类型，所以导致 <code>class</code>不兼容。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的 <code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变 <code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h3 id="安全性">安全性</h3><p>因为Java的序列化机制可以导致一个实例能直接从 <code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 <code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h2 id="Reader">Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和 <code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以 <code>byte</code>为单位读取，而 <code>Reader</code>是一个字符流，即以 <code>char</code>为单位读取：</p><table><thead><tr><th>InputStream</th><th>Reader</th></tr></thead><tbody><tr><td>字节流，以byte为单位</td><td>字符流，以char为单位</td></tr><tr><td>读取字节（-1，<code>0~255</code>）：int read()</td><td>读取字符（-1，0~65535）：int read()</td></tr><tr><td>读到字节数组：int read(byte[] b)</td><td>读到字符数组：int read(char[] c)</td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><blockquote><p>public int read() throws IOException;</p></blockquote><p>这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。</p><h3 id="FileReader">FileReader</h3><p><code>FileReader</code>是 <code>Reader</code>的一个子类，它可以打开文件并获取 <code>Reader</code>。下面的代码演示了如何完整地读取一个 <code>FileReader</code>的所有字符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为 <code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建 <code>FileReader</code>时指定编码：</p><blockquote><p>Reader reader = new FileReader(“src/readme.txt”, StandardCharsets.UTF_8);</p></blockquote><p>和 <code>InputStream</code>类似 <code>，Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用 <code>try (resource)</code>来保证Reader在无论有没有IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code>还提供了一次性读取若干字符并填充到 <code>char[]</code>数组的方法：</p><blockquote><p>public int read(char[] c) throws IOException</p></blockquote><p>它返回实际读入的字符个数，最大不超过 <code>char[]</code>数组的长度。返回-1表示流结束。</p><p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayReader">CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个 <code>Reader</code>，它的作用实际上是把一个 <code>char[]</code>数组变成一个 <code>Reader</code>，这和 <code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringReader">StringReader</h3><p><code>StringReader</code>可以直接把 <code>String</code>作为数据源，它和 <code>CharArrayReader</code>几乎一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> StringReader(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader">InputStreamReader</h3><p><code>Reader</code>和 <code>InputStream</code>有什么关系？</p><p>除了特殊的 <code>CharArrayReader</code>和 <code>StringReader</code>，普通的 <code>Reader</code>实际上是基于 <code>InputStream</code>构造的，因为 <code>Reader</code>需要从 <code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看 <code>FileReader</code>的源码，它在内部实际上持有一个 <code>FileInputStream</code>。</p><p>既然 <code>Reader</code>本质上是一个基于 <code>InputStream</code>的 <code>byte</code>到 <code>char</code>的转换器，那么，如果我们已经有一个 <code>InputStream</code>，想把它转换为Reader，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何 <code>InputStream</code>转换为 <code>Reader</code>。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>构造 <code>InputStreamReader</code>时，我们需要传入 <code>InputStream</code>，还需要指定编码，就可以得到一个 <code>Reader</code>对象。上述代码可以通过 <code>try (resource)</code>更简洁地改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是 <code>FileReader</code>的一种实现方式。</p><p>使用 <code>try (resource)</code>结构时，当我们关闭 <code>Reader</code>时，它会在内部自动调用 <code>InputStream</code>的 <code>close()</code>方法，所以，只需要关闭最外层的 <code>Reader</code>对象即可。</p><div class="note info sample simple"><p>使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p></div><h2 id="Writer">Writer</h2><p><code>Reader</code>是带编码转换器的 <code>InputStream</code>，它把 <code>byte</code>转换为 <code>char</code>，而 <code>Writer</code>就是带编码转换器的 <code>OutputStream</code>，它把 <code>char</code>转换为 <code>byte</code>并输出。</p><p><code>Writer</code>和 <code>OutputStream</code>的区别如下：</p><table><thead><tr><th>OutputStream</th><th>Writer</th></tr></thead><tbody><tr><td>字节流，以byte为单位</td><td>字符流，以char为单位</td></tr><tr><td>写入字节（<code>0~255</code>）：void write(int b)</td><td>写入字符（<code>0~65535</code>）：void write(int c)</td></tr><tr><td>写入字节数组：void write(byte[] b)</td><td>写入字符数组：void write(char[] c)</td></tr><tr><td>无对应方法</td><td>写入String：void write(String s)</td></tr></tbody></table><p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p><ul><li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li><li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li><li>写入String表示的所有字符：<code>void write(String s)</code>。</li></ul><h3 id="FileWriter">FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的 <code>Writer</code>。它的使用方法和 <code>FileReader</code>类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayWriter">CharArrayWriter</h3><p><code>CharArrayWriter</code>可以在内存中创建一个 <code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入 <code>char</code>，最后得到写入的 <code>char[]</code>数组，这和 <code>ByteArrayOutputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="keyword">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringWriter">StringWriter</h3><p><code>StringWriter</code>也是一个基于内存的 <code>Writer</code>，它和 <code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个 <code>StringBuffer</code>，并对外提供了 <code>Writer</code>接口。</p><h3 id="OutputStreamWriter">OutputStreamWriter</h3><p>除了 <code>CharArrayWriter</code>和 <code>StringWriter</code>外，普通的 <code>Writer</code>实际上是基于 <code>OutputStream</code>构造的，它接收 <code>char</code>，然后在内部自动转换成一个或多个 <code>byte</code>，并写入 <code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的 <code>OutputStream</code>转换为 <code>Writer</code>的转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是 <code>FileWriter</code>的一种实现方式。这和上一节的 <code>InputStreamReader</code>是一样的。</p><h2 id="PrintStream和PrintWriter">PrintStream和PrintWriter</h2><p><code>PrintStream</code>是一种 <code>FilterOutputStream</code>，它在 <code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code>int</code>：<code>print(int)</code></li><li>写入<code>boolean</code>：<code>print(boolean)</code></li><li>写入<code>String</code>：<code>print(String)</code></li><li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li><li>…</li></ul><p>以及对应的一组 <code>println()</code>方法，它会自动加上换行符。</p><p>我们经常使用的 <code>System.out.println()</code>实际上就是使用 <code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的 <code>PrintStream</code>，表示标准输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="number">12345</span>); <span class="comment">// 输出12345</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> Object()); <span class="comment">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure><p><code>System.err</code>是系统默认提供的标准错误输出。</p><p><code>PrintStream</code>和 <code>OutputStream</code>相比，除了添加了一组 <code>print()/println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出 <code>IOException</code>，这样我们在编写代码的时候，就不必捕获IOException。</p><h3 id="PrintWriter">PrintWriter</h3><p><code>PrintStream</code>最终输出的总是 <code>byte</code>数据，而 <code>PrintWriter</code>则是扩展了 <code>Writer</code>接口，它的 <code>print()/println()</code>方法最终输出的是 <code>char</code>数据。两者的使用方法几乎是一模一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterTset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Files">使用Files</h2><p>从Java 7开始，提供了 <code>Files</code>和 <code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p><p>虽然 <code>Files</code>和 <code>Paths</code>是 <code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个byte[]，可以这么写：</p><blockquote><p>byte[] data = Files.readAllBytes(Paths.get(“/path/to/file.txt”));</p></blockquote><p>如果是文本文件，可以把一个文件的全部内容读取为 <code>String</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line">String content1 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line">String content2 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有 <code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h1>日期与时间</h1><h2 id="基本概念">基本概念</h2><p>在计算机中，我们经常需要处理日期和时间。</p><p>这是日期：</p><ul><li>2019-11-20</li><li>2020-1-1</li></ul><p>这是时间：</p><ul><li>12:30:59</li><li>2020-1-1 20:21:59</li></ul><p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p><p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p><h3 id="本地时间">本地时间</h3><p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1298615433691201/l" alt="localtime"></p><p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p><h3 id="时区">时区</h3><p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p><p>一种是以 <code>GMT</code>或者 <code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者 <code>UTC+08:00</code>表示东八区。</p><p><code>GMT</code>和 <code>UTC</code>可以认为基本是等价的，只是 <code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p><p>另一种是缩写，例如，<code>CST</code>表示 <code>China Standard Time</code>，也就是中国标准时间。但是 <code>CST</code>也可以表示美国中部时间 <code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p><p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p><p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1298616075419714/l" alt="timezone"></p><p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p><h3 id="夏令时">夏令时</h3><p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1298616301912130/l" alt="daynight-saving"></p><p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p><p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p><ul><li>如果以 <code>GMT</code>或者 <code>UTC</code>作为时区，无论日期是多少，时间都是 <code>19:00</code>；</li><li>如果以国家／城市表示，例如 <code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，GMT时间和纽约时间可能是不一样的：</li></ul><table><thead><tr><th>时区</th><th>2019-11-20</th><th>2019-6-20</th></tr></thead><tbody><tr><td>GMT-05:00</td><td>19:00</td><td>19:00</td></tr><tr><td>UTC-05:00</td><td>19:00</td><td>19:00</td></tr><tr><td>America/New_York</td><td>19:00</td><td>20:00</td></tr></tbody></table><p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p><div class="note warning sample simple"><p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p></div><h3 id="本地化">本地化</h3><p>在计算机中，通常使用 <code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由 <code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p><p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p><ul><li>zh_CN：2016-11-30</li><li>en_US：11/30/2016</li></ul><p>计算机用 <code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的 <code>Locale</code>对用户显示如下：</p><p>||中国用户|美国用户|<br>||--------|-------|<br>|购买价格|12000.00|12,000.00|<br>|购买日期|2016-11-30|11/30/2016|</p><h2 id="Date和Calendar">Date和Calendar</h2><p>在计算机中，应该如何表示日期和时间呢？</p><p>我们经常看到的日期和时间表示方式如下：</p><ul><li>2019-11-20 0:15:00 GMT+00:00</li><li>2019年11月20日8:15:00</li><li>11/19/2019 19:15:00 America/New_York</li></ul><p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p><p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p><p>当我们定义一个整型变量并赋值时：</p><blockquote><p>int n = 123400;</p></blockquote><p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量 <code>n</code>指向的内存实际上是一个4字节区域：</p><p>┌──┬──┬──┬──┐<br>│00│01│e2│08│<br>└──┴──┴──┴──┘<br>注意到计算机内存除了二进制的 <code>0/1</code>外没有其他任何格式。上述十六机制是为了简化表示。</p><p>当我们用 <code>System.out.println(n)</code>打印这个整数的时候，实际上 <code>println()</code>这个方法在内部把 <code>int</code>类型转换成 <code>String</code>类型，然后打印出字符串 <code>123400</code>。</p><p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果n表示一个价格，我们就以 <code>$123,400.00</code>的形式来打印它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">123400</span>;</span><br><span class="line">        <span class="comment">// 123400</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="comment">// 1e208</span></span><br><span class="line">        System.out.println(Integer.toHexString(n));</span><br><span class="line">        <span class="comment">// $123,400.00</span></span><br><span class="line">        System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，整数 <code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p><blockquote><p>String toDisplay(int n) { … }</p></blockquote><p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p><ul><li>2019-11-20 0:15:01 GMT+00:00</li><li>2019年11月20日8:15:01</li><li>11/19/2019 19:15:01 America/New_York</li></ul><p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为 <code>Epoch Time</code>。</p><p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p><p><code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1574208900 = 北京时间2019-11-20 8:15:00</span><br><span class="line">           = 伦敦时间2019-11-20 0:15:00</span><br><span class="line">           = 纽约时间2019-11-19 19:15:00</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/1298615433691201/l" alt="localtime"></p><p>因此，在计算机中，只需要存储一个整数 <code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p><blockquote><p>String displayDateTime(int n, String timezone) { … }</p></blockquote><p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p><ul><li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li><li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li><li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li></ul><p>它们之间转换非常简单。而在Java程序中，时间戳通常是用 <code>long</code>表示的毫秒数，即：</p><blockquote><p>long t = 1574208900123L;</p></blockquote><p>转换成北京时间就是 <code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用 <code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p><h3 id="标准库API">标准库API</h3><p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p><ul><li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li><li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li></ul><p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p><p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p><p>本节我们快速讲解旧API的常用类型和方法。</p><h4 id="Date">Date</h4><p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与 <code>java.sql.Date</code>区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看Date的基本用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>getYear()</code>返回的年份必须加上 <code>1900</code>，<code>getMonth()</code>返回的月份是 <code>0~11</code>分别表示 <code>1~12</code>月，所以要加1，而 <code>getDate()</code>返回的日期范围是 <code>1~31</code>，又不能加1。</p><p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用 <code>SimpleDateFormat</code>对一个 <code>Date</code>进行转换。它用预定义的字符串表示格式化：</p><ul><li>yyyy：年</li><li>MM：月</li><li>dd: 日</li><li>HH: 小时</li><li>mm: 分钟</li><li>ss: 秒</li></ul><p>我们来看如何以自定义的格式输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的格式化预定义了许多不同的格式，我们以 <code>MMM</code>和 <code>E</code>为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在不同的语言环境会打印出类似 <code>Sun Sep 15, 2019</code>这样的日期。可以从<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/text/SimpleDateFormat.html">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以 <code>M</code>为例，假设当前月份是9月：</p><ul><li><code>M</code>：输出<code>9</code></li><li><code>MM</code>：输出<code>09</code></li><li><code>MMM</code>：输出<code>Sep</code></li><li><code>MMMM</code>：输出<code>September</code></li></ul><p><code>Date</code>对象有几个严重的问题：它不能转换时区，除了 <code>toGMTString()</code>可以按 <code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p><h4 id="Calendar">Calendar</h4><p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和 <code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p><p>我们来看 <code>Calendar</code>的基本用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> y = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> ss = c.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">&quot;-&quot;</span> + m + <span class="string">&quot;-&quot;</span> + d + <span class="string">&quot; &quot;</span> + w + <span class="string">&quot; &quot;</span> + hh + <span class="string">&quot;:&quot;</span> + mm + <span class="string">&quot;:&quot;</span> + ss + <span class="string">&quot;.&quot;</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>Calendar</code>获取年月日这些信息变成了 <code>get(int field)</code>，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~<code>7</code>分别表示周日，周一，……，周六。</p><p><code>Calendar</code>只有一种方式获取，即 <code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置2019年:</span></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">// 设置9月:注意8表示9月:</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置2日:</span></span><br><span class="line">        c.set(Calendar.DATE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置时间:</span></span><br><span class="line">        c.set(Calendar.HOUR_OF_DAY, <span class="number">21</span>);</span><br><span class="line">        c.set(Calendar.MINUTE, <span class="number">22</span>);</span><br><span class="line">        c.set(Calendar.SECOND, <span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-09-02 21:22:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>Calendar.getTime()</code>可以将一个 <code>Calendar</code>对象转换成 <code>Date</code>对象，然后就可以用 <code>SimpleDateFormat</code>进行格式化了。</p><h4 id="TimeZone">TimeZone</h4><p><code>Calendar</code>和 <code>Date</code>相比，它提供了时区转换的功能。时区用 <code>TimeZone</code>对象表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeZone tzDefault = TimeZone.getDefault(); <span class="comment">// 当前时区</span></span><br><span class="line">        TimeZone tzGMT9 = TimeZone.getTimeZone(<span class="string">&quot;GMT+09:00&quot;</span>); <span class="comment">// GMT+9:00时区</span></span><br><span class="line">        TimeZone tzNY = TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>); <span class="comment">// 纽约时区</span></span><br><span class="line">        System.out.println(tzDefault.getID()); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">        System.out.println(tzGMT9.getID()); <span class="comment">// GMT+09:00</span></span><br><span class="line">        System.out.println(tzNY.getID()); <span class="comment">// America/New_York</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时区的唯一标识是以字符串表示的ID，我们获取指定 <code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用 <code>TimeZone.getAvailableIDs()</code>。</p><p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间 <code>2019-11-20 8:15:00</code>转换为纽约时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置为北京时区:</span></span><br><span class="line">        c.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(sdf.format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-11-19 19:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，利用 <code>Calendar</code>进行时区转换的步骤是：</p><ol><li>清除所有字段；</li><li>设定指定时区；</li><li>设定日期和时间；</li><li>创建<code>SimpleDateFormat</code>并设定目标时区；</li><li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li></ol><p>因此，本质上时区转换只能通过 <code>SimpleDateFormat</code>在显示的时候完成。</p><p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date d = c.getTime();</span><br><span class="line">        System.out.println(sdf.format(d));</span><br><span class="line">        <span class="comment">// 2019-11-25 6:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LocalDateTime">LocalDateTime</h2><p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p><ul><li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li><li>带时区的日期和时间：<code>ZonedDateTime</code>；</li><li>时刻：<code>Instant</code>；</li><li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li><li>时间间隔：<code>Duration</code>。</li></ul><p>以及一套新的用于取代 <code>SimpleDateFormat</code>的格式化类型 <code>DateTimeFormatter</code>。</p><p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p><p>此外，新API修正了旧API不合理的常量设计：</p><ul><li>Month的范围用1~12表示1月到12月；</li><li>Week的范围用1~7表示周一到周日。</li></ul><p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p><h3 id="LocalDateTime-2">LocalDateTime</h3><p>我们首先来看最常用的 <code>LocalDateTime</code>，它表示一个本地日期和时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate d = LocalDate.now(); <span class="comment">// 当前日期</span></span><br><span class="line">        LocalTime t = LocalTime.now(); <span class="comment">// 当前时间</span></span><br><span class="line">        LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">        System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和 <code>LocalTime</code>默认严格按照<a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>规定的日期和时间格式进行打印。</p><p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">LocalDate d = dt.toLocalDate(); <span class="comment">// 转换到当前日期</span></span><br><span class="line">LocalTime t = dt.toLocalTime(); <span class="comment">// 转换到当前时间</span></span><br></pre></td></tr></table></figure><p>反过来，通过指定的日期和时间创建 <code>LocalDateTime</code>可以通过 <code>of()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定日期和时间:</span></span><br><span class="line">LocalDate d2 = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>); <span class="comment">// 2019-11-30, 注意11=11月</span></span><br><span class="line">LocalTime t2 = LocalTime.of(<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 15:16:17</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure><p>因为严格按照ISO 8601的格式，因此，将字符串转换为LocalDateTime就可以传入标准格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.parse(<span class="string">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class="line">LocalDate d = LocalDate.parse(<span class="string">&quot;2019-11-19&quot;</span>);</span><br><span class="line">LocalTime t = LocalTime.parse(<span class="string">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意ISO 8601规定的日期和时间分隔符是 <code>T</code>。标准格式如下：</p><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul><h3 id="DateTimeFormatter">DateTimeFormatter</h3><p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成 <code>LocalDateTime</code>，可以使用新的 <code>DateTimeFormatter</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义格式化:</span></span><br><span class="line">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用自定义格式解析:</span></span><br><span class="line">        LocalDateTime dt2 = LocalDateTime.parse(<span class="string">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class="line">        System.out.println(dt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 加5天减3小时:</span></span><br><span class="line">        LocalDateTime dt2 = dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T17:30:59</span></span><br><span class="line">        <span class="comment">// 减1月:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.minusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T17:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到月份加减会自动调整日期，例如从 <code>2019-10-31</code>减去1个月得到的结果是 <code>2019-09-30</code>，因为9月没有31日。</p><p>对日期和时间进行调整则使用 <code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把 <code>10:11:12</code>变为 <code>15:11:12</code>：</p><ul><li>调整年：withYear()</li><li>调整月：withMonth()</li><li>调整日：withDayOfMonth()</li><li>调整时：withHour()</li><li>调整分：withMinute()</li><li>调整秒：withSecond()</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 日期变为31日:</span></span><br><span class="line">        LocalDateTime dt2 = dt.withDayOfMonth(<span class="number">31</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T20:30:59</span></span><br><span class="line">        <span class="comment">// 月份变为9:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.withMonth(<span class="number">9</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T20:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样注意到调整月份时，会相应地调整日期，即把 <code>2019-10-31</code>的月份调整为 <code>9</code>时，日期也自动变为 <code>30</code>。</p><p>实际上，<code>LocalDateTime</code>还有一个通用的 <code>with()</code>方法允许我们做更复杂的运算。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line">        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line">        System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月最后1天:</span></span><br><span class="line">        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下月第1天:</span></span><br><span class="line">        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">        System.out.println(nextMonthFirstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月第1个周一:</span></span><br><span class="line">        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">        System.out.println(firstWeekday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p><p>要判断两个 <code>LocalDateTime</code>的先后，可以使用 <code>isBefore()</code>、<code>isAfter()</code>方法，对于 <code>LocalDate</code>和 <code>LocalTime</code>类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        LocalDateTime target = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(now.isBefore(target));</span><br><span class="line">        System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">        System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">&quot;08:15:00&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>LocalDateTime</code>无法与时间戳进行转换，因为 <code>LocalDateTime</code>没有时区，无法确定某一时刻。后面我们要介绍的 <code>ZonedDateTime</code>相当于 <code>LocalDateTime</code>加时区的组合，它具有时区，可以与 <code>long</code>表示的时间戳进行转换。</p><h3 id="Duration和Period">Duration和Period</h3><p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的 <code>Period</code>表示两个日期之间的天数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime start = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        LocalDateTime end = LocalDateTime.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>);</span><br><span class="line">        Duration d = Duration.between(start, end);</span><br><span class="line">        System.out.println(d); <span class="comment">// PT1235H10M30S</span></span><br><span class="line"></span><br><span class="line">        Period p = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>).until(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">        System.out.println(p); <span class="comment">// P1M21D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到两个 <code>LocalDateTime</code>之间的差值使用 <code>Duration</code>表示，类似 <code>PT1235H10M30S</code>，表示1235小时10分钟30秒。而两个 <code>LocalDate</code>之间的差值用 <code>Period</code>表示，类似 <code>P1M21D</code>，表示1个月21天。</p><p><code>Duration</code>和 <code>Period</code>的表示方法也符合ISO 8601的格式，它以 <code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是 <code>PT...</code>的格式表示仅有时间间隔。利用 <code>ofXxx()</code>或者 <code>parse()</code>方法也可以直接创建 <code>Duration</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = Duration.ofHours(<span class="number">10</span>); <span class="comment">// 10 hours</span></span><br><span class="line">Duration d2 = Duration.parse(<span class="string">&quot;P1DT2H3M&quot;</span>); <span class="comment">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure><p>有的童鞋可能发现Java 8引入的 <code>java.time</code>API。怎么和一个开源的<a href="https://www.joda.org/">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了 <code>java.time</code>API。</p><h2 id="ZonedDateTime">ZonedDateTime</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。</p><p>可以简单地把 <code>ZonedDateTime</code>理解成 <code>LocalDateTime</code>加 <code>ZoneId</code>。<code>ZoneId</code>是 <code>java.time</code>引入的新的时区类，注意和旧的 <code>java.util.TimeZone</code>区别。</p><p>要创建一个 <code>ZonedDateTime</code>对象，有以下几种方法，一种是通过 <code>now()</code>方法返回当前时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>)); <span class="comment">// 用指定时区获取当前时间</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察打印的两个 <code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T20:<span class="number">58</span>:<span class="number">18.786182</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T08:<span class="number">58</span>:<span class="number">18.788860</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure><p>另一种方式是通过给一个 <code>LocalDateTime</code>附加一个 <code>ZoneId</code>，就可以变成 <code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime ldt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class="line">        ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式创建的 <code>ZonedDateTime</code>，它的日期和时间与 <code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T15:<span class="number">16</span>:<span class="number">17</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T15:<span class="number">16</span>:<span class="number">17</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure><h3 id="时区转换">时区转换</h3><p>要转换时区，首先我们需要有一个 <code>ZonedDateTime</code>对象，然后，通过 <code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p><p>下面的代码演示了如何将北京时间转换为纽约时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 转换为纽约时间:</span></span><br><span class="line">        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T21:<span class="number">05</span>:<span class="number">50.187697</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-09-15T09:<span class="number">05</span>:<span class="number">50.187697</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure><p>这是北京时间11月15日的转换结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-15T21:<span class="number">05</span>:<span class="number">50.187697</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-15T08:<span class="number">05</span>:<span class="number">50.187697</span>-<span class="number">05</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure><p>两次转换后的纽约时间有1小时的夏令时时差。</p><div class="note warning sample simple"><p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p></div><p>有了 <code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZonedDateTime zdt = ...</span><br><span class="line">LocalDateTime ldt = zdt.toLocalDateTime();</span><br></pre></td></tr></table></figure><p>转换为 <code>LocalDateTime</code>时，直接丢弃了时区信息。</p><h2 id="DateTimeFormatter-2">DateTimeFormatter</h2><p>使用旧的 <code>Date</code>对象时，我们用 <code>SimpleDateFormat</code>进行格式化显示。使用新的 <code>LocalDateTime</code>或 <code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用 <code>DateTimeFormatter</code>。</p><p>和 <code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为 <code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而 <code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p><p>创建 <code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p><blockquote><p>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm”);</p></blockquote><p>格式化字符串的使用方式与 <code>SimpleDateFormat</code>完全一致。</p><p>另一种创建 <code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定 <code>Locale</code>：</p><blockquote><p>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(“E, yyyy-MMMM-dd HH:mm”, <a href="http://Locale.US">Locale.US</a>);</p></blockquote><p>这种方式可以按照 <code>Locale</code>默认习惯格式化。我们来看实际效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">        <span class="keyword">var</span> formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class="line">        System.out.println(formatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> zhFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(zhFormatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> usFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(usFormatter.format(zdt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在格式化字符串中，如果需要输出固定字符，可以用 <code>'xxx'</code>表示。</p><p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-09-15T23:<span class="number">16</span> GMT+08:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span> <span class="number">9</span>月 <span class="number">15</span> 周日 <span class="number">23</span>:<span class="number">16</span></span><br><span class="line">Sun, September/<span class="number">15</span>/<span class="number">2019</span> <span class="number">23</span>:<span class="number">16</span></span><br></pre></td></tr></table></figure><p>当我们直接调用 <code>System.out.println()</code>对一个 <code>ZonedDateTime</code>或者 <code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的 <code>toString()</code>方法，默认的 <code>toString()</code>方法显示的字符串就是按照 <code>ISO 8601</code>格式显示的，我们可以通过 <code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br></pre></td></tr></table></figure><p>得到的输出和toString()类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-09-15</span><br><span class="line">2019-09-15T23:16:51.56217</span><br></pre></td></tr></table></figure><h2 id="Instant">Instant</h2><p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的 <code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p><p>这个当前时间戳在 <code>java.time</code>中以 <code>Instant</code>类型表示，我们用 <code>Instant.now()</code>获取当前时间戳，效果和 <code>System.currentTimeMillis()</code>类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now.getEpochSecond()); <span class="comment">// 秒</span></span><br><span class="line">        System.out.println(now.toEpochMilli()); <span class="comment">// 毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1568568760</span><br><span class="line">1568568760316</span><br></pre></td></tr></table></figure><p>实际上，<code>Instant</code>内部只有两个核心字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Instant</span> <span class="keyword">implements</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和 <code>System.currentTimeMillis()</code>返回的 <code>long</code>相比，只是多了更高精度的纳秒。</p><p>既然 <code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出 <code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以指定时间戳创建Instant:</span></span><br><span class="line">Instant ins = Instant.ofEpochSecond(<span class="number">1568568760</span>);</span><br><span class="line">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zdt); <span class="comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>可见，对于某一个时间戳，给它关联上指定的 <code>ZoneId</code>，就得到了 <code>ZonedDateTime</code>，继而可以获得了对应时区的 <code>LocalDateTime</code>。</p><p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和 <code>long</code>都可以互相转换：</p><p>┌─────────────┐<br>│LocalDateTime│────┐<br>└─────────────┘    │    ┌─────────────┐<br>├───&gt;│ZonedDateTime│<br>┌─────────────┐    │    └─────────────┘<br>│   ZoneId    │────┘           ▲<br>└─────────────┘      ┌─────────┴─────────┐<br>│                   │<br>▼                   ▼<br>┌─────────────┐     ┌─────────────┐<br>│   Instant   │&lt;───&gt;│    long     │<br>└─────────────┘     └─────────────┘<br>转换的时候，只需要留意 <code>long</code>类型以毫秒还是秒为单位即可。</p><h2 id="最佳实践">最佳实践</h2><p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p><p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p><h3 id="旧API转新API">旧API转新API</h3><p>如果要把旧式的 <code>Date</code>或 <code>Calendar</code>转换为新API对象，可以通过 <code>toInstant()</code>方法转换为 <code>Instant</code>对象，再继续转换为 <code>ZonedDateTime</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; Instant:</span></span><br><span class="line">Instant ins1 = <span class="keyword">new</span> Date().toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Instant ins2 = calendar.toInstant();</span><br><span class="line">ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure><p>从上面的代码还可以看到，旧的 <code>TimeZone</code>提供了一个 <code>toZoneId()</code>，可以把自己变成新的 <code>ZoneId</code>。</p><h3 id="新API转旧API">新API转旧API</h3><p>如果要把新的 <code>ZonedDateTime</code>转换为旧的API对象，只能借助 <code>long</code>型时间戳做一个“中转”：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZonedDateTime -&gt; long:</span></span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line"><span class="keyword">long</span> ts = zdt.toEpochSecond() * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Date:</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// long -&gt; Calendar:</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.clear();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));</span><br><span class="line">calendar.setTimeInMillis(zdt.toEpochSecond() * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>从上面的代码还可以看到，新的 <code>ZoneId</code>转换为旧的 <code>TimeZone</code>，需要借助 <code>ZoneId.getId()</code>返回的 <code>String</code>完成。</p><h3 id="在数据库中存储日期和时间">在数据库中存储日期和时间</h3><p>除了旧式的 <code>java.util.Date</code>，我们还可以找到另一个 <code>java.sql.Date</code>，它继承自 <code>java.util.Date</code>，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p><p>在数据库中，也存在几种日期和时间类型：</p><ul><li><code>DATETIME</code>：表示日期和时间；</li><li><code>DATE</code>：仅表示日期；</li><li><code>TIME</code>：仅表示时间；</li><li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li></ul><p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p><table><thead><tr><th>数据库</th><th>对应Java类（旧）</th><th>对应Java类（新）</th></tr></thead><tbody><tr><td>DATETIME</td><td>java.util.Date</td><td>LocalDateTime</td></tr><tr><td>DATE</td><td>java.sql.Date</td><td>LocalDate</td></tr><tr><td>TIME</td><td>java.sql.Time</td><td>LocalTime</td></tr><tr><td>TIMESTAMP</td><td>java.sql.Timestamp</td><td>LocalDateTime</td></tr></tbody></table><p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数 <code>long</code>表示，在数据库中存储为 <code>BIGINT</code>类型。</p><p>通过存储一个 <code>long</code>型时间戳，我们可以编写一个 <code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ts = <span class="number">1574208900000L</span>;</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.CHINA, <span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.US, <span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">timestampToString</span><span class="params">(<span class="keyword">long</span> epochMilli, Locale lo, String zoneId)</span> </span>&#123;</span><br><span class="line">        Instant ins = Instant.ofEpochMilli(epochMilli);</span><br><span class="line">        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class="line">        <span class="keyword">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述方法进行调用，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019年11月20日 上午8:15</span><br><span class="line">Nov 19, 2019, 7:15 PM</span><br></pre></td></tr></table></figure><h1>单元测试</h1><h2 id="编写JUnit测试">编写JUnit测试</h2><p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p><p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：<br>编写接口<br>│<br>▼<br>编写测试<br>│<br>▼<br>┌─&gt; 编写实现<br>│    │<br>│ N  ▼<br>└── 运行测试<br>│ Y<br>▼<br>任务完成</p><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p><p>我们先通过一个示例来看如何编写测试。假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p><p>n!=1×2×3×…×n</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试这个方法，一个很自然的想法是编写一个 <code>main()</code>方法，然后运行一些测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fact(<span class="number">10</span>) == <span class="number">3628800</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过运行 <code>main()</code>方法来运行测试代码。</p><p>不过，使用 <code>main()</code>方法测试有很多缺点：</p><p>一是只能有一个 <code>main()</code>方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，<code>expected: 3628800, but actual: 123456</code>，三是很难编写一组通用的测试代码。</p><p>因此，我们需要一种测试框架，帮助我们编写测试。</p><h3 id="JUnit">JUnit</h3><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p><p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p><p>以Eclipse为例，当我们已经编写了一个 <code>Factorial.java</code>文件后，我们想对其进行测试，需要编写一个对应的 <code>FactorialTest.java</code>文件，以 <code>Test</code>为后缀是一个惯例，并分别将其放入 <code>src</code>和 <code>test</code>目录中。最后，在 <code>Project</code> - <code>Properties</code> - <code>Java Build Path</code> - <code>Libraries</code>中添加 <code>JUnit 5</code>的库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1304076771917890/l" alt=""></p><p>整个项目结构如下</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1304076140675137/l" alt=""></p><p>我们来看一下 <code>FactorialTest.java</code>的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心测试方法 <code>testFact()</code>加上了 <code>@Test</code>注解，这是 <code>JUnit</code>要求的，它会把带有 <code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用 <code>assertEquals(1, Factorial.fact(1))</code>表示，期望 <code>Factorial.fact(1)</code>返回 <code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在Assertion类中定义。Assertion还定义了其他断言方法，例如：</p><ul><li><code>assertTrue()</code>: 期待结果为<code>true</code></li><li><code>assertFalse()</code>: 期待结果为<code>false</code></li><li><code>assertNotNull()</code>: 期待结果为<code>非null</code></li><li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><p>运行单元测试非常简单。选中 <code>FactorialTest.java</code>文件，点击 <code>Run</code> - <code>Run As</code> - <code>JUnit Test</code>，Eclipse会自动运行这个 <code>JUnit</code>测试，并显示结果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1304081469538370/l" alt=""></p><p>如果测试结果与预期不符，<code>assertEquals()</code>会抛出异常，我们就会得到一个测试失败的结果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1304081566007362/l" alt=""></p><p>在Failure Trace中，JUnit会告诉我们详细的错误结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: expected: &lt;<span class="number">3628800</span>&gt; but was: &lt;<span class="number">362880</span>&gt;</span><br><span class="line">at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:<span class="number">55</span>)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:<span class="number">195</span>)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:<span class="number">168</span>)</span><br><span class="line">at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:<span class="number">163</span>)</span><br><span class="line">at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:<span class="number">611</span>)</span><br><span class="line">at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:<span class="number">14</span>)</span><br><span class="line">at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at ...</span><br></pre></td></tr></table></figure><p>第一行的失败信息的意思是期待结果 <code>3628800</code>但是实际返回是 <code>362880</code>，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止。</p><p>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用 <code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p><blockquote><p>assertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.0000001);</p></blockquote><h3 id="单元测试的好处">单元测试的好处</h3><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p><p>在编写单元测试的时候，我们要遵循一定的规范：</p><p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为 <code>0</code>，<code>null</code>，空字符串 <code>&quot;&quot;</code>等情况。</p><h2 id="使用Fixture">使用Fixture</h2><p>在一个单元测试中，我们经常编写多个 <code>@Test</code>方法，来分组、分类对目标代码进行测试。</p><p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个 <code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p><p>我们来看一个具体的 <code>Calculator</code>的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n + x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sub</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n - x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过 <code>@BeforeEach</code>来初始化，通过 <code>@AfterEach</code>来清理资源：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="keyword">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="keyword">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="keyword">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="keyword">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>CalculatorTest</code>测试中，有两个标记为 <code>@BeforeEach</code>和 <code>@AfterEach</code>的方法，它们会在运行每个 <code>@Test</code>方法前后自动运行。</p><p>上面的测试代码在JUnit中运行顺序如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="keyword">new</span> CalculatorTest(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<code>@BeforeEach</code>和 <code>@AfterEach</code>会“环绕”在每个 <code>@Test</code>方法前后。</p><p>还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了 <code>@BeforeAll</code>和 <code>@AfterAll</code>，它们在运行所有 <code>@Test</code>前后运行，顺序如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeforeAll(CalculatorTest.class);</span><br><span class="line"><span class="keyword">for</span> (Method testMethod : findTestMethods(CalculatorTest.class)) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="keyword">new</span> CalculatorTest(); <span class="comment">// 创建Test实例</span></span><br><span class="line">    invokeBeforeEach(test);</span><br><span class="line">        invokeTestMethod(test, testMethod);</span><br><span class="line">    invokeAfterEach(test);</span><br><span class="line">&#125;</span><br><span class="line">invokeAfterAll(CalculatorTest.class);</span><br></pre></td></tr></table></figure><p>因为 <code>@BeforeAll</code>和 <code>@AfterAll</code>在所有 <code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Database db;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db = createDb(...);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dropDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>@BeforeAll</code>和 <code>@AfterAll</code>也只能标注在静态方法上。</p><p>因此，我们总结出编写Fixture的套路如下：</p><ol><li>对于实例变量，在 <code>@BeforeEach</code>中初始化，在 <code>@AfterEach</code>中清理，它们在 个 <code>@Test</code>方法中互不影响，因为是不同的实例；</li><li>对于静态变量，在 <code>@BeforeAll</code>中初始化，在 <code>@AfterAll</code>中清理，它们在各个 <code>@Test</code>方法中均是唯一实例，会影响各个 <code>@Test</code>方法。</li></ol><p>大多数情况下，使用 <code>@BeforeEach</code>和 <code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到 <code>@BeforeAll</code>和 <code>@AfterAll</code>。</p><p>最后，注意到每次运行一个 <code>@Test</code>方法前，JUnit首先创建一个 <code>XxxTest</code>实例，因此，每个 <code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个 <code>@Test</code>方法带到另一个 <code>@Test</code>方法。</p><h2 id="异常测试">异常测试</h2><p>在Java程序中，异常处理是非常重要的。</p><p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p><p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p><p>我们仍然用 <code>Factorial</code>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法入口，我们增加了对参数 <code>n</code>的检查，如果为负数，则直接抛出 <code>IllegalArgumentException</code>。</p><p>现在，我们希望对异常进行测试。在JUnit测试中，我们可以编写一个 <code>@Test</code>方法专门测试异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> Executable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit提供 <code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数 <code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行 <code>Factorial.fact(-1)</code>时，必定抛出 <code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p><p>有些童鞋会觉得编写一个 <code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述奇怪的 <code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p><h2 id="条件测试">条件测试</h2><p>在运行测试的时候，有些时候，我们需要排出某些 <code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个 <code>@Disabled</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBug101</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们不直接注释掉 <code>@Test</code>，而是要加一个 <code>@Disabled</code>？这是因为注释掉 <code>@Test</code>，JUnit就不知道这是个测试方法，而加上 <code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p><blockquote><p>Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</p></blockquote><p>类似 <code>@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的 <code>@Test</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigFile</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        String os = System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;C:\\&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (os.contains(<span class="string">&quot;mac&quot;</span>) || os.contains(<span class="string">&quot;linux&quot;</span>) || os.contains(<span class="string">&quot;unix&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/usr/local/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要测试 <code>getConfigFile()</code>这个方法，但是在Windows上跑，和在Linux上跑的代码路径不同，因此，针对两个系统的测试方法，其中一个只能在Windows上跑，另一个只能在Mac/Linux上跑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们给上述两个测试方法分别加上条件如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableOnOs</code>就是一个条件测试判断。</p><p>我们来看一些常用的条件测试：</p><p>不在Windows平台执行的测试，可以加上 <code>@DisabledOnOs(OS.WINDOWS)</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnNonWindowsOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on windows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在Java 9或更高版本执行的测试，可以加上 <code>@DisabledOnJre(JRE.JAVA_8)</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnJre(JRE.JAVA_8)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnJava9OrAbove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on java 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在64位操作系统上执行的测试，可以用 <code>@EnabledIfSystemProperty</code>判断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOn64bitSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on 64 bit system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传入环境变量 <code>DEBUG=true</code>才能执行的测试，可以用 <code>@EnabledIfEnvironmentVariable</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOnDebugMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在JUnit中运行所有测试的时候，JUnit会给出执行的结果。在IDE中，我们能很容易地看到没有执行的测试：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1304094455103553/l" alt="junit-conditional-test"></p><p>带有⊘标记的测试方法表示没有执行。</p><h2 id="参数化测试">参数化测试</h2><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个 <code>@ParameterizedTest</code>注解，用来进行参数化测试。</p><p>假设我们想对 <code>Math.abs()</code>进行测试，先用一组正数进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用一组负数进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbsNegative</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到参数化测试的注解是 <code>@ParameterizedTest</code>，而不是普通的 <code>@Test</code>。</p><p>实际的测试场景往往没有这么简单。假设我们自己编写了一个 <code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">capitalize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：参数如何传入？</p><p>最简单的方法是通过 <code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解：静态方法 <code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个 <code>String</code>，正好作为测试方法的两个参数传入。</p><div class="note info sample simple"><p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p></div><p>另一种传入测试参数的方法是使用 <code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用,分隔，因此，上述测试又可以改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有成百上千的测试输入，那么，直接写 <code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上 <code>@CsvFileSource</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit只在 <code>classpath</code>中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到 <code>test</code>目录下，内容如下：</p><p>apple, Apple<br>HELLO, Hello<br>JUnit, Junit<br>reSource, Resource</p><h1>加密与安全</h1><h2 id="编码算法">编码算法</h2><p>要学习编码算法，我们先来看一看什么是编码。</p><p>ASCII码就是一种编码，字母 <code>A</code>的编码是十六进制的 <code>0x41</code>，字母 <code>B</code>是 <code>0x42</code>，以此类推：</p><table><thead><tr><th>字母</th><th>ASCII编码</th></tr></thead><tbody><tr><td>A</td><td>0x41</td></tr><tr><td>B</td><td>0x42</td></tr><tr><td>C</td><td>0x43</td></tr><tr><td>D</td><td>0x44</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用 <code>Unicode</code>。而中文的中使用 <code>Unicode</code>编码就是 <code>0x4e2d</code>，使用 <code>UTF-8</code>则需要3个字节编码：</p><table><thead><tr><th>汉字</th><th>Unicode编码</th><th>UTF-8编码</th></tr></thead><tbody><tr><td>中</td><td>0x4e2d</td><td>0xe4b8ad</td></tr><tr><td>文</td><td>0x6587</td><td>0xe69687</td></tr><tr><td>编</td><td>0x7f16</td><td>0xe7bc96</td></tr><tr><td>码</td><td>0x7801</td><td>0xe7a081</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p><p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p><h3 id="URL编码">URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p><p>[<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87">https://www.baidu.com/s?wd=中文</a>]</p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul><li>如果字符是<code>A~Z</code>，<code>a~z</code>，<code>0~9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li></ul><p>例如：字符中的UTF-8编码是 <code>0xe4b8ad</code>，因此，它的URL编码是 <code>%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个 <code>URLEncoder</code>类来对任意字符串进行URL编码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String encoded = URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是 <code>%E4%B8%AD%E6%96%87%21</code>，中的URL编码是 <code>%E4%B8%AD</code>，文的URL编码是 <code>%E6%96%87</code>，<code>!</code>虽然是ASCII字符，也要对其编码为 <code>%21</code>。</p><p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成 <code>+</code>，而现在的URL编码标准要求空格被编码为 <code>%20</code>，不过，服务器都可以处理这两种情况。</p><p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的 <code>URLDecoder</code>就可以解码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String decoded = URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为 <code>%</code>前缀表示的文本，编码后的文本仅包含 <code>A~Z</code>，<code>a~z</code>，<code>0~9</code>，<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>和 <code>%</code>，便于浏览器和服务器处理</p><h3 id="Base64编码">Base64编码</h3><p>URL编码是对字符进行编码，表示成 <code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含 <code>A~Z</code>、<code>a~z</code>、<code>0~9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><p>举个例子：3个byte数据分别是 <code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到 <code>39</code>、<code>0b</code>、<code>22</code>和 <code>2d</code>：</p><p>┌───────────────┬───────────────┬───────────────┐<br>│      e4       │      b8       │      ad       │<br>└───────────────┴───────────────┴───────────────┘<br>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│<br>└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>┌───────────┬───────────┬───────────┬───────────┐<br>│    39     │    0b     │    22     │    2d     │<br>└───────────┴───────────┴───────────┴───────────┘<br>因为6位整数的范围总是 <code>0~63</code>，所以，能用64个字符表示：字符 <code>A~Z</code>对应索引 <code>0~25</code>，字符 <code>a~z</code>对应索引 <code>26~51</code>，字符 <code>0~9</code>对应索引 <code>52~61</code>，最后两个索引 <code>62</code>、<code>63</code>分别用字符 <code>+</code>和 <code>/</code>表示。</p><p>在Java中，二进制数据就是 <code>byte[]</code>数组。Java标准库提供了 <code>Base64</code>来对 <code>byte[]</code>数组进行编解码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码后得到 <code>5Lit</code>4个字符。要对 <code>Base64</code>解码，仍然用 <code>Base64</code>这个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的童鞋会问：如果输入的 <code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个 <code>0x00</code>，编码后，在结尾加一个 <code>=</code>表示补充了1个 <code>0x00</code>，加两个 <code>=</code>表示补充了2个 <code>0x00</code>，解码的时候，去掉末尾补充的一个或两个 <code>0x00</code>即可。</p><p>实际上，因为编码后的长度加上 <code>=</code>总是4的倍数，所以即使不加 <code>=</code>也可以计算出原始输入的 <code>byte[]</code>。Base64编码的时候可以用 <code>withoutPadding()</code>去掉 <code>=</code>，解码出来的结果是一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span>, <span class="number">0x21</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        System.out.println(b64encoded2);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为标准的Base64编码会出现 <code>+</code>、<code>/</code>和 <code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把 <code>+</code>变成 <code>-</code>，<code>/</code>变成 <code>_</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getUrlEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getUrlDecoder().decode(b64encoded);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。</p><p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p><h2 id="哈希算法">哈希算法</h2><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p><p>哈希算法最重要的特点就是：</p><ul><li>同的输入一定得到相同的输出；</li><li>不同的输入大概率得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java字符串的 <code>hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节 <code>int</code>整数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.hashCode(); <span class="comment">// 0x5e918d2</span></span><br><span class="line"><span class="string">&quot;hello, java&quot;</span>.hashCode(); <span class="comment">// 0x7a9d88e8</span></span><br><span class="line"><span class="string">&quot;hello, bob&quot;</span>.hashCode(); <span class="comment">// 0xa0dbae2f</span></span><br></pre></td></tr></table></figure><p>两个相同的字符串永远会计算出相同的 <code>hashCode</code>，否则基于 <code>hashCode</code>定位的 <code>HashMap</code>就无法正常工作。这也是为什么当我们自定义一个class时，覆写 <code>equals()</code>方法时我们必须正确覆写 <code>hashCode()</code>方法。</p><h3 id="哈希碰撞">哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;AaAaAa&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br><span class="line"><span class="string">&quot;BBAaBB&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br></pre></td></tr></table></figure><p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code>的 <code>hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashA(<span class="string">&quot;java001&quot;</span>) = <span class="string">&quot;123456&quot;</span></span><br><span class="line">hashA(<span class="string">&quot;java002&quot;</span>) = <span class="string">&quot;123457&quot;</span></span><br><span class="line">hashA(<span class="string">&quot;java003&quot;</span>) = <span class="string">&quot;123458&quot;</span></span><br></pre></td></tr></table></figure><p>那么很容易从输出 <code>123459</code>反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashB(<span class="string">&quot;java001&quot;</span>) = <span class="string">&quot;123456&quot;</span></span><br><span class="line">hashB(<span class="string">&quot;java002&quot;</span>) = <span class="string">&quot;580271&quot;</span></span><br><span class="line">hashB(<span class="string">&quot;java003&quot;</span>) = ???</span><br></pre></td></tr></table></figure><p>常用的哈希算法有：</p><table><thead><tr><th>算法</th><th>输出长度（位）</th><th>输出长度（字节）</th></tr></thead><tbody><tr><td>MD5</td><td>128 bits</td><td>16 bytes</td></tr><tr><td>SHA-1</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>RipeMD-160</td><td>160 bits</td><td>20 bytes</td></tr><tr><td>SHA-256</td><td>256 bits</td><td>32 bytes</td></tr><tr><td>SHA-512</td><td>512 bits</td><td>64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>MessageDigest</code>时，我们首先根据哈希算法获取一个 <code>MessageDigest</code>实例，然后，反复调用 <code>update(byte[])</code>输入数据。当输入结束后，调用 <code>digest()</code>方法获得 <code>byte[]</code>数组表示的摘要，最后，把它转换为十六进制的字符串。</p><p>运行上述代码，可以得到输入 <code>HelloWorld</code>的MD5是 <code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1305351978745921/l" alt="file-md5"></p><p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p><ul><li>数据库管理员能够看到用户明文口令；</li><li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li></ul><p>不存储用户的原始口令，那么如何对用户进行认证？</p><p>方法是存储用户口令的哈希，例如，MD5。</p><p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td>alice</td><td>25d55ad283aa400af464c76d713c07ad</td></tr><tr><td>tim</td><td>bed128365216c019988915ed3add75fb</td></tr></tbody></table><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。</p><p>什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p><p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p><table><thead><tr><th>常用口令</th><th>MD5</th></tr></thead><tbody><tr><td>hello123</td><td>f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td>12345678</td><td>25d55ad283aa400af464c76d713c07ad</td></tr><tr><td>passw0rd</td><td>bed128365216c019988915ed3add75fb</td></tr><tr><td>19700101</td><td>570da6d5277a646f6552b8832012f5dc</td></tr><tr><td>…</td><td>…</td></tr><tr><td>20201231</td><td>6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p><p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p><p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p><p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p><p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p><p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><p>digest = md5(salt+inputPassword)<br>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th>username</th><th>salt</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>H1r0a</td><td>a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td>alice</td><td>7$p2w</td><td>e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td>tim</td><td>z5Sk9</td><td>1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p><h3 id="SHA-1">SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为 <code>&quot;SHA-1&quot;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，计算SHA-256，我们需要传入名称 <code>&quot;SHA-256&quot;</code>，计算SHA-512，我们需要传入名称 <code>&quot;SHA-512&quot;</code>。Java标准库支持的所有哈希算法可以在<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms">这里</a>查到。</p><div class="note info sample simple"><p>注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。</p></div><h2 id="BouncyCastle">BouncyCastle</h2><p>我们知道，Java标准库提供了一系列常用的哈希算法。</p><p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p><p>方法一：自己写一个，难度很大；</p><p>方法二：找一个现成的第三方库，直接使用。</p><p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p><p>我们来看一下如何使用BouncyCastle这个第三方提供的算法。</p><p>首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是 <code>bcprov-jdk15on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p><p>Java标准库的 <code>java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注册BouncyCastle:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 按名称正常调用:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;RipeMD160&quot;</span>);</span><br><span class="line">        md.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，注册BouncyCastle是通过下面的语句实现的：</p><blockquote><p>Security.addProvider(new BouncyCastleProvider());</p></blockquote><p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p><h2 id="Hmac算法">Hmac算法</h2><p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p><p>我们回顾一下哈希算法：</p><blockquote><p>digest = hash(input)</p></blockquote><p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p><blockquote><p>digest = hash(salt + input)</p></blockquote><p>这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p><blockquote><p>HmacMD5 ≈ md5(secure_random_key, input)</p></blockquote><p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p><ul><li>HmacMD5使用的key长度是64字节，更安全；</li><li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li><li>Hmac输出和原有的哈希算法长度一致。</li></ul><p>可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p><p>为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        SecretKey key = keyGen.generateKey();</span><br><span class="line">        <span class="comment">// 打印随机生成的key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] skey = key.getEncoded();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, skey).toString(<span class="number">16</span>));</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和MD5相比，使用HmacMD5的步骤是：</p><ol><li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li><li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li><li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li><li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li><li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li><li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li></ol><p>我们可以用 <code>Hmac</code>算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p><table><thead><tr><th>username</th><th>secret_key (64 bytes)</th><th>password</th></tr></thead><tbody><tr><td>bob</td><td>a8c06e05f92e…5e16</td><td>7e0387872a57c85ef6dddbaa12f376de</td></tr><tr><td>alice</td><td>e6a343693985…f4be</td><td>c1f929ac2552642b302e739bc0cdbaac</td></tr><tr><td>tim</td><td>f27a973dfdc0…6003</td><td>af57651c3a8a73303515804d4af43790</td></tr></tbody></table><p>有了Hmac计算的哈希和 <code>SecretKey</code>，我们想要验证怎么办？这时，<code>SecretKey</code>不能从 <code>KeyGenerator</code>生成，而是从一个 <code>byte[]</code>数组恢复：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hkey = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">106</span>, <span class="number">70</span>, -<span class="number">110</span>, <span class="number">125</span>, <span class="number">39</span>, -<span class="number">20</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">9</span>, -<span class="number">19</span>, -<span class="number">72</span>, <span class="number">52</span>, -<span class="number">53</span>, <span class="number">52</span>, -<span class="number">45</span>, -<span class="number">6</span>, <span class="number">119</span>, -<span class="number">63</span>,</span><br><span class="line">                <span class="number">30</span>, <span class="number">20</span>, -<span class="number">83</span>, -<span class="number">28</span>, <span class="number">77</span>, <span class="number">98</span>, <span class="number">109</span>, -<span class="number">32</span>, -<span class="number">76</span>, <span class="number">121</span>, -<span class="number">106</span>, <span class="number">0</span>, -<span class="number">74</span>, -<span class="number">107</span>, -<span class="number">114</span>, -<span class="number">45</span>, <span class="number">104</span>, -<span class="number">104</span>, -<span class="number">8</span>, <span class="number">2</span>, <span class="number">121</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">97</span>, -<span class="number">18</span>, -<span class="number">13</span>, -<span class="number">63</span>, -<span class="number">30</span>, -<span class="number">125</span>, -<span class="number">103</span>, -<span class="number">80</span>, -<span class="number">46</span>, <span class="number">113</span>, -<span class="number">14</span>, <span class="number">68</span>, <span class="number">32</span>, -<span class="number">46</span>, <span class="number">101</span>, -<span class="number">116</span>, -<span class="number">104</span>, -<span class="number">81</span>, -<span class="number">108</span>, <span class="number">122</span>,</span><br><span class="line">                <span class="number">89</span>, -<span class="number">106</span>, -<span class="number">109</span> &#125;;</span><br><span class="line"></span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(hkey, <span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        <span class="comment">// [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复 <code>SecretKey</code>的语句就是 <code>new SecretKeySpec(hkey, &quot;HmacMD5&quot;)</code>。</p><h2 id="对称加密算法">对称加密算法</h2><p>对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1306480187801666/l" alt="winrar"></p><p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p><blockquote><p>secret = encrypt(key, message);</p></blockquote><p>而解密则相反，它接收密码和密文，然后输出明文：</p><blockquote><p>plain = decrypt(key, secret);</p></blockquote><p>在软件开发中，常用的对称加密算法有：</p><table><thead><tr><th>算法</th><th>密钥长度</th><th>工作模式</th><th>填充模式</th></tr></thead><tbody><tr><td>DES</td><td>56/64</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/…</td></tr><tr><td>AES</td><td>128/192/256</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td>IDEA</td><td>128</td><td>ECB</td><td>PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p><p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p><h3 id="使用AES加密">使用AES加密</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p><ol><li>根据算法名称/工作模式/填充模式获取Cipher实例；</li><li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li><li>使用SerectKey初始化Cipher实例，并设置加密或解密模式；</li><li>传入明文或密文，获得密文或明文。</li></ol><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        SecureRandom sr = SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="keyword">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] iv = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] join(<span class="keyword">byte</span>[] bs1, <span class="keyword">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] r = <span class="keyword">new</span> <span class="keyword">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CBC模式下，需要一个随机生成的16字节IV参数，必须使用 <code>SecureRandom</code>生成。因为多了一个 <code>IvParameterSpec</code>实例，因此，初始化方法需要调用 <code>Cipher</code>的一个重载方法并传入 <code>IvParameterSpec</code>。</p><p>观察输出，可以发现每次生成的IV不同，密文也不同。</p><h2 id="口令加密算法">口令加密算法</h2><p>上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。</p><p>这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p><p>但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？</p><p>实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p><p>PBE就是Password Based Encryption的缩写，它的作用如下：</p><blockquote><p>key = generate(userPassword, secureRandomPassword);</p></blockquote><p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密口令:</span></span><br><span class="line">        String password = <span class="string">&quot;hello12345&quot;</span>;</span><br><span class="line">        <span class="comment">// 16 bytes随机Salt:</span></span><br><span class="line">        <span class="keyword">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="number">16</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;salt: %032x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, salt));</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(password, salt, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(password, salt, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是 <code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用 <code>Cipher</code>的 <code>init()</code>方法时同时传入 <code>SecretKey</code>和 <code>PBEParameterSpec</code>实现的。在创建 <code>PBEParameterSpec</code>的时候，我们还指定了循环次数 <code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p><p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p><h2 id="密钥交换算法">密钥交换算法</h2><p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p><p>现在问题来了：如何传递密钥？</p><p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p><p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p><p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p><p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p><ol><li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数a，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li><li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li><li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li></ol><p>所以最终双方协商出的密钥 <code>s</code>是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的 <code>p</code>，<code>g</code>，<code>A</code>和 <code>B</code>是无法推算出s的，因为实际算法选择的素数是非常大的。</p><p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p><p>如果我们把 <code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥 <code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的 <code>secretKey</code>是相同的。</p><p>使用Java实现DH算法的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyAgreement;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bob和Alice:</span></span><br><span class="line">        Person bob = <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自生成KeyPair:</span></span><br><span class="line">        bob.generateKeyPair();</span><br><span class="line">        alice.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双方交换各自的PublicKey:</span></span><br><span class="line">        <span class="comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        bob.generateSecretKey(alice.publicKey.getEncoded());</span><br><span class="line">        <span class="comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        alice.generateSecretKey(bob.publicKey.getEncoded());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查双方的本地密钥是否相同:</span></span><br><span class="line">        bob.printKeys();</span><br><span class="line">        alice.printKeys();</span><br><span class="line">        <span class="comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地KeyPair:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            kpGen.initialize(<span class="number">512</span>);</span><br><span class="line">            KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">            <span class="keyword">this</span>.privateKey = kp.getPrivate();</span><br><span class="line">            <span class="keyword">this</span>.publicKey = kp.getPublic();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSecretKey</span><span class="params">(<span class="keyword">byte</span>[] receivedPubKeyBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从byte[]恢复PublicKey:</span></span><br><span class="line">            X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(receivedPubKeyBytes);</span><br><span class="line">            KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            PublicKey receivedPublicKey = kf.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 生成本地密钥:</span></span><br><span class="line">            KeyAgreement keyAgreement = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            keyAgreement.init(<span class="keyword">this</span>.privateKey); <span class="comment">// 自己的PrivateKey</span></span><br><span class="line">            keyAgreement.doPhase(receivedPublicKey, <span class="keyword">true</span>); <span class="comment">// 对方的PublicKey</span></span><br><span class="line">            <span class="comment">// 生成SecretKey密钥:</span></span><br><span class="line">            <span class="keyword">this</span>.secretKey = keyAgreement.generateSecret();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Name: %s\n&quot;</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Private key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.privateKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Public key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.publicKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secret key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.secretKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p><h2 id="非对称加密算法">非对称加密算法</h2><p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p><p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p><p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p><p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要 <code>N*(N-1)/2</code>个密钥，因此每个人需要管理 <code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p><p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p><p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p><ol><li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li><li>小红用自己的RSA私钥解密得到AES口令；</li><li>双方使用这个共享的AES口令用AES加密通信。</li></ol><p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p><p>Java标准库提供了RSA算法的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 明文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] plain = <span class="string">&quot;Hello, encrypt use RSA&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建公钥／私钥对:</span></span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 用Alice的公钥加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] pk = alice.getPublicKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;public key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, pk)));</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = alice.encrypt(plain);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 用Alice的私钥解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sk = alice.getPrivateKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;private key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sk)));</span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = alice.decrypt(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 私钥:</span></span><br><span class="line">    PrivateKey sk;</span><br><span class="line">    <span class="comment">// 公钥:</span></span><br><span class="line">    PublicKey pk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 生成公钥／私钥对:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        <span class="keyword">this</span>.sk = kp.getPrivate();</span><br><span class="line">        <span class="keyword">this</span>.pk = kp.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把私钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPrivateKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把公钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPublicKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">this</span>.pk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">this</span>.sk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RSA的公钥和私钥都可以通过 <code>getEncoded()</code>方法获得以 <code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从 <code>byte[]</code>数组恢复公钥或私钥，可以这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] pkData = ...</span><br><span class="line"><span class="keyword">byte</span>[] skData = ...</span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="comment">// 恢复公钥:</span></span><br><span class="line">X509EncodedKeySpec pkSpec = <span class="keyword">new</span> X509EncodedKeySpec(pkData);</span><br><span class="line">PublicKey pk = kf.generatePublic(pkSpec);</span><br><span class="line"><span class="comment">// 恢复私钥:</span></span><br><span class="line">PKCS8EncodedKeySpec skSpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(skData);</span><br><span class="line">PrivateKey sk = kf.generatePrivate(skSpec);</span><br></pre></td></tr></table></figure><p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p><p>如果修改待加密的 <code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p><p>此外，只使用非对称加密算法不能防止中间人攻击。</p><h2 id="签名算法">签名算法</h2><p>我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p><p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p><p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p><p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如 <code>小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认 <code>小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p><p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p><blockquote><p>signature = encrypt(privateKey, sha256(message))</p></blockquote><p>对签名进行验证实际上就是用公钥解密：</p><blockquote><p>hash = decrypt(publicKey, signature)</p></blockquote><p>然后把解密后的哈希与原始消息的哈希进行对比。</p><p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p><p>常用数字签名算法有：</p><ul><li>MD5withRSA</li><li>SHA1withRSA</li><li>SHA256withRSA</li></ul><p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        PrivateKey sk = kp.getPrivate();</span><br><span class="line">        PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待签名的消息:</span></span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, I am Bob!&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用私钥签名:</span></span><br><span class="line">        Signature s = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        s.initSign(sk);</span><br><span class="line">        s.update(message);</span><br><span class="line">        <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用公钥验证:</span></span><br><span class="line">        Signature v = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        v.initVerify(pk);</span><br><span class="line">        v.update(message);</span><br><span class="line">        <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">        System.out.println(<span class="string">&quot;valid? &quot;</span> + valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p><h3 id="DSA签名">DSA签名</h3><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p><p>DSA只能配合SHA使用，常用的算法有：</p><ul><li>SHA1withDSA</li><li>SHA256withDSA</li><li>SHA512withDSA</li></ul><p>和RSA数字签名相比，DSA的优点是更快。</p><h3 id="ECDSA签名">ECDSA签名</h3><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p><h2 id="数字证书">数字证书</h2><p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p><p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p><p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1311504758472770/l" alt="cert"></p><p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p><p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keytool -storepass <span class="number">123456</span> -genkeypair -keyalg RSA -keysize <span class="number">1024</span> -sigalg SHA1withRSA -validity <span class="number">3650</span> -alias mycert -keystore my.keystore -dname <span class="string">&quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot;</span></span><br></pre></td></tr></table></figure><p>几个主要的参数是：</p><ul><li>keyalg：指定RSA加密算法；</li><li>sigalg：指定SHA1withRSA签名算法；</li><li>validity：指定证书有效期3650天；</li><li>alias：指定证书在程序中引用的名称；</li><li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li></ul><p>执行上述命令，JDK会在当前目录创建一个 <code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是 <code>mycert</code>。</p><p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, use X.509 cert!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取KeyStore:</span></span><br><span class="line">        KeyStore ks = loadKeyStore(<span class="string">&quot;/my.keystore&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取私钥:</span></span><br><span class="line">        PrivateKey privateKey = (PrivateKey) ks.getKey(<span class="string">&quot;mycert&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">        <span class="comment">// 读取证书:</span></span><br><span class="line">        X509Certificate certificate = (X509Certificate) ks.getCertificate(<span class="string">&quot;mycert&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 签名:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sign)));</span><br><span class="line">        <span class="comment">// 验证签名:</span></span><br><span class="line">        <span class="keyword">boolean</span> verified = verify(certificate, message, sign);</span><br><span class="line">        System.out.println(<span class="string">&quot;verify: &quot;</span> + verified);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">loadKeyStore</span><span class="params">(String keyStoreFile, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;file not found in classpath: &quot;</span> + keyStoreFile);</span><br><span class="line">            &#125;</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            ks.load(input, password.toCharArray());</span><br><span class="line">            <span class="keyword">return</span> ks;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(X509Certificate certificate, <span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(PrivateKey privateKey, <span class="keyword">byte</span>[] data) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class="keyword">byte</span>[] message)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(X509Certificate certificate, <span class="keyword">byte</span>[] message, <span class="keyword">byte</span>[] sig)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initVerify(certificate);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.verify(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以 <code>PrivateKey</code>实例表示，公钥以 <code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p><p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p><ol><li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li><li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li><li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li></ol><p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p><p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商 <code>DigiNotar</code>就发生过私钥泄漏导致公司破产的事故。</p><h1>多线程</h1><p>多线程是Java最基本的一种并发模型，本章我们将详细介绍Java多线程编程。</p><h2 id="多线程基础">多线程基础</h2><h3 id="进程">进程</h3><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。<br>┌──────────┐<br>│Process   │<br>│┌────────┐│<br>┌──────────┐││ Thread ││┌──────────┐<br>│Process   ││└────────┘││Process   │<br>│┌────────┐││┌────────┐││┌────────┐│<br>┌──────────┐││ Thread ││││ Thread ││││ Thread ││<br>│Process   ││└────────┘││└────────┘││└────────┘│<br>│┌────────┐││┌────────┐││┌────────┐││┌────────┐│<br>││ Thread ││││ Thread ││││ Thread ││││ Thread ││<br>│└────────┘││└────────┘││└────────┘││└────────┘│<br>└──────────┘└──────────┘└──────────┘└──────────┘<br>┌──────────────────────────────────────────────┐<br>│               Operating System               │<br>└──────────────────────────────────────────────┘<br>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p><p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p><p>多进程模式（每个进程只有一个线程）：</p><p>┌──────────┐ ┌──────────┐ ┌──────────┐<br>│Process   │ │Process   │ │Process   │<br>│┌────────┐│ │┌────────┐│ │┌────────┐│<br>││ Thread ││ ││ Thread ││ ││ Thread ││<br>│└────────┘│ │└────────┘│ │└────────┘│<br>└──────────┘ └──────────┘ └──────────┘<br>多线程模式（一个进程有多个线程）：</p><p>┌────────────────────┐<br>│Process             │<br>│┌────────┐┌────────┐│<br>││ Thread ││ Thread ││<br>│└────────┘└────────┘│<br>│┌────────┐┌────────┐│<br>││ Thread ││ Thread ││<br>│└────────┘└────────┘│<br>└────────────────────┘<br>多进程＋多线程模式（复杂度最高）：</p><p>┌──────────┐┌──────────┐┌──────────┐<br>│Process   ││Process   ││Process   │<br>│┌────────┐││┌────────┐││┌────────┐│<br>││ Thread ││││ Thread ││││ Thread ││<br>│└────────┘││└────────┘││└────────┘│<br>│┌────────┐││┌────────┐││┌────────┐│<br>││ Thread ││││ Thread ││││ Thread ││<br>│└────────┘││└────────┘││└────────┘│<br>└──────────┘└──────────┘└──────────┘</p><h3 id="进程-vs-线程">进程 vs 线程</h3><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。<br>而多进程的优点在于：</li></ul><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><h3 id="多线程">多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行 <code>main()</code>方法，在 <code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p><h2 id="创建新线程">创建新线程</h2><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行 <code>main()</code>方法。在 <code>main()</code>方法中，我们又可以启动其他线程。</p><p>要创建一个新线程非常容易，我们需要实例化一个 <code>Thread</code>实例，然后调用它的 <code>start()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p><p>方法一：从 <code>Thread</code>派生一个自定义类，然后覆写 <code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，注意到 <code>start()</code>方法会在内部自动调用实例的 <code>run()</code>方法。</p><p>方法二：创建 <code>Thread</code>实例时，传入一个 <code>Runnable</code>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用Java8引入的 <code>lambda</code>语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线程执行的打印语句，和直接在main()方法执行有区别吗？</p><p>区别大了去了。我们看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>线程执行的代码有4行，首先打印 <code>main start</code>，然后创建 <code>Thread</code>对象，紧接着调用 <code>start()</code>启动新线程。当 <code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量t来表示这个新线程对象，并开始执行。</p><p>接着，<code>main</code>线程继续执行打印 <code>main end</code>语句，而t线程在 <code>main</code>线程执行的同时会并发执行，打印 <code>thread run</code>和 <code>thread end</code>语句。</p><p>当 <code>run()</code>方法结束时，新线程就结束了。而 <code>main()</code>方法结束时，主线程也结束了。</p><p>我们再来看线程的执行顺序：</p><ol><li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；<br>2.<code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li></ol><p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在 <code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从 <code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p><p>要模拟并发执行的效果，我们可以在线程中调用 <code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到 <code>main</code>线程和 <code>t</code>线程执行的先后顺序。</p><p>要特别注意：直接调用 <code>Thread</code>实例的 <code>run()</code>方法是无效的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接调用 <code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在 <code>main()</code>方法内部又调用了 <code>run()</code>方法，打印 <code>hello</code>语句是在 <code>main</code>线程中执行的，没有任何新线程被创建。</p><p>必须调用 <code>Thread</code>实例的 <code>start()</code>方法才能启动新线程，如果我们查看 <code>Thread</code>类的源代码，会看到 <code>start()</code>方法内部调用了一个 <code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p><h3 id="线程的优先级">线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p><blockquote><p>Thread.setPriority(int n) // 1~10, 默认值5</p></blockquote><p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p><p><code>n</code>越大，优先级越高</p><h2 id="线程状态">线程状态</h2><p>在Java程序中，一个线程对象只能调用一次 <code>start()</code>方法启动新线程，并在新线程中执行 <code>run()</code>方法。一旦 <code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li><code>New</code>：新创建的线程，尚未执行；</li><li><code>Runnable</code>：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li><code>Blocked</code>：运行中的线程，因为某些操作被阻塞而挂起；</li><li><code>Waiting</code>：运行中的线程，因为某些操作在等待中；</li><li><code>Timed Waiting</code>：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li><code>Terminated</code>：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>用一个状态转移图表示如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│     New     │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br></pre></td></tr></table></figure><p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>┌─────────────┐ ┌─────────────┐<br>││  Runnable   │ │   Blocked   ││<br>└─────────────┘ └─────────────┘<br>│┌─────────────┐ ┌─────────────┐│<br>│   Waiting   │ │Timed Waiting│<br>│└─────────────┘ └─────────────┘│<br>─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─<br>│<br>▼<br>┌─────────────┐<br>│ Terminated  │<br>└─────────────┘<br>当线程启动后，它可以在 <code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和 <code>Timed Waiting</code>这几个状态之间切换，直到最后变成 <code>Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到return语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动 <code>t</code>线程后，可以通过 <code>t.join()</code>等待t线程结束后再继续运行：</p><p>当 <code>main</code>线程对线程对象 <code>t</code>调用 <code>join()</code>方法时，主线程将等待变量t表示的线程运行结束，即 <code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是 <code>main</code>线程先打印 <code>start</code>，<code>t</code>线程再打印 <code>hello</code>，<code>main</code>线程最后再打印 <code>end</code>。</p><p>如果t线程已经结束，对实例t调用 <code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><h2 id="中断线程">中断线程</h2><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行 <code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用 <code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p><p>我们还是看示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure><p>仔细看上述代码，<code>main</code>线程通过调用 <code>t.interrupt()</code>方法中断t线程，但是要注意，<code>interrupt()</code>方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而t线程的 <code>while</code>循环会检测 <code>isInterrupted()</code>，所以上述代码能正确响应 <code>interrupt()</code>请求，使得自身立刻结束运行 <code>run()</code>方法。</p><p>如果线程处于等待状态，例如，<code>t.join()</code>会让 <code>main</code>线程进入等待状态，此时，如果对 <code>main</code>线程调用 <code>interrupt()</code>，<code>join()</code>方法会立刻抛出 <code>InterruptedException</code>，因此，目标线程只要捕获到 <code>join()</code>方法抛出的 <code>InterruptedException</code>，就说明有其他线程对其调用了 <code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p><p>我们来看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// 2 hello!</span></span><br><span class="line"><span class="comment">// 3 hello!</span></span><br><span class="line"><span class="comment">// 4 hello!</span></span><br><span class="line"><span class="comment">// 5 hello!</span></span><br><span class="line"><span class="comment">// 6 hello!</span></span><br><span class="line"><span class="comment">// 7 hello!</span></span><br><span class="line"><span class="comment">// 8 hello!</span></span><br><span class="line"><span class="comment">// 9 hello!</span></span><br><span class="line"><span class="comment">// 10 hello!</span></span><br><span class="line"><span class="comment">// interrupted!</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure><p><code>main</code>线程通过调用 <code>t.interrupt()</code>从而通知t线程中断，而此时 <code>t</code>线程正位于 <code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出 <code>InterruptedException</code>。由于我们在t线程中捕获了 <code>InterruptedException</code>，因此，就可以准备结束该线程。在t线程结束前，对 <code>hello</code>线程也进行了 <code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现 <code>hello</code>线程仍然会继续运行，且JVM不会退出。</p><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个 <code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把 <code>HelloThread.running</code>置为 <code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 hello!</span></span><br><span class="line"><span class="comment">// end!</span></span><br></pre></td></tr></table></figure><p>注意到 <code>HelloThread</code>的标志位 <code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用 <code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字 <code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><p>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>Main Memory<br>│                               │<br>┌───────┐┌───────┐┌───────┐<br>│  │ var A ││ var B ││ var C │  │<br>└───────┘└───────┘└───────┘<br>│     │ ▲               │ ▲     │<br>─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─<br>│ │               │ │<br>┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐<br>▼ │               ▼ │<br>│  ┌───────┐  │   │  ┌───────┐  │<br>│ var A │         │ var C │<br>│  └───────┘  │   │  └───────┘  │<br>Thread 1          Thread 2<br>└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘<br>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量 <code>a = true</code>，线程1执行 <code>a = false</code>时，它在此刻仅仅是把变量a的副本变成了 <code>false</code>，主内存的变量 <code>a</code>还是 <code>true</code>，在JVM把修改后的a回写到主内存之前，其他线程读取到的 <code>a</code>的值仍然是 <code>true</code>，这就造成了多线程之间共享的变量不一致。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉 <code>volatile</code>关键字，运行上述程序，发现效果和带 <code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h2 id="守护线程">守护线程</h2><p>Java程序入口就是由JVM启动 <code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p><p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p><p>答案是使用 <code>守护线程（Daemon Thread）</code>。</p><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>因此，JVM退出时，不必关心守护线程是否已结束。</p><p>如何创建守护线程呢？方法和普通线程一样，只是在调用 <code>start()</code>方法前，调用 <code>setDaemon(true)</code>把该线程标记为守护线程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><h2 id="线程同步">线程同步</h2><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，两个线程同时对一个 <code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p><p>例如，对于语句：</p><blockquote><p>n = n + 1;<br>看上去是一行语句，实际上对应了3条指令：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>我们假设n的值是100，如果两个线程同时执行 <code>n = n + 1</code>，得到的结果很可能不是102，而是101，原因在于：</p><p>┌───────┐    ┌───────┐<br>│Thread1│    │Thread2│<br>└───┬───┘    └───┬───┘<br>│            │<br>│ILOAD (100) │<br>│            │ILOAD (100)<br>│            │IADD<br>│            │ISTORE (101)<br>│IADD        │<br>│ISTORE (101)│<br>▼            ▼<br>如果线程1在执行 <code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行 <code>ILOAD</code>后获取的值仍然是 <code>100</code>，最终结果被两个线程的 <code>ISTORE</code>写入后变成了 <code>101</code>，而不是期待的 <code>102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p><p>┌───────┐     ┌───────┐<br>│Thread1│     │Thread2│<br>└───┬───┘     └───┬───┘<br>│             │<br>│-- lock –   │<br>│ILOAD (100)  │<br>│IADD         │<br>│ISTORE (101) │<br>│-- unlock – │<br>│             │-- lock –<br>│             │ILOAD (101)<br>│             │IADD<br>│             │ISTORE (102)<br>│             │-- unlock –<br>▼             ▼</p><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 <code>临界区（Critical Section）</code>，任何时候临界区最多只有一个线程能执行。</p><p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用 <code>synchronized</code>关键字对一个对象进行加锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用 <code>synchronized</code>改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><p>它表示用 <code>Counter.lock</code>实例作为锁，两个线程在执行各自的 <code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在 <code>synchronized</code>语句块结束会自动释放锁。这样一来，对 <code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><p>使用 <code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为 <code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>我们来概括一下如何使用 <code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><p>在使用 <code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在 <code>synchronized</code>结束处正确释放锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一个错误使用 <code>synchronized</code>的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock1) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock2) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果并不是0，这是因为两个线程各自的 <code>synchronized</code>锁住的不是同一个对象！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p><p>因此，使用 <code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p><p>我们再看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> Thread[] &#123; <span class="keyword">new</span> AddStudentThread(), <span class="keyword">new</span> DecStudentThread(), <span class="keyword">new</span> AddTeacherThread(), <span class="keyword">new</span> DecTeacherThread() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> studentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> teacherCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是 <code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的 <code>Counter.studentCount += 1</code>和 <code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和 <code>DecStudentThread</code>，<code>AddTeacherThread</code>和 <code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p><p><code>AddStudentThread</code>和 <code>DecStudentThread</code>使用 <code>lockStudent</code>锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddTeacherThread</code>和 <code>DecTeacherThread</code>使用 <code>lockTeacher</code>锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能最大化地提高执行效率。</p><h3 id="不需要synchronized的操作">不需要synchronized的操作</h3><p>JVM规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和 <code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在 <code>x64</code>平台的JVM是把 <code>long</code>和 <code>double</code>的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不需要同步。</p><p>对引用也是类似。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述赋值语句并不需要同步。</p><p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.last = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pair;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; first, last &#125;;</span><br><span class="line">        <span class="keyword">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不再需要同步，因为 <code>this.pair = ps</code>是引用赋值的原子操作。而语句：</p><blockquote><p>int[] ps = new int[] { first, last };</p></blockquote><p>这里的 <code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p><h2 id="同步方法">同步方法</h2><p>我们知道Java程序依靠 <code>synchronized</code>对线程进行同步，使用 <code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把 <code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，线程调用 <code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为 <code>synchronized</code>代码块在 <code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是 <code>this</code>，即当前实例，这又使得创建多个 <code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = Counter();</span><br><span class="line"><span class="keyword">var</span> c2 = Counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c1进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.dec();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c2进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.dec();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>现在，对于 <code>Counter</code>类，多线程可以正确调用。</p><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是 <code>“线程安全”</code>的（<code>thread-safe</code>），上面的 <code>Counter</code>类就是线程安全的。Java标准库的 <code>java.lang.StringBuffer</code>也是线程安全的。</p><p>还有一些不变类，例如 <code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是 <code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>除了上述几种少数情况，大部分类，例如 <code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么 <code>ArrayList</code>是可以安全地在线程间共享的。</p><div class="note info simple"><p>没有特殊说明时，一个类默认是非线程安全的。</p></div><p>我们再观察 <code>Counter</code>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们锁住的是 <code>this</code>实例时，实际上可以用 <code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>因此，用 <code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用this实例加锁。</p><p>我们再思考一下，如果对一个静态方法添加 <code>synchronized</code>修饰符，它锁住的是哪个对象？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>static</code>方法，是没有 <code>this</code>实例的，因为 <code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的 <code>Class</code>实例，因此，对 <code>static</code>方法添加 <code>synchronized</code>，锁住的是该类的Class实例。上述 <code>synchronized static</code>方法实际上相当于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再考察 <code>Counter</code>的 <code>get()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有同步，因为读一个 <code>int</code>变量不需要同步。</p><p>然而，如果我们把代码稍微改一下，返回一个包含两个 <code>int</code>的对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pair p = <span class="keyword">new</span> Pair();</span><br><span class="line">        p.first = first;</span><br><span class="line">        p.last = last;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就必须要同步了。</p><h2 id="死锁">死锁</h2><p>Java的线程锁是可重入的锁。</p><p>什么是可重入的锁？我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 <code>synchronized</code>修饰的 <code>add()</code>方法，一旦线程执行到 <code>add()</code>方法内部，说明它已经获取了当前实例的 <code>this</code>锁。如果传入的 <code>n &lt; 0</code>，将在 <code>add()</code>方法内部调用 <code>dec()</code>方法。由于 <code>dec()</code>方法也需要获取 <code>this</code>锁，现在问题来了：</p><p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p><p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p><p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录 <code>+1</code>，每退出 <code>synchronized</code>块，记录 <code>-1</code>，减到 <code>0</code>的时候，才会真正释放锁。</p><h3 id="死锁-2">死锁</h3><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="keyword">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="keyword">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行 <code>add()</code>和 <code>dec()</code>方法时：</p><ul><li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li><li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li></ul><p>随后：</p><ul><li>线程1：准备获得<code>lockB</code>，失败，等待中；</li><li>线程2：准备获得<code>lockA</code>，失败，等待中。</li></ul><p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p><p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p><p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p><p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取lockA，再获取 <code>lockB</code>的顺序，改写 <code>dec()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用wait和notify">使用wait和notify</h2><p>在Java程序中，synchronized解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用synchronized加锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>synchronized</code>并没有解决多线程协调的问题。</p><p>仍然以上面的 <code>TaskQueue</code>为例，我们再编写一个 <code>getTask()</code>方法取出队列的第一个任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p><p>但实际上 <code>while()</code>循环永远不会退出。因为线程在执行 <code>while()</code>循环时，已经在 <code>getTask()</code>入口获取了 <code>this</code>锁，其他线程根本无法调用 <code>addTask()</code>，因为 <code>addTask()</code>执行条件也是获取 <code>this</code>锁。</p><p>因此，执行上述代码，线程会在 <code>getTask()</code>中因为死循环而100%占用CPU资源。</p><p>如果深入思考一下，我们想要的执行效果是：</p><ul><li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li><li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li></ul><p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p><p>对于上述 <code>TaskQueue</code>，我们先改造 <code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程执行到 <code>getTask()</code>方法内部的 <code>while</code>循环时，它必定已经获取到了 <code>this</code>锁，此时，线程执行 <code>while</code>条件判断，如果条件成立（队列为空），线程将执行 <code>this.wait()</code>，进入等待状态。</p><p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是 <code>this</code>锁，因此调用 <code>this.wait()</code>。</p><p>调用 <code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p><p>有些仔细的童鞋会指出：即使线程在 <code>getTask()</code>内部等待，其他线程如果拿不到 <code>this</code>锁，照样无法执行 <code>addTask()</code>，肿么办？</p><p>这个问题的关键就在于 <code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在 <code>Object</code>类的一个 <code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在 <code>synchronized</code>块中才能调用 <code>wait()</code>方法，因为 <code>wait()</code>方法调用时，会释放线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p><p>因此，只能在锁对象上调用 <code>wait()</code>方法。因为在 <code>getTask()</code>中，我们获得了 <code>this</code>锁，因此，只能在 <code>this</code>对象上调用 <code>wait()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程在 <code>this.wait()</code>等待时，它就会释放 <code>this</code>锁，从而使得其他线程能够在 <code>addTask()</code>方法获得 <code>this</code>锁。</p><p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从 <code>wait()</code>方法返回？答案是在相同的锁对象上调用 <code>notify()</code>方法。我们修改 <code>addTask()</code>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在往队列中添加了任务后，线程立刻对 <code>this</code>锁对象调用 <code>notify()</code>方法，这个方法会唤醒一个正在 <code>this</code>锁等待的线程（就是在 <code>getTask()</code>中位于 <code>this.wait()</code>的线程），从而使得等待线程从 <code>this.wait()</code>方法返回。</p><p>我们来看一个完整的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> q = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                String s = <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们重点关注 <code>addTask()</code>方法，内部调用了 <code>this.notifyAll()</code>而不是 <code>this.notify()</code>，使用 <code>notifyAll()</code>将唤醒所有当前正在this锁等待的线程，而 <code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在 <code>getTask()</code>方法内部的 <code>wait()</code>中等待，使用 <code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用 <code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p><p>但是，注意到 <code>wait()</code>方法返回时需要重新获得 <code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行 <code>addTask()</code>的线程结束此方法后，才能释放 <code>this</code>锁，随后，这3个线程中只能有一个获取到 <code>this</code>锁，剩下两个将继续等待。</p><p>再注意到我们在 <code>while()</code>循环中调用 <code>wait()</code>，而不是if语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取 <code>this</code>锁。多个线程被唤醒后，只有一个线程能获取 <code>this</code>锁，此刻，该线程执行 <code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取 <code>this</code>锁后执行 <code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在 <code>while</code>循环中 <code>wait()</code>，并且每次被唤醒后拿到 <code>this</code>锁就必须再次判断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p><h2 id="使用ReentrantLock">使用ReentrantLock</h2><p>从Java 5开始，引入了一个高级的处理并发的 <code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>我们知道Java语言直接提供了 <code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p><p><code>java.util.concurrent.locks</code>包提供的 <code>ReentrantLock</code>用于替代 <code>synchronized</code>加锁，我们来看一下传统的 <code>synchronized</code>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <code>ReentrantLock</code>替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而 <code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在 <code>finally</code>中正确释放锁。</p><p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和 <code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p><p>和 <code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回 <code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用 <code>ReentrantLock</code>比直接使用 <code>synchronized</code>更安全，线程在 <code>tryLock()</code>失败的时候不会导致死锁。</p><h2 id="使用Condition">使用Condition</h2><p>使用 <code>ReentrantLock</code>比直接使用 <code>synchronized</code>更安全，可以替代 <code>synchronized</code>进行线程同步。</p><p>但是，<code>synchronized</code>可以配合 <code>wait</code>和 <code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用 <code>ReentrantLock</code>我们怎么编写 <code>wait</code>和 <code>notify</code>的功能呢？</p><p>答案是使用 <code>Condition</code>对象来实现 <code>wait</code>和 <code>notify</code>的功能。</p><p>我们仍然以 <code>TaskQueue</code>为例，把前面用 <code>synchronized</code>实现的功能通过 <code>ReentrantLock</code>和 <code>Condition</code>来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用 <code>Condition</code>时，引用的 <code>Condition</code>对象必须从 <code>Lock</code>实例的 <code>newCondition()</code>返回，这样才能获得一个绑定了 <code>Lock</code>实例的 <code>Condition</code>实例。</p><p><code>Condition</code>提供的 <code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和 <code>synchronized</code>锁对象的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li></ul><p>唤醒线程从 <code>await()</code>返回后需要重新获得锁。</p><p>此外，和 <code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过 <code>signal()</code>或 <code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用 <code>Condition</code>配合 <code>Lock</code>，我们可以实现更灵活的线程同步。</p><h2 id="使用ReadWriteLock">使用ReadWriteLock</h2><p>前面讲到的 <code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用 <code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p><p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p><p>||读|写|<br>||–|–|<br>|读|允许|不允许|<br>|写|不允许|不允许|</p><p>使用 <code>ReadWriteLock</code>可以解决这个问题，它保证：</p><p>只允许一个线程写入（其他线程既不能写入也不能读取）；<br>没有写入时，多个线程允许同时读（提高性能）。<br>用 <code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个 <code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p><p>使用 <code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p><p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用 <code>ReadWriteLock</code>。</p><h2 id="使用StampedLock">使用StampedLock</h2><p>前面介绍的 <code>ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p><p>如果我们深入分析 <code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code>。</p><p><code>StampedLock</code>和 <code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p>我们来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过 <code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过 <code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><p>可见，<code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是 <code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁。</p><p><code>StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在 <code>if-then-update</code>的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p><h2 id="使用Concurrent集合">使用Concurrent集合</h2><p>我们在前面已经通过 <code>ReentrantLock</code>和 <code>Condition</code>实现了一个 <code>BlockingQueue</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个 <code>TaskQueue</code>的 <code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p><p>因为 <code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用Java标准库的 <code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code>。</p><p>除了 <code>BlockingQueue</code>外，针对 <code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p><p>|interface|non-thread-safe|thread-safe|<br>|List|ArrayList|CopyOnWriteArrayList|<br>|Map|HashMap|ConcurrentHashMap|<br>|Set|HashSet / TreeSet|CopyOnWriteArraySet|<br>|Queue|ArrayDeque / LinkedList|ArrayBlockingQueue / LinkedBlockingQueue|<br>|Deque|ArrayDeque / LinkedList|LinkedBlockingDeque|</p><p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以 <code>ConcurrentHashMap</code>为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 在不同的线程读写:</span></span><br><span class="line">map.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.get(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p><blockquote><p>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</p></blockquote><p>改为：</p><blockquote><p>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</p></blockquote><p>就可以了。</p><p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure><p>但是它实际上是用一个包装类包装了非线程安全的 <code>Map</code>，然后对所有读写方法都用 <code>synchronized</code>加锁，这样获得的线程安全集合的性能比 <code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p><p>使用 <code>java.util.concurrent</code>包提供的线程安全的并发集合可以大大简化多线程编程：</p><p>多线程同时读写并发集合是安全的；</p><p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p><h2 id="使用Atomic">使用Atomic</h2><p>Java的 <code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于 <code>java.util.concurrent.atomic</code>包。</p><p>我们以 <code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p><code>Atomic</code>类是通过无锁 <code>（lock-free）</code>的方式实现的线程安全 <code>（thread-safe）</code>访问。它的主要原理是利用了 <code>CAS：Compare and Set</code>。</p><p>如果我们自己通过CAS编写 <code>incrementAndGet()</code>，它大概长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS是指，在这个操作中，如果 <code>AtomicInteger</code>的当前值是 <code>prev</code>，那么就更新为 <code>next</code>，返回 <code>true</code>。如果 <code>AtomicInteger</code>的当前值不是 <code>prev</code>，就什么也不干，返回 <code>false</code>。通过CAS操作并配合do … while循环，即使其他线程修改了 <code>AtomicInteger</code>的值，最终的结果也是正确的。</p><p>我们利用 <code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    AtomicLong <span class="keyword">var</span> = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们并不需要直接用 <code>do ... while</code>循环调用 <code>compareAndSet</code>实现复杂的并发操作，而是用 <code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p><p>在高度竞争的情况下，还可以使用Java 8提供的 <code>LongAdder</code>和 <code>LongAccumulator</code>。</p><h2 id="使用线程池">使用线程池</h2><p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p><p>如果可以复用一组线程：</p><p>┌─────┐ execute  ┌──────────────────┐<br>│Task1│─────────&gt;│ThreadPool        │<br>├─────┤          │┌───────┐┌───────┐│<br>│Task2│          ││Thread1││Thread2││<br>├─────┤          │└───────┘└───────┘│<br>│Task3│          │┌───────┐┌───────┐│<br>├─────┤          ││Thread3││Thread4││<br>│Task4│          │└───────┘└───────┘│<br>├─────┤          └──────────────────┘<br>│Task5│<br>├─────┤<br>│Task6│<br>└─────┘<br>…<br>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p><p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p><p>Java标准库提供了 <code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure><p>因为 <code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p><ul><li><code>FixedThreadPool</code>：线程数固定的线程池；</li><li><code>CachedThreadPool</code>：线程数根据任务动态调整的线程池；</li><li><code>SingleThreadExecutor</code>：仅单线程执行的线程池。</li></ul><p>创建这些线程池的方法都被封装到 <code>Executors</code>这个类中。我们以 <code>FixedThreadPool</code>为例，看看线程池的执行逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start task 0</span></span><br><span class="line"><span class="comment">// start task 1</span></span><br><span class="line"><span class="comment">// start task 2</span></span><br><span class="line"><span class="comment">// start task 3</span></span><br><span class="line"><span class="comment">// end task 0</span></span><br><span class="line"><span class="comment">// end task 2</span></span><br><span class="line"><span class="comment">// end task 1</span></span><br><span class="line"><span class="comment">// start task 4</span></span><br><span class="line"><span class="comment">// start task 5</span></span><br><span class="line"><span class="comment">// end task 3</span></span><br><span class="line"><span class="comment">// end task 4</span></span><br><span class="line"><span class="comment">// end task 5</span></span><br></pre></td></tr></table></figure><p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p><p>线程池在程序结束的时候要关闭。使用 <code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p><p>如果我们把线程池改为 <code>CachedThreadPool</code>，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p><p>如果我们想把线程池的大小限制在 <code>4～10</code>个之间动态调整怎么办？我们查看 <code>Executors.newCachedThreadPool()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，想创建指定动态范围的线程池，可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPool">ScheduledThreadPool</h3><p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用 <code>ScheduledThreadPool</code>。放入 <code>ScheduledThreadPool</code>的任务可以定期反复执行。</p><p>创建一个 <code>ScheduledThreadPool</code>仍然是通过Executors类：</p><blockquote><p>ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</p></blockquote><p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>如果任务以固定的每3秒执行，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>注意 <code>FixedRate</code>和 <code>FixedDelay</code>的区别。<code>FixedRate</code>是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p><p>│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░<br>├───────┼───────┼───────┼───────┼────&gt;<br>│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│<br>而 <code>FixedDelay</code>是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p><p>│░░░│       │░░░░░│       │░░│       │░<br>└───┼───────┼─────┼───────┼──┼───────┼──&gt;<br>│&lt;─────&gt;│     │&lt;─────&gt;│  │&lt;─────&gt;│<br>因此，使用 <code>ScheduledThreadPool</code>时，我们要根据需要选择执行一次、<code>FixedRate</code>执行还是 <code>FixedDelay</code>执行。</p><p>细心的童鞋还可以思考下面的问题：</p><p>在 <code>FixedRate</code>模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p><p>如果任务抛出了异常，后续任务是否继续执行？</p><p>Java标准库还提供了一个 <code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个 <code>Timer</code>会对应一个 <code>Thread</code>，所以，一个 <code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个 <code>Timer</code>，而一个 <code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用 <code>ScheduledThreadPool</code>取代旧的 <code>Timer</code>。</p><h2 id="使用Future">使用Future</h2><p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现 <code>Runnable</code>接口，就可以让线程池去执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个 <code>Callable</code>接口，和 <code>Runnable</code>接口比，它多了一个返回值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且 <code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p><p>现在的问题是，如何获得异步执行的结果？</p><p>如果仔细看 <code>ExecutorService.submit()</code>方法，可以看到，它返回了一个 <code>Future</code>类型，一个 <code>Future</code>类型的实例代表一个未来能获取结果的对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure><p>当我们提交一个 <code>Callable</code>任务后，我们会同时获得一个 <code>Future</code>对象，然后，我们在主线程某个时刻调用 <code>Future</code>对象的 <code>get()</code>方法，就可以获得异步执行的结果。在调用 <code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么 <code>get()</code>会阻塞，直到任务完成后才返回结果。</p><p>一个 <code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p><ul><li><code>get()</code>：获取结果（可能会等待）</li><li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li><li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li><li><code>isDone()</code>：判断任务是否已完成。</li></ul><h2 id="使用CompletableFuture">使用CompletableFuture</h2><p>使用 <code>Future</code>获得异步执行结果时，要么调用阻塞方法 <code>get()</code>，要么轮询看 <code>isDone()</code>是否为 <code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>从Java 8开始引入了 <code>CompletableFuture</code>，它针对 <code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><p>我们以获取股票价格为例，看看如何使用 <code>CompletableFuture</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了串行执行外，多个 <code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p><p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompletableFuture</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑实现的异步查询规则实际上是：</p><p>┌─────────────┐ ┌─────────────┐<br>│ Query Code  │ │ Query Code  │<br>│  from sina  │ │  from 163   │<br>└─────────────┘ └─────────────┘<br>│               │<br>└───────┬───────┘<br>▼<br>┌─────────────┐<br>│    anyOf    │<br>└─────────────┘<br>│<br>┌───────┴────────┐<br>▼                ▼<br>┌─────────────┐  ┌─────────────┐<br>│ Query Price │  │ Query Price │<br>│  from sina  │  │  from 163   │<br>└─────────────┘  └─────────────┘<br>│                │<br>└────────┬───────┘<br>▼<br>┌─────────────┐<br>│    anyOf    │<br>└─────────────┘<br>│<br>▼<br>┌─────────────┐<br>│Display Price│<br>└─────────────┘<br>除了 <code>anyOf()</code>可以实现“任意个 <code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有 <code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p><p>最后我们注意 <code>CompletableFuture</code>的命名规则：</p><ul><li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li><li><code>xxxAsync()</code>：表示将异步在线程池中执行</li></ul><h2 id="使用ForkJoin">使用ForkJoin</h2><p>Java 7开始引入了一种新的 <code>Fork/Join</code>线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p><p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p><p>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p><p>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘<br>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p><p>┌─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┘<br>┌─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┘<br>┌─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┘<br>┌─┬─┬─┬─┬─┬─┐<br>└─┴─┴─┴─┴─┴─┘<br>这就是 <code>Fork/Join</code>任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p><p>我们来看如何使用 <code>Fork/Join</code>对大数据进行并行求和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码的执行过程，一个大的计算任务 <code>0~2000</code>首先分裂为两个小任务 <code>0~1000</code>和 <code>1000~2000</code>，这两个小任务仍然太大，继续分裂为更小的 <code>0~500</code>，<code>500~1000</code>，<code>1000~1500</code>，<code>1500~2000</code>，最后，计算结果被依次合并，得到最终结果。</p><p>因此，核心代码 <code>SumTask</code>继承自 <code>RecursiveTask</code>，在 <code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p><p>因此，核心代码 <code>SumTask</code>继承自 <code>RecursiveTask</code>，在 <code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fork/Join</code>线程池在Java标准库中就有应用。Java标准库提供的 <code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过 <code>Fork/Join</code>对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度</p><h2 id="使用ThreadLocal">使用ThreadLocal</h2><p>多线程是Java实现多任务的基础，<code>Thread</code>对象代表一个线程，我们可以在代码中调用 <code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;start main...&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;run task...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;print...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log(<span class="string">&quot;end main.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    doWork();</span><br><span class="line">    saveStatus();</span><br><span class="line">    sendResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，通过线程池去执行这些任务。</p><p>观察 <code>process()</code>方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p><p><code>process()</code>方法需要传递的状态就是 <code>User</code>实例。有的童鞋会想，简单地传入 <code>User</code>就可以了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    checkPermission(user);</span><br><span class="line">    doWork(user);</span><br><span class="line">    saveStatus(user);</span><br><span class="line">    sendResponse(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是往往一个方法又会调用其他很多方法，这样会导致 <code>User</code>传递到所有地方：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    queryStatus(user);</span><br><span class="line">    checkStatus();</span><br><span class="line">    setNewStatus(user);</span><br><span class="line">    log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为 <code>上下文（Context）</code>，它是一种状态，可以是用户身份、任务信息等。</p><p>给每个方法增加一个 <code>context</code>参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，<code>User</code>对象就传不进去了。</p><p>Java标准库提供了一个特殊的 <code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p><p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p><blockquote><p>static ThreadLocal<code>&lt;User&gt;</code> threadLocalUser = new ThreadLocal&lt;&gt;();</p></blockquote><p>它的典型使用方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置一个 <code>User</code>实例关联到 <code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该 <code>User</code>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到普通的方法调用一定是同一个线程执行的，所以，<code>step1()</code>、<code>step2()</code>以及 <code>log()</code>方法内，<code>threadLocalUser.get()</code>获取的User对象是同一个实例。</p><p>实际上，可以把 <code>ThreadLocal</code>看成一个全局 <code>Map&lt;Thread, Object&gt;</code>：每个线程获取 <code>ThreadLocal</code>变量时，总是使用 <code>Thread</code>自身作为key：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object threadLocalValue = threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure><p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的 <code>ThreadLocal</code>关联的实例互不干扰。</p><p>最后，特别注意 <code>ThreadLocal</code>一定要在 <code>finally</code>中清除：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果 <code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p><p>为了保证能释放 <code>ThreadLocal</code>关联的实例，我们可以通过 <code>AutoCloseable</code>接口配合 <code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的 <code>ThreadLocal</code>可以封装为一个 <code>UserContext</code>对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，我们借助 <code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure><p>这样就在 <code>UserContext</code>中完全封装了 <code>ThreadLocal</code>，外部代码在 <code>try (resour) &#123;...&#125;</code>内部可以随时调用 <code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog搭建教程</title>
      <link href="/2022/01/19/blog%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/01/19/blog%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步">第一步</h2><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11245991882461293997">参考教程</a></p><p>前置教程：您需要</p><p>掌握git的基本语法<a class="btn-beautify outline" href="https://winfredliu.github.io/2022/01/18/git%E5%AD%A6%E4%B9%A0/index.html"   title="git学习"><i class="far fa-hand-point-right"></i><span>git学习</span></a><br>熟练使用markdown<a class="btn-beautify " href="https://winfredliu.github.io/2022/01/18/markdown%E5%AD%A6%E4%B9%A0/index.html"   title="Markdown 基本语法教程"><i class="far fa-hand-point-right"></i><span>Markdown 基本语法教程</span></a>。</p><p>也可以在网上自己寻找相关教程</p><h3 id="安装node-js">安装node.js</h3><p>访问[官网](<a href="https://nodejs.org/en/">nodejs.org</a></p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">教程</a></p><p>用<code>npm -v</code>来验证是否安装成功</p><h3 id="安装npm的国内镜像源-可选">安装npm的国内镜像源(可选)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>之后可将<code>npm</code>命令换为<code>cnpm</code></p><p>用<code>cnpm -v</code>来验证是否安装成功</p><h3 id="安装博客框架">安装博客框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>来验证是否安装成功</p><h3 id="使用hexo框架来搭建博客">使用hexo框架来搭建博客</h3><p>在电脑某一目录下，创建blog文件夹，然后在blog目录下运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>在本地4000端口来预览搭建的博客。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="第二步">第二步</h2><p>博客文章在blog-&gt;source-&gt;_posts下</p><h3 id="修改博客文章之后">修改博客文章之后</h3><p>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="将博客部署到github上公开使用">将博客部署到github上公开使用</h3><p>用户部署个人博客的GitHub仓库命令必须符合规范。<br>如：<br><img src="https://i.bmp.ovh/imgs/2022/01/5148007bd3fbab06.png" alt=""></p><h3 id="将博客部署到gitee上公开使用">将博客部署到gitee上公开使用</h3><p>用户部署个人博客的Gitee仓库命令必须符合规范。<br>如：<br><img src="https://i.bmp.ovh/imgs/2022/01/2925f2d9a54f0b86.png" alt=""></p><h3 id="在目录下安装git插件">在目录下安装git插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install  hexo -deploy-git --save</span><br></pre></td></tr></table></figure><h3 id="修改-config-yml文件">修改_config.yml文件</h3><p>如下图：<br><img src="https://i.bmp.ovh/imgs/2022/01/2994ad62386a908c.png" alt=""></p><h3 id="推送博客到远端">推送博客到远端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h4 id="gitee推动成功之后还要开启静态页面服务">gitee推动成功之后还要开启静态页面服务</h4><p>进入码云新建的仓库，开启 Gitee Pages<br>实名认证之后才可以开通。<br>审核之后就会出现你博客的网站。</p><h2 id="自定义博客主题">自定义博客主题</h2><p>运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>在_config.yml修改主题<br>如下图<br><img src="https://i.bmp.ovh/imgs/2022/01/bfbbc668ad1fe6f2.png" alt=""><br>安装以下插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>重新生成文件报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">err: YAMLException: end of the stream or a document separator is expected at line 2, column 1:</span><br></pre></td></tr></table></figure><p>原因一：md文件在Typora中修改过（编码不正常）。<br>建议：md最上面加上title并下划线分隔。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: git学习</span><br><span class="line">tag: git</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="自定义博客主题一">自定义博客主题一</h2><p><a href="https://butterfly.js.org/">详细教程</a><br>我的操作如下：</p><h3 id="新建页面">新建页面</h3><h4 id="标签页">标签页</h4><ol><li><p>前往你的 Hexo 博客的根目录（source目录下）</p></li><li><p>输入hexo new page tags</p></li><li><p>你会找到source/tags/index.md这个文件</p></li><li><p>修改这个文件：</p></li></ol><p>记得添加 type: “tags”</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2022-01-19 03:41:35</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h4 id="分类页">分类页</h4><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入hexo new page categories</p></li><li><p>你会找到source/categories/index.md这个文件</p></li><li><p>修改这个文件：</p></li></ol><p>记得添加 type: “categories”</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2022-01-19 04:22:04</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h4 id="友情链接">友情链接</h4><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入 hexo new page link</p></li><li><p>你会找到source/link/index.md这个文件</p></li><li><p>修改这个文件：</p></li></ol><p>记得添加 type: “link”</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2022-01-19 04:24:39</span><br><span class="line"><span class="section">type: &quot;link&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="友情链接添加">友情链接添加</h3><p>在Hexo博客目录中的source/_data（如果没有 _data 文件夹，请自行创建），创建一个文件link.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">stevenlin</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://steven900516.github.io/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://steven900516.github.io/img/friend_404.gif</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">lyxのblog</span></span><br></pre></td></tr></table></figure><p>name就是名字，link就是点击跳转的链接，avatar就是头像图片<br>示例：<img src="/img/example1.png" alt=""></p><h3 id="友情链接-2">友情链接</h3><p>主题内置了一个简单的404页面，在themes/butterfly寻找_config.yml进行修改</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;页面未找到&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png</span></span><br></pre></td></tr></table></figure><h2 id="自定义博客主题二">自定义博客主题二</h2><h3 id="front-master">front-master</h3><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于页面配置<br>Post Front-matter 用于文章页配置</p><h4 id="Page-Front-matter">Page Front-matter</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>具体解释如下：</p><table><thead><tr><th>title</th><th>【必需】</th><th>页面标题</th></tr></thead><tbody><tr><td>date</td><td>【必需】</td><td>页面创建日期</td></tr><tr><td>type</td><td>【必需】</td><td>标签、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】</td><td>页面更新日期</td></tr><tr><td>description</td><td>【可选】</td><td>页面描述</td></tr><tr><td>keywords</td><td>【可选】</td><td>页面关键字</td></tr><tr><td>comments</td><td>【可选】</td><td>显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】</td><td>显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】</td><td>显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】</td><td>显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】</td><td>在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】</td><td>配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h4 id="Post-Front-matter">Post Front-matter</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">aside:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>title</th><th>【必需】</th><th>文章标题</th></tr></thead><tbody><tr><td>date</td><td>【必需】</td><td>文章创建日期</td></tr><tr><td>updated</td><td>【可选】</td><td>文章更新日期</td></tr><tr><td>tags</td><td>【可选】</td><td>文章标签</td></tr><tr><td>categories</td><td>【可选】</td><td>文章分类</td></tr><tr><td>keywords</td><td>【可选】</td><td>文章关键字</td></tr><tr><td>description</td><td>【可选】</td><td>文章描述</td></tr><tr><td>top_img</td><td>【可选】</td><td>文章顶部图片</td></tr><tr><td>cover</td><td>【可选】</td><td>文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】</td><td>显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】</td><td>显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】</td><td>显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】</td><td>显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】</td><td>显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】</td><td>文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】</td><td>文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】</td><td>文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】</td><td>文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】</td><td>显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】</td><td>显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】</td><td>在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】</td><td>配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】</td><td>显示侧边栏 (默认 true)</td></tr></tbody></table><p>如果要打多个tag的话，做法如下</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line"><span class="bullet">   -</span> blog</span><br><span class="line"><span class="bullet">   -</span> 教程</span><br></pre></td></tr></table></figure><h3 id="报错查看">报错查看</h3><p><code>hexo g</code>时出现如下错误1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">ERROR Theme config load failed.</span><br><span class="line">ERROR &#123;</span><br><span class="line">  err: YAMLException: bad indentation of a mapping entry (40:27)</span><br><span class="line"></span><br><span class="line">   37 | #   icon: link || the description</span><br><span class="line">   38 | social:</span><br><span class="line">   39 |    fab fa-github: https://github.com/winfredliu || Github</span><br><span class="line">   40 |    fas fa-envelope: mailto: 3194769362@qq.com || Email</span><br><span class="line">   --------------------------------^</span><br><span class="line">   41 |</span><br><span class="line">   42 | # search (搜索)</span><br></pre></td></tr></table></figure><p>你知道怎么错了吗？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>从上面可知主题配置文件中第40行出错，查看是否有语法错误或其他错误。<br>我们查看相关信息发现：<br><img src="/img/example2.png" alt=""></p><p>我们在<code>mailto:</code>后多加了一个空格。</p><p>去掉空格即可</p></div></div><p><code>hexo g</code>时出现如下错误2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR RangeError: E:\blog\themes\butterfly\layout\includes\widget\index.pug:33</span><br><span class="line">    31|       !=partial(&#x27;includes/widget/card_tags&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    32|       !=partial(&#x27;includes/widget/card_archives&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  &gt; 33|       !=partial(&#x27;includes/widget/card_webinfo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    34|       !=partial(&#x27;includes/widget/card_bottom_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">E:\blog\themes\butterfly\layout\includes\widget\card_webinfo.pug:14</span><br><span class="line">    12|         .webinfo-item</span><br><span class="line">    13|           .item-name= _p(&#x27;aside.card_webinfo.runtime.name&#x27;) + &quot; :&quot;</span><br><span class="line">  &gt; 14|           .item-count#runtimeshow(data-publishDate=date_xml(theme.runtimeshow.publish_date))</span><br><span class="line">    15|       if theme.wordcount.enable &amp;&amp; theme.wordcount.total_wordcount</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(&#x27;aside.card_webinfo.site_wordcount&#x27;) + &quot; :&quot;</span><br></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>解决方法</span></div>    <div class="hide-content"><p>我们可以知道应该是主题配置文件的card_webinfo出错，查看相关信息可知</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">card_webinfo:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure><p>这个webinfo与网站访问人数和运营时间有关，再查看这两个</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time difference between publish date and now (網頁運行時間)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">publish_date:</span> <span class="number">18</span><span class="string">/1/2022</span> <span class="number">20</span><span class="string">:00:00</span></span><br></pre></td></tr></table></figure><p>我们可以发现我们的日期格式写错了，更正就可以了。</p></div></div><h3 id="语言">语言</h3><p>修改根目录配置文件 _config.yml</p><p>默认语言是 en</p><p>主题支持三种语言</p><p>default(en)<br>zh-CN (简体中文)<br>zh-TW (繁体中文）</p><h3 id="网站资料">网站资料</h3><p>修改网站各种资料，例如标题、副标题和邮箱等个人资料，请修改博客根目录的_config.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">欢迎来到我的博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;博客&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">winfred</span> <span class="string">liu</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://winfredliu.github.io</span></span><br></pre></td></tr></table></figure><h3 id="导航菜单">导航菜单</h3><p>修改themes/butterfly下的_config.yml（主题配置文件）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line"><span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line"><span class="string">List||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"><span class="attr">Link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line"><span class="attr">About:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>必须是 /xxx/，后面||分开，然后写图标名。</p><p>如果不希望显示图标，图标名可不写。</p><p>默认子目录是展开的，如果你想要隐藏，在子目录里添加 hide 。</p><p>导航中的文字可自行更改</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">娱乐||fas</span> <span class="string">fa-list||hide:</span></span><br><span class="line">    <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="attr">photo:</span> <span class="string">/photo/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-photo</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><h4 id="代码高亮主题">代码高亮主题</h4><p>Butterfly 支持6种代码高亮样式：</p><p>darker<br>pale night<br>light<br>ocean<br>mac<br>mac light</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><h4 id="代码复制功能">代码复制功能</h4><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># copy button</span></span><br></pre></td></tr></table></figure><h4 id="代码框展开关闭">代码框展开关闭</h4><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击&gt;可展开代码</p><ul><li>true 全部代码框不展开，需点击&gt;打开</li><li>false 代码狂展开，有&gt;点击按钮</li><li>none 不显示&gt;按钮</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><br></pre></td></tr></table></figure><p>注：你也可以在post/page页对应的markdown文件front-matter添加highlight_shrink来独立配置。</p><p>当主题配置文件中的 highlight_shrink 设为true时，可在front-matter添加highlight_shrink: false来单独配置文章展开代码框。</p><p>当主题配置文件中的 highlight_shrink 设为false时，可在front-matter添加highlight_shrink: true来单独配置文章收缩代码框。</p><h4 id="代码换行">代码换行</h4><p>在默认情况下，Hexo 在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果你是使用 highlight 渲染（一般默认是highlight渲染），需要找到你根目录下的 Hexo 配置文件_config.yml，将line_number改成false:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment"># &lt;- 改这个</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure><h4 id="代码高度限制">代码高度限制</h4><p>可配置代码高度限制，超出的部分会隐藏，并显示展开按钮。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_height_limit:</span> <span class="number">200</span> <span class="comment"># unit: px</span></span><br></pre></td></tr></table></figure><p>注：单位是 px，直接添加数字，如 200</p><p>实际限制高度为 highlight_height_limit + 30 px ，多增加 30px 限制，目的是避免代码高度只超出highlight_height_limit 一点时，出现展开按钮，展开没内容。</p><p>不适用于隐藏后的代码块（ css 设置 display: none）</p><h3 id="社交图标">社交图标</h3><p>Butterfly支持 font-awesome v5图标</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">   <span class="attr">fab fa-github:</span> <span class="string">https://github.com/winfredliu</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">   <span class="attr">fas fa-envelope:</span> <span class="string">mailto:3194769362@qq.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure><h3 id="主页文章节选-自动节选和文章页description">主页文章节选(自动节选和文章页description)</h3><p>因为主题UI的关系，主页文章节选只支持自动节选和文章页description。</p><p>在butterfly里，有四种可供选择</p><ol><li>description： 只显示description</li><li>both： 优先选择description，如果没有配置description，则显示自动节选的内容</li><li>auto_excerpt：只显示自动节选</li><li>false： 不显示文章内容</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p>description在front-matter里添加</p><h3 id="顶部图">顶部图</h3><p>如果不要显示顶部图，可直接配置 disable_top_img: true<br>配置中的值：</p><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>index_img</td><td>主页的 top_img</td></tr><tr><td>default_top_img</td><td>默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img</td></tr><tr><td>archive_img</td><td>归档页面的 top_img</td></tr><tr><td>tag_imgtag</td><td>子页面 的 默认 top_img</td></tr><tr><td>tag_per_img</td><td>tag 子页面的 top_img，可配置每个 tag 的 top_img</td></tr><tr><td>category_img</td><td>category 子页面 的 默认 top_img</td></tr><tr><td>category_per_img</td><td>category 子页面的 top_img，可配置每个 category 的 top_img</td></tr></tbody></table><p>其它页面 （tags/categories/自建页面）和 文章页 的 top_img ，请到对应的 md 页面设置front-matter中的top_img</p><p>以上所有的 top_img 可配置以下值</p><table><thead><tr><th>配置的值</th><th>效果</th></tr></thead><tbody><tr><td>留空</td><td>显示默认的top_img（如有），否则显示默认的颜色（文章页top_img留空的话，会显示 cover 的值）</td></tr><tr><td>img链接</td><td>图片的链接，显示所配置的图片</td></tr><tr><td>颜色(  HEX值 - #0000FF   RGB值 - rgb(0,0,255)  颜色单词 - orange    渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)</td><td>对应的颜色</td></tr><tr><td>transparent</td><td>透明</td></tr><tr><td>false</td><td>不显示top_img</td></tr><tr><td>ag_per_img 和 category_per_img 是 3.2.0 新增的内容，可对 tag 和 category 进行单独的配置</td><td></td></tr></tbody></table><p>并不推荐为每个 tag 和每个 category 都配置不同的顶部图，因为配置太多会拖慢生成速度</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">tag_per_img：</span></span><br><span class="line">  <span class="attr">aplayer:</span> <span class="string">https://xxxxxx.png</span></span><br><span class="line">  <span class="attr">android:</span> <span class="string">ddddddd.png</span></span><br><span class="line">  </span><br><span class="line"><span class="string">category_per_img：</span></span><br><span class="line">  <span class="string">随想:</span> <span class="string">hdhdh.png</span></span><br><span class="line">  <span class="string">推荐:</span> <span class="string">ddjdjdjd.png</span></span><br></pre></td></tr></table></figure><h3 id="文章置顶">文章置顶</h3><p>【推荐】hexo-generator-index从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h3 id="文章封面">文章封面</h3><p>文章的markdown文档上,在Front-matter添加cover,并填上要显示的图片地址。<br>如果不配置cover,可以设置显示默认的cover.</p><p>如果不想在首页显示cover,可以设置为false</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the position of cover in home page (封面顯示的位置)</span></span><br><span class="line">  <span class="comment"># left/right/both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span></span><br></pre></td></tr></table></figure><p>当配置多张图片时,会随机选择一张作为cover.此时写法应为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/img/cover1.jpg</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/img/cover2.jpg</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/img/cover3.jpg</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/img/cover4.jpg</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/img/cover5.jpg</span></span><br></pre></td></tr></table></figure><h3 id="文章页相关配置">文章页相关配置</h3><h4 id="文章meta显示">文章meta显示</h4><p>这个选项是用来显示文章的相关信息的。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 主頁文章日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章頁日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br></pre></td></tr></table></figure><p>主页：<img src="/img/example_page1.png" alt=""><br>文章页：<img src="/img/example_post1.png" alt=""><br>date_format 是 3.2.0 新增的内容，配置时间显示明确时间还是相对时间</p><h3 id="文章版权">文章版权</h3><p>为你的博客文章展示文章版权和许可协议。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>由于Hexo 4.1开始，默认对网址进行解码，以至于如果是中文网址，会被解码，可设置decode: true来显示中文网址。</p><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copyright:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从3.0.0开始，支持对单独文章设置版权信息，可以在文章Front-matter单独设置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copyright_author:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">copyright_author_href:</span> <span class="string">https://xxxxxx.com</span></span><br><span class="line"><span class="attr">copyright_url:</span> <span class="string">https://xxxxxx.com</span></span><br><span class="line"><span class="attr">copyright_info:</span> <span class="string">此文章版權歸xxxxx所有，如有轉載，請註明來自原作者</span></span><br></pre></td></tr></table></figure><h3 id="文章打赏">文章打赏</h3><p>在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置。</p><p>对于没有提供二维码的，可配置一张软件的icon图片，然后在link上添加相应的打赏链接。用户点击图片就会跳转到链接去。</p><p>link可以不写，会默认为图片的链接。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechat.png</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">微信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><h3 id="目录-2">目录</h3><p>在文章页，会有一个目录，用于显示TOC。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># for post</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>post</td><td>文章页是否显示 TOC</td></tr><tr><td>page</td><td>普通页面是否显示 TOC</td></tr><tr><td>number</td><td>是否显示章节数</td></tr><tr><td>expand</td><td>是否展开 TOC</td></tr><tr><td>style_simple</td><td>简洁模式（侧边栏只显示 TOC, 只对文章页有效 ）</td></tr></tbody></table><h4 id="为特定的文章配置">为特定的文章配置</h4><p>在你的文章md文件的头部，加入toc_number和toc，并配置true或者false即可。</p><p>主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为准。否则，以主题配置文件中的配置为准</p><h3 id="相关文章">相关文章</h3><p>相关文章推荐的原理是根据文章tags的比重来推荐</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">3</span> <span class="comment"># Number of posts displayed</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">updated</span> <span class="comment"># or created or updated 文章日期顯示創建日或者更新日</span></span><br></pre></td></tr></table></figure><h3 id="文章锚点">文章锚点</h3><p>开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题ID进行替换<br>(注意: 每替换一次，会留下一个历史记录。所以如果一篇文章有很多锚点的话，网页的历史记录会很多。)</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="文章过期提醒">文章过期提醒</h3><p>可设置是否显示文章过期提醒，以更新时间为基准。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Displays outdated notice for a post (文章過期提醒)</span></span><br><span class="line"><span class="attr">noticeOutdate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span> <span class="comment"># style: simple/flat</span></span><br><span class="line">  <span class="attr">limit_day:</span> <span class="number">500</span> <span class="comment"># When will it be shown</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span> <span class="comment"># position: top/bottom</span></span><br><span class="line">  <span class="attr">message_prev:</span> <span class="string">It</span> <span class="string">has</span> <span class="string">been</span></span><br><span class="line">  <span class="attr">message_next:</span> <span class="string">days</span> <span class="string">since</span> <span class="string">the</span> <span class="string">last</span> <span class="string">update,</span> <span class="string">the</span> <span class="string">content</span> <span class="string">of</span> <span class="string">the</span> <span class="string">article</span> <span class="string">may</span> <span class="string">be</span> <span class="string">outdated.</span></span><br></pre></td></tr></table></figure><p>limit_day： 距离更新时间多少天才显示文章过期提醒</p><p>message_prev ： 天数之前的文字</p><p>message_next：天数之后的文字</p><p>style: 过期提示的样式选择</p><h3 id="文章编辑按钮">文章编辑按钮</h3><p>在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/</span></span><br><span class="line">  <span class="comment"># For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/</span></span><br><span class="line">  <span class="attr">url:</span></span><br></pre></td></tr></table></figure><h3 id="文章分页按钮">文章分页按钮</h3><p>在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post_pagination (分頁)</span></span><br><span class="line"><span class="comment"># value: 1 || 2 || false</span></span><br><span class="line"><span class="comment"># 1: The &#x27;next post&#x27; will link to old post</span></span><br><span class="line"><span class="comment"># 2: The &#x27;next post&#x27; will link to new post</span></span><br><span class="line"><span class="comment"># false: disable pagination</span></span><br><span class="line"><span class="attr">post_pagination:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>post_pagination: false</td><td>关闭分页按钮</td></tr><tr><td>post_pagination: 1</td><td>下一篇显示的是旧文章</td></tr><tr><td>post_pagination: 2</td><td>下一篇显示的是新文章</td></tr></tbody></table><h3 id="头像">头像</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="图片描述">图片描述</h3><p>可开启图片Figcaption描述文字显示</p><p>优先显示图片的 title 属性，然后是 alt 属性</p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\ ![图片alt](图片链接 &quot;图片title&quot;)。</span><br></pre></td></tr></table></figure><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="复制相关配置">复制相关配置</h3><p>可配置网站是否可以复制、复制的内容是否添加版权信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>enable</td><td>是否开启网站复制权限</td></tr><tr><td>copyright</td><td>复制的内容后面加上版权信息</td></tr><tr><td>enable</td><td>是否开启复制版权信息添加</td></tr><tr><td>limit_count</td><td>字数限制，当复制文字大于这个字数限制时，将在复制的内容后面加上版权信息</td></tr></tbody></table><h3 id="页面底部设置">页面底部设置</h3><h4 id="博客年份">博客年份</h4><p>since是一个来展示你站点起始时间的选项。它位于页面的最底部。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2022</span></span><br></pre></td></tr></table></figure><h4 id="页脚自定义文本">页脚自定义文本</h4><p>custom_text是一个给你用来在页脚自定义文本的选项。通常你可以在这里写声明文本等。支持 HTML。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_text:</span> <span class="string">欢迎来到我的博客</span></span><br></pre></td></tr></table></figure><p>对于部分人需要写 ICP 的，也可以写在 custom_text里</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_text:</span> <span class="string">&lt;a</span> <span class="string">href=&quot;icp链接&quot;&gt;&lt;img</span> <span class="string">class=&quot;icp-icon&quot;</span> <span class="string">src=&quot;icp图片&quot;&gt;&lt;span&gt;备案号：xxxxxx&lt;/span&gt;&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><h3 id="右下角按钮">右下角按钮</h3><h4 id="简繁转换">简繁转换</h4><p>简体繁体互换</p><p>右下角会有简繁转换按钮。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># The text of a button</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">简</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Simplified Chinese</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Traditional Chinese</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;简&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="夜间模式">夜间模式</h4><p>右下角会有夜间模式按钮</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dark mode</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Switch dark/light mode automatically (自動切換 dark mode和 light mode)</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 2  Switch dark mode between 6 pm to 6 am</span></span><br><span class="line">  <span class="comment"># autoChangeMode: false</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注：V2.0.0 开始增加一个选项，可开启自动切换light mode 和 dark mode</p><p>autoChangeMode: 1 跟随系统而变化，不支持的浏览器/系统将按照时间晚上6点到早上6点之间切换为 dark mode</p><p>autoChangeMode: 2 只按照时间 晚上6点到早上6点之间切换为 dark mode,其余时间为light mode</p><p>autoChangeMode: false 取消自动切换</p><h4 id="阅读模式">阅读模式</h4><p>阅读模式下会去掉除文章外的内容，避免干扰阅读。</p><p>只会出现在文章页面，右下角会有阅读模式按钮。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="按钮排序">按钮排序</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要請不要修改 )</span></span><br><span class="line"><span class="comment"># Choose: readmode,translate,darkmode,hideAside,toc,chat,comment</span></span><br><span class="line"><span class="comment"># Don&#x27;t repeat 不要重複</span></span><br><span class="line"><span class="attr">rightside_item_order:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="comment"># readmode,translate,darkmode,hideAside</span></span><br><span class="line">  <span class="attr">show:</span> <span class="comment"># toc,chat,comment</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏设置">侧边栏设置</h3><h4 id="侧边排版">侧边排版</h4><p>可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/winfredliu</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure><h4 id="访问人数-busuanzi-UV-和-PV">访问人数 busuanzi (UV 和 PV)</h4><p>访问 busuanzi 的<a href="http://busuanzi.ibruce.info/">官方网站</a>查看更多的介绍。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="运行时间">运行时间</h4><p>网页已运行时间</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time difference between publish date and now (網頁運行時間)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">publish_date:</span> <span class="number">18</span><span class="string">/1/2022</span> <span class="number">20</span><span class="string">:00:00</span></span><br></pre></td></tr></table></figure><h4 id="最新评论">最新评论</h4><p>注：最新评论只会在刷新时才会去读取，并不会实时变化</p><p>由于 API 有 访问次数限制，为了避免调用太多，主题默认存取期限为 10 分钟。也就是说，调用后资料会存在 localStorage 里，10分钟内刷新网站只会去 localStorage 读取资料。 10 分钟期限一过，刷新页面时才会去调取 API 读取新的数据。 （ 3.6.0 新增了 storage 配置，可自行配置缓存时间）<br>在侧边栏显示最新评论板块</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">newest_comments:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="number">10</span> <span class="comment"># unit: mins, save data to localStorage</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>limit</td><td>显示的数量</td></tr><tr><td>storage</td><td>设置缓存时间，单位 分钟</td></tr><tr><td>avatar</td><td>是否显示头像</td></tr></tbody></table><h3 id="标签外挂（Tag-Plugins）">标签外挂（Tag Plugins）</h3><p>info提示的写法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>详细写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>标签外挂是Hexo独有的功能，并不是标准的Markdown格式。</p><p>以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p></div><div class="note blue icon simple"><i class="note-icon fab fa-cc-visa"></i><p>标签外挂虽然能为主题带来一些额外的功能和UI方面的强化，但是，标签外挂也有明显的限制，使用时请留意。</p></div><h4 id="Note-Bootstrap-Callout">Note (Bootstrap Callout)</h4><p>移植于next主题，并进行修改。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>color</td><td>【可选】颜色(default / blue / pink / red / purple / orange / green)</td></tr><tr><td>icon</td><td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置no-icon )</td></tr><tr><td>style</td><td>【可选】可以覆盖配置中的 style（simple/modern/flat/disabled）</td></tr></tbody></table><h4 id="Gallery相册图库">Gallery相册图库</h4><p>一个图库集合。</p><div class="note info simple"><p>例如我的：</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>写法</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup &#x27;OH MY GIRL&#x27; &#x27;OH MY GIRL的图片（对没错，是网图）&#x27; &#x27;/gallery/girl&#x27; https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="Gallery相冊">Gallery相冊</h4><p>写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>例如：</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><h4 id="tag-hide">tag-hide</h4><div class="note info simple"><p>请注意，tag-hide内的标签外挂content内都不建议有h1 - h6 等标题。因为Toc会把隐藏内容标题也显示出来，而且当滚动屏幕时，如果隐藏内容没有显示出来，会导致Toc的滚动出现异常。</p></div><p>如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。</p><p>有以下三种方式：</p><h5 id="inline">inline</h5><p>inline 在文本里面添加按钮隐藏内容，只限文字</p><p>( content不能包含英文逗号，可用‚)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>content: 文本内容</p></li><li><p>display: 按钮显示的文字(可选)</p></li><li><p>bg: 按钮的背景颜色(可选)</p></li><li><p>color: 按钮文字的颜色(可选)</p></li></ul><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">你帅（美）吗？ &#123;% hideInline 还行,点击查看答案,#FF7242,#fff %&#125;</span><br><span class="line">挥手告别  &#123;% hideInline 军 %&#125;</span><br></pre></td></tr></table></figure><p>你帅（美）吗？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">点击查看答案  </button><span class="hide-content">还行</span></span><br>挥手告别  <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">军</span></span></p><h5 id="block-2">block</h5><p>block独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p><p>( display 不能包含英文逗号，可用‚)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><ul><li>content: 文本内容</li><li>display: 按钮显示的文字(可选)</li><li>bg: 按钮的背景颜色(可选)</li><li>color: 按钮文字的颜色(可选)</li></ul><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">还有比你更帅（美）的人吗？</span><br><span class="line">&#123;% hideBlock 查看答案 %&#125;</span><br><span class="line">这重要吗？</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><p>还有比你更帅（美）的人吗？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>这重要吗？</p></div></div><h5 id="Toggle">Toggle</h5><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p><p>( display 不能包含英文逗号，可用‚)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle 不知道写什么了 %&#125;</span><br><span class="line">就不写了吧</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>不知道写什么了</span></div>    <div class="hide-content"><p>就不写了吧</p></div></div><h4 id="mermaid">mermaid</h4><p>使用mermaid标签可以绘制Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看<a href="https://mermaid-js.github.io/mermaid/#/">mermaid文档</a></p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">內容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">pie</span><br><span class="line"><span class="code">    title Key elements in Product X</span></span><br><span class="line"><span class="code">    &quot;钙&quot; : 45</span></span><br><span class="line"><span class="code">    &quot;钾&quot; : 50.00</span></span><br><span class="line"><span class="code">    &quot;Magnesium&quot; : 10</span></span><br><span class="line"><span class="code">    &quot;Iron&quot; :  5</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  pie    title Key elements in Product X    &quot;钙&quot; : 45    &quot;钾&quot; : 50.00    &quot;Magnesium&quot; : 10    &quot;Iron&quot; :  5  </pre></div><h4 id="Tab">Tab</h4><p>移植于next主题</p><p>使用方法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><div class="note default simple"><p>实例1 默认选择第一个</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note default simple"><p>实例2 自定义Tab名 + 只有icon + icon和Tab名</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="button">button</h4><p>使用方法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line"></span><br><span class="line">[url]         : 链接</span><br><span class="line">[text]        : 按钮文字</span><br><span class="line">[icon]        : [可选] 图标</span><br><span class="line">[color]       : [可选] 按钮背景颜色(默认style时）</span><br><span class="line"><span class="code">                      按钮字体和边框颜色(outline时)</span></span><br><span class="line"><span class="code">                      default/blue/pink/red/purple/orange/green</span></span><br><span class="line"><span class="code">[style]       : [可选] 按钮样式 默认实心</span></span><br><span class="line"><span class="code">                      outline/留空</span></span><br><span class="line"><span class="code">[layout]      : [可选] 按钮布局 默认为line</span></span><br><span class="line"><span class="code">                      block/留空</span></span><br><span class="line"><span class="code">[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边</span></span><br><span class="line"><span class="code">                      center/right/留空</span></span><br><span class="line"><span class="code">[size]        : [可选] 按钮大小</span></span><br><span class="line"><span class="code">                      larger/留空</span></span><br></pre></td></tr></table></figure><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,blue %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right,red outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right,larger %&#125;</span><br></pre></td></tr></table></figure><p>This is my website, click the button <a class="btn-beautify " href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="blue"></i><span>好看的妹妹</span></a><br>This is my website, click the button <a class="btn-beautify " href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a><br>This is my website, click the button <a class="btn-beautify " href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="red outline"></i><span>好看的妹妹</span></a><br>This is my website, click the button <a class="btn-beautify outline" href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a><br>This is my website, click the button <a class="btn-beautify larger" href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right,block %&#125;</span><br><span class="line">&#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right,block center  green larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://winfredliu.github.io/gallery/girl/&#x27;,好看的妹妹,far fa-hand-point-right,block right outline blue  larger %&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify block" href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a><a class="btn-beautify block center green larger" href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a><a class="btn-beautify block right outline blue larger" href="https://winfredliu.github.io/gallery/girl/"   title="好看的妹妹"><i class="far fa-hand-point-right"></i><span>好看的妹妹</span></a><h4 id="inlineImg">inlineImg</h4><p>主题中的图片都是默认以块级元素显示，如果你想以内联元素显示，可以使用这个标签外挂。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineImg [src] [height] %&#125;</span><br><span class="line"></span><br><span class="line">[src]      :    图片链接</span><br><span class="line">[height]   ：   图片高度限制【可选】</span><br></pre></td></tr></table></figure><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineImg https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png 150px %&#125;</span><br></pre></td></tr></table></figure><p>你看我长得漂亮不</p><p><img src="https://i.loli.net/2021/03/19/2P6ivUGsdaEXSFI.png" alt=""></p><img class="inline-img" src="https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png" style="height:150px"/><h4 id="label">label</h4><p>高亮所需的文字</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>text</td><td>文字</td></tr><tr><td>color</td><td>【可选】背景颜色，默认为 default default/blue/pink/red/purple/orange/green</td></tr></tbody></table><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">敲黑板&#123;% label 划重点 %&#125;，&#123;% label 网络流行词 blue %&#125;，作为网络语的该词其实和老师当年的&#123;% label 手势动作 pink %&#125;有&#123;% label 异曲同工之妙 red %&#125;，该词常作为标题出现后面还会紧接着其他的信息咨询，意思为&#123;% label 强调 purple %&#125;接下来要说的东西的重要性，起到一定的强调作用，和之前的&#123;% label “前方高能” orange %&#125;一词&#123;% label 意思比较接近 green %&#125;。</span><br></pre></td></tr></table></figure><p>敲黑板<mark class="hl-label default">划重点</mark> ，<mark class="hl-label blue">网络流行词</mark> ，作为网络语的该词其实和老师当年的<mark class="hl-label pink">手势动作</mark> 有<mark class="hl-label red">异曲同工之妙</mark> ，该词常作为标题出现后面还会紧接着其他的信息咨询，意思为<mark class="hl-label purple">强调</mark> 接下来要说的东西的重要性，起到一定的强调作用，和之前的<mark class="hl-label orange">“前方高能”</mark> 一词<mark class="hl-label green">意思比较接近</mark> 。</p><h4 id="timeline">timeline</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>标题/时间线</td></tr><tr><td>color</td><td>timeline 颜色 default(留空) / blue / pink / red / purple / orange / green</td></tr></tbody></table><div class="note default simple"><p>实例</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,pink %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><div class="timeline pink"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div><h2 id="自定义博客主题三">自定义博客主题三</h2><h3 id="评论">评论</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">通用设置</button></li><li class="tab"><button type="button" data-href="#test1-2">Disqus</button></li><li class="tab"><button type="button" data-href="#test1-3">Twikoo</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>从3.0.0开始，开启评论需要在comments-use中填写你需要的评论。</p><p>支持双评论显示，只需要配置两个评论（第一个为默认显示）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Valine,Disqus</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>use</td><td>使用的评论（请注意，最多支持两个，如果不需要请留空）注意：双评论不能是 Disqus 和 Disqusjs 一起，由于其共用同一个 ID，会出错</td></tr><tr><td>text</td><td>是否显示评论服务商的名字</td></tr><tr><td>lazyload</td><td>是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示）</td></tr><tr><td>count</td><td>是否在文章顶部显示评论数 livere、Giscus 和 utterances 不支持评论数显示</td></tr><tr><td>card_post_count</td><td>是否在首页文章卡片显示评论数 gitalk、livere 、Giscus 和 utterances 不支持评论数显示</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>注册 <a href="ttps://disqus.com">disqus</a>，配置你自己的 disqus，然后在Butterfly里开启它。</p><p>配置教程：<a href="jianshu.com/p/d68de067ea74">配置流程</a></p><p>记得选免费订阅！</p><p>允许访客评论：Settings -&gt; Moderation -&gt; Guest Commenting -&gt; Allow guests to comment (Enable)</p><p>shortname:<br><img src="/img/example3.png" alt="示例图3"></p><p>之后把shortname放在对应位置。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">winfredliu</span></span><br><span class="line">  <span class="attr">apikey:</span> <span class="comment"># For newest comments widget</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><code>Twikoo</code> 是一个简洁、安全、无后端的静态网站评论系统，基于<code>腾讯云开发</code>。</p><p>具体如何配置评论，请查看 <a href="https://twikoo.js.org/quick-start.html#%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">Twikoo文档</a></p><p>所以，大家应该知道怎么做吧？</p><p>选择0元套餐的流程如下：<br>进入腾讯云-&gt; 选择最新活动-&gt; 选择云开发 CloudBase <mark class="hl-label blue">0元xx</mark> （具体我忘了，主要这个套餐我订了之后就没出现了，我也无法演示）</p><div class="note info simple"><p>注：如果你的博客评论人数和使用较多（0元每月云存储有5GB，云数据库2GB，云函数使用量1000GBS，每月重置），建议购买资源或自行配置服务器资源。</p></div><p>我是用命令行的形式部署的。</p><p>中间有个指令包下载时间较长，请耐心等待：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\imaegoo\twikoo&gt;yarn install</span><br></pre></td></tr></table></figure><p>部署成功你将看到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">√ [twikoo] 云函数部署成功！</span><br><span class="line"></span><br><span class="line">i 控制台查看函数详情或创建HTTP 访问服务链接 🔗：https://console.cloud.tencent.com/tcb/scf?envId=test1-2gktnr4k00ee729f&amp;rid=4</span><br><span class="line">i 使用 cloudbase functions:list 命令查看已部署云函数</span><br></pre></td></tr></table></figure><p>接下来，你只需要把获取到的 <code>环境ID (envId)</code> 填写到配置上去就行</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>envId</td><td>环境 ID</td></tr><tr><td>region</td><td>环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数</td></tr><tr><td>visitor</td><td>是否显示文章閲读数</td></tr><tr><td>option</td><td>可选配置</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>更多评论API请看<a href="https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96">这里</a></p><h3 id="在线聊天">在线聊天</h3><p>从3.0开始，Butterfly主题内置了多种在綫聊天工具。你可以选择开启一种，方便你与访客的交流。</p><p>你只需要把chat_btn打开就行。</p><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Chat Button [recommend]</span></span><br><span class="line"><span class="comment"># It will create a button in the bottom right corner of website, and hide the origin button</span></span><br><span class="line"><span class="attr">chat_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>为了不影响访客的体验，主题提供一个chat_hide_show配置<br>设为true后，使用工具提供的按钮时，只有向上滚动才会显示聊天按钮，向下滚动时会隐藏按钮。</p><p>修改 主题配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The origin chat button is displayed when scrolling up, and the button is hidden when scrolling down</span></span><br><span class="line"><span class="attr">chat_hide_show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>如果使用工具自带的聊天按钮，按钮位置可能会遮挡右下角图标，请配置rightside-bottom调正右下角图标位置</p><p>the position of bottom right button/default unit: px (右下角按钮距离底部的距离/默认单位为px)<br>rightside-bottom</p></div><p>我选择的是daovie这个国内聊天工具，五千人以内免费。</p><h4 id="添加步骤">添加步骤</h4><h5 id="注册daovice账号">注册daovice账号</h5><p>首先需要到 <a href="https://dashboard.daocloud.io/">DaoCloud</a> 注册，登录之后需要进入到<a href="http://dashboard.daovoice.io/get-started">控制台</a></p><div class="note info simple"><p>注意：注册完毕之后找不到你所需的app_id，一定要从上面的控制台进入，创建你的应用。</p></div><h5 id="控制台查看app-id">控制台查看app_id</h5><p>进入到应用之后，点击左边的应用设置 -&gt; 安装到网站 -&gt; 注册用户+匿名用户，下方会看到我们的 app_id 后面需要用到</p><h6 id="聊天样式设置">聊天样式设置</h6><p>找到应用设置 -&gt; 聊天设置，可以进行聊天小图标的设置，设置自己喜欢的颜色和位置。</p><h6 id="主题配置文件修改">主题配置文件修改</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># daovoice</span></span><br><span class="line"><span class="comment"># http://daovoice.io/</span></span><br><span class="line"><span class="attr">daovoice:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">填自己的app_id</span></span><br></pre></td></tr></table></figure><p>更多在线聊天工具请看<a href="https://butterfly.js.org/posts/ceeb73f/#%E5%9C%A8%E7%B6%AB%E8%81%8A%E5%A4%A9">这里</a></p><h3 id="分享">分享</h3><p>默认是<a href="https://github.com/overtrue/share.js/">sharejs</a>，这个就不用管了。</p><h3 id="搜索系统">搜索系统</h3><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">Algolia</button></li><li class="tab"><button type="button" data-href="#test2-2">本地搜索</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><div class="note info simple"><p>记得运行<code>hexo clean</code>和<code>hexo g</code></p></div>1. 你需要安装 [hexo-algolia](https://github.com/oncletom/hexo-algolia)或 [hexo-algoliasearch](https://github.com/LouisBarranqueiro/hexo-algoliasearch)（个人推荐这个，但是这个功能有限,只能搜索文章，要搜索全站内容推荐第一个，但是第一个我没配成功）. 根据它们的说明文档去做相应的配置。<p>网上的教程基本上都是第二个。</p><p><a href="https://blog.ccknbc.cc/posts/hexo-butterfly-algolia/">具体教程</a></p><p>这个比较详细</p><div class="note info simple"><p>记得添加algolia时，是在根目录下的<code>_config.yml</code>中，而不是主题配置文件。</p><p>寻找apikey时，看下图<br><img src="/img/example4.png" alt=""></p><p>点进去之后，再查看<br><img src="/img/example5.png" alt=""></p><p><code>Search-Only API Key</code>在<code>all api keys</code>里，其余的<code>appid</code>,<code>admin api key</code>在这里</p><p>最后看：<br><img src="/img/example6.png" alt=""><br>有你创建的<code>index</code>的<code>api key</code>才是真正的<code>Search-Only API Key</code></p><p>还有在你的电脑里加入关于<code>Search-Only API Key</code>的环境变量</p><ol start="2"><li>修改 <code>主题配置文件</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p>个人推荐用这个，那个algolia配置之后感觉还不如这个本地搜索，而且配置algolia花了我整整四个小时。</p><ol><li><p>你需要安装 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a>. 根据它的文档去做相应配置。注意格式只支持 xml。<br>具体就是，根目录下输入<code>npm install hexo-generator-search</code>下载需要的插件</p></li><li><p>修改 <code>主题配置文件</code></p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>记得运行<code>hexo clean</code>和<code>hexo g</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="网站验证">网站验证</h3><p>如果需要搜索引擎收录网站，可能需要登录对应搜索引擎的管理平台（站点管理）进行提交。<br>各自的验证码可从各自管理平台拿到</p><p>修改 <code>主题配置文件</code><br>我的配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">site_verification:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">google-site-verification</span></span><br><span class="line">      <span class="attr">content:</span> <span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">baidu-site-verification</span></span><br><span class="line">      <span class="attr">content:</span> <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">msvalidate.01</span></span><br><span class="line">      <span class="attr">content:</span> <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br></pre></td></tr></table></figure><p>修改之后,<code>hexo d</code>推送之后再通过各自平台验证（我分别验证了百度，google，bing）。</p><h3 id="分析统计">分析统计</h3><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">百度统计</button></li><li class="tab"><button type="button" data-href="#test3-2">谷歌分析</button></li><li class="tab"><button type="button" data-href="#test3-3">Microsoft Clarity</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><ol><li><p>登录百度统计的<a href="https://tongji.baidu.com/web/welcome/login">官方网站</a><br>注意这里登录建议选择新媒体站长</p></li><li><p>找到你百度统计的统计代码<br><img src="/img/example7.png" alt=""></p></li><li><p>修改<code>主题配置文件</code></p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><ol><li><p>登录谷歌分析的官方网站</p></li><li><p>找到你的谷歌分析的跟踪 ID</p></li></ol><div class="note info simple"><p>创建资源时候要选择高级选项，创建Universal Analytics 媒体资源，不创建Google Analytics（分析）4 媒体资源</p><p>详细说明：<br><a href="https://support.google.com/analytics/answer/9539598?hl=zh-Hans">有关跟踪ID的变化</a></p></div><ol start="3"><li>修改<code>主题配置文件</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_analytics:</span> <span class="string">UA-xxxx</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><ol><li><p>登录 Clarity 的官方网站</p></li><li><p>创建 PROJECT</p></li><li><p>找到你的 ID<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-clarity-id.png" alt=""></p></li><li><p>修改<code>主题配置文件</code></p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">microsoft_clarity:</span> <span class="string">xxxxxxx</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="广告">广告</h3><div class="note info simple"><p>个人认为没必要</p></div><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">谷歌广告</button></li><li class="tab"><button type="button" data-href="#test4-2">手动广告配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>主题已集成谷歌广告（自动广告）未开启</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_adsense:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_ads:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 填入个人识别码</span></span><br><span class="line">  <span class="attr">enable_page_level_ads:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>主题预留了三个位置可供插入广告，分别为主页文章(每三篇文章出现广告)/aside公告之后/文章页打赏之后。<br>把html代码填写到对应的位置<br>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Insert ads manually (手動插入廣告)</span></span><br><span class="line"><span class="comment"># ad:</span></span><br><span class="line"><span class="comment">#   index:</span></span><br><span class="line"><span class="comment">#   aside:</span></span><br><span class="line"><span class="comment">#   post:</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Math数学">Math数学</h3><p>主题作者提供了两种MAth方式，本人没有配置<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">MsthJax</a>。</p><p>Katex配置如下：</p><p>首先禁用<code>MathJax</code>（如果你配置过 <code>MathJax</code> 的话），然后修改你的主题配置文件以便加载<code>katex.min.css</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># KaTeX</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>你不需要添加<code>katex.min.js</code>来渲染数学方程。相应的你需要卸载你之前的 hexo 的 markdown 渲染器，然后安装其它插件。</p><p>卸载掉 marked 插件，安装 <a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save # 如果有安装这个的话，卸载</span><br><span class="line">npm un hexo-renderer-kramed --save # 如果有安装这个的话，卸载</span><br><span class="line"></span><br><span class="line">npm i hexo-renderer-markdown-it --save # 需要安装这个渲染插件</span><br><span class="line">npm install @neilsustc/markdown-it-katex --save #需要安装这个katex插件</span><br></pre></td></tr></table></figure><p>在 hexo 的根目录的 <code>_config.yml</code> 中配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">strict:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="美化-特效">美化/特效</h3><h4 id="自定义主题色">自定义主题色</h4><p>可以修改大部分UI颜色</p><p>修改 <code>主题配置文件</code>，比如：</p><div class="note info simple"><p>颜色值必须被双引号包裹，就像&quot;#000&quot;而不是#000。否则将会在构建的时候报错！</p></div><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">main:</span> <span class="string">&quot;#49B1F5&quot;</span></span><br><span class="line">  <span class="attr">paginator:</span> <span class="string">&quot;#00c4b6&quot;</span></span><br><span class="line">  <span class="attr">button_hover:</span> <span class="string">&quot;#FF7242&quot;</span></span><br><span class="line">  <span class="attr">text_selection:</span> <span class="string">&quot;#00c4b6&quot;</span></span><br><span class="line">  <span class="attr">link_color:</span> <span class="string">&quot;#99a9bf&quot;</span></span><br><span class="line">  <span class="attr">meta_color:</span> <span class="string">&quot;#858585&quot;</span></span><br><span class="line">  <span class="attr">hr_color:</span> <span class="string">&quot;#A4D8FA&quot;</span></span><br><span class="line">  <span class="attr">code_foreground:</span> <span class="string">&quot;#F47466&quot;</span></span><br><span class="line">  <span class="attr">code_background:</span> <span class="string">&quot;rgba(27, 31, 35, .05)&quot;</span></span><br><span class="line">  <span class="attr">toc_color:</span> <span class="string">&quot;#00c4b6&quot;</span></span><br><span class="line">  <span class="attr">blockquote_padding_color:</span> <span class="string">&quot;#49b1f5&quot;</span></span><br><span class="line">  <span class="attr">blockquote_background_color:</span> <span class="string">&quot;#49b1f5&quot;</span></span><br><span class="line">  <span class="attr">scrollbar_color:</span> <span class="string">&quot;#49b1f5&quot;</span></span><br></pre></td></tr></table></figure><h4 id="网站背景">网站背景</h4><p>默认显示白色，可设置图片或者颜色</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片格式 url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="comment"># 颜色（HEX值/RGB值/顔色单词/渐变色)</span></span><br><span class="line"><span class="comment"># 留空 不显示背景</span></span><br><span class="line"><span class="attr">background:</span></span><br></pre></td></tr></table></figure><p>留意: 如果你的网站根目录不是’/',使用本地图片时，需加上你的根目录。</p><p>例如：网站是 <a href="https://yoursite.com/blog,%E5%BC%95%E7%94%A8%E4%B8%80%E5%BC%A0img/xx.png%E5%9B%BE%E7%89%87%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AEbackground%E4%B8%BA">https://yoursite.com/blog,引用一张img/xx.png图片，则设置background为</a> `url(/blog/img/xx.png)</p><p>像我的网站根目录就是’/'，<a href="https://winfredliu.github.io/">https://winfredliu.github.io/</a>.</p><p>以下是两种写法：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">background:&#x27;#49B202&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">background:</span> <span class="string">url(https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png)</span></span><br></pre></td></tr></table></figure><h4 id="footer背景">footer背景</h4><p>修改<code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Footer Background</span></span><br><span class="line"><span class="attr">footer_bg:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置的值</th><th>效果</th></tr></thead><tbody><tr><td>留空/false</td><td>显示默认的顔色</td></tr><tr><td>img链接</td><td>图片的链接，显示所配置的图片</td></tr><tr><td>顔色(HEX值 - #0000FF RGB值 - rgb(0,0,255) 顔色单词 - orange 渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)）</td><td>对应的顔色</td></tr><tr><td>true</td><td>显示跟 top_img 一样</td></tr></tbody></table><h4 id="打字效果">打字效果</h4><p>打字效果<a href="https://github.com/disjukr/activate-power-mod">activate-power-mode</a></p><p>修改<code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode</span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖動特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="背景特效">背景特效</h4><div class="tabs" id="test5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test5-1">精止彩带</button></li><li class="tab"><button type="button" data-href="#test5-2">动态彩带</button></li><li class="tab"><button type="button" data-href="#test5-3">canvas-nest</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test5-1"><p>好看的彩带背景，可设置每次刷新更换彩带，或者每次点击更换彩带<br>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">false</span>  <span class="comment">#设置是否每次点击都更换彩带</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br></pre></td></tr></table></figure><p>相关配置可查看<a href="https://github.com/hustcc/ribbon.js">canvas_ribbon</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-2"><p>好看的彩带背景，会飘动<br>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-3"><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">   <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">   <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">   <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">   <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="鼠标点击效果">鼠标点击效果</h4><div class="tabs" id="test6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test6-1">烟花</button></li><li class="tab"><button type="button" data-href="#test6-2">爱心</button></li><li class="tab"><button type="button" data-href="#test6-3">文字</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test6-1"><p>zIndex建议只在-1和9999上选<br>-1 代表烟火效果在底部<br>9999 代表烟火效果在前面</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">9999</span> <span class="comment"># -1 or 9999</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-firewall.gif" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test6-2"><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 点击出现爱心</span></span><br><span class="line"><span class="attr">click_heart:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/click_love.gif" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test6-3"><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 点击出现文字，文字可自行修改</span></span><br><span class="line"><span class="attr">ClickShowText:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">I</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LOVE</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">YOU</span></span><br><span class="line">  <span class="attr">fontSize:</span> <span class="string">15px</span></span><br><span class="line">  <span class="attr">random:</span> <span class="literal">false</span> <span class="comment"># 文字随机显示</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="页面美化">页面美化</h4><p>会改变ol、ul、h1-h5的样式</p><p>field配置生效的区域</p><ul><li>post 只在文章页生效</li><li>site 在全站生效<br>修改 <code>主题配置文件</code></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 美化页面显示</span></span><br><span class="line"><span class="attr">beautify:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br><span class="line">   <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f0c1&#x27;</span></span><br><span class="line">   <span class="attr">title-prefix-icon-color:</span> <span class="string">&quot;#F47466&quot;</span></span><br></pre></td></tr></table></figure><p><code>title-prefix-icon</code>填写的是fontawesome的icon的Unicode数。</p><h4 id="自定义字体和字体大小">自定义字体和字体大小</h4><h5 id="全局字体">全局字体</h5><p>可自行设置字体的font-family<br>如不需要配置，请留空</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span></span><br><span class="line">  <span class="attr">code-font-size:</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">-apple-system,</span> <span class="string">BlinkMacSystemFont,</span> <span class="string">&quot;Segoe UI&quot;</span><span class="string">,</span> <span class="string">&quot;Helvetica Neue&quot;</span><span class="string">,</span> <span class="string">Lato,</span> <span class="string">Roboto,</span> <span class="string">&quot;PingFang SC&quot;</span><span class="string">,</span> <span class="string">&quot;Microsoft JhengHei&quot;</span><span class="string">,</span> <span class="string">&quot;Microsoft YaHei&quot;</span><span class="string">,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">consolas,</span> <span class="string">Menlo,</span> <span class="string">&quot;PingFang SC&quot;</span><span class="string">,</span> <span class="string">&quot;Microsoft JhengHei&quot;</span><span class="string">,</span> <span class="string">&quot;Microsoft YaHei&quot;</span><span class="string">,</span> <span class="string">sans-serif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="blog标题字体">blog标题字体</h5><p>可自行设置字体的<code>font-family</code><br>如不需要配置，请留空。<br>如不需要使用网络字体，只需要把font_link留空就行</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Font settings for the site title and site subtitle</span></span><br><span class="line"><span class="comment"># 左上角网站名字 主页居中网站名字</span></span><br><span class="line"><span class="attr">blog_title_font:</span></span><br><span class="line">  <span class="attr">font_link:</span> <span class="string">https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">Titillium</span> <span class="string">Web,</span> <span class="string">&#x27;PingFang SC&#x27;</span><span class="string">,</span> <span class="string">&#x27;Hiragino Sans GB&#x27;</span><span class="string">,</span> <span class="string">&#x27;Microsoft JhengHei&#x27;</span><span class="string">,</span> <span class="string">&#x27;Microsoft YaHei&#x27;</span><span class="string">,</span> <span class="string">sans-serif</span></span><br></pre></td></tr></table></figure><h4 id="网站副标题">网站副标题</h4><p>可设置主页中显示的网站副标题或者喜欢的座右铭。</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主页subtitle</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 关闭调用</span></span><br><span class="line">  <span class="comment"># source: 1  调用一言网的一句话（简体） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  调用一句网（简体） http://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  调用今日诗词（简体） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的内容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">欢迎来到我的博客</span></span><br><span class="line">  <span class="comment"># &quot;&amp;#44;&quot;表示是逗号</span></span><br></pre></td></tr></table></figure><h4 id="主页top-img显示大小">主页top_img显示大小</h4><p>默认的显示为全屏。site-info的区域会居中显示</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主页设置</span></span><br><span class="line"><span class="comment"># 默认top_img全屏，site_info在中间</span></span><br><span class="line"><span class="comment"># 使用默认, 都无需填写（建议默认）</span></span><br><span class="line"><span class="attr">index_site_info_top:</span> <span class="comment"># 主页标题距离顶部距离  例如 300px/300em/300rem/10%</span></span><br><span class="line"><span class="attr">index_top_img_height:</span>  <span class="comment">#主页top_img高度 例如 300px/300em/300rem  不能使用百分比</span></span><br></pre></td></tr></table></figure><p>注意：index_top_img_height的值不能使用百分比。<br>2个都不填的话，会使用默认值</p><h4 id="页面加载动画preloader">页面加载动画preloader</h4><p>当进入网页时，因为加载速度的问题，可能会导致top_img图片出现断层显示，或者网页加载不全而出现等待时间，开启preloader后，会显示加载动画，等页面加载完，加载动画会消失。</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载动画 Loading Animation</span></span><br><span class="line"><span class="attr">preloader:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="PWA">PWA</h3><p>要为<code>Butterfly</code>配上 <a href="https://en.wikipedia.org/wiki/Progressive_web_application">PWA</a> 特性, 你需要如下几个步骤:</p><ol><li><p>打开 hexo 工作目录</p></li><li><p><code>npm install hexo-offline --save</code> 或者 <code>yarn add hexo-offline</code></p></li><li><p>在根目录创建 <code>hexo-offline.config.cjs</code> 文件，并增加以下内容。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offline config passed to workbox-build.</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">globPatterns</span>: [<span class="string">&#x27;**/*.&#123;js,html,css,png,jpg,gif,svg,webp,eot,ttf,woff,woff2&#125;&#x27;</span>],</span><br><span class="line">  <span class="comment">// 静态文件合集，如果你的站点使用了例如 webp 格式的文件，请将文件类型添加进去。</span></span><br><span class="line">  <span class="attr">globDirectory</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">  <span class="attr">swDest</span>: <span class="string">&#x27;public/service-worker.js&#x27;</span>,</span><br><span class="line">  <span class="attr">maximumFileSizeToCacheInBytes</span>: <span class="number">10485760</span>, <span class="comment">// 缓存的最大文件大小，以字节为单位。</span></span><br><span class="line">  <span class="attr">skipWaiting</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">runtimeCaching</span>: [ <span class="comment">// 如果你需要加载 CDN 资源，请配置该选项，如果没有，可以不配置。</span></span><br><span class="line">    <span class="comment">// CDNs - should be CacheFirst, since they should be used specific versions so should not change</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">urlPattern</span>: <span class="regexp">/^https:\/\/cdn\.example\.com\/.*/</span>, <span class="comment">// 可替换成你的 URL</span></span><br><span class="line">      handler: <span class="string">&#x27;CacheFirst&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容请查看<a href="https://github.com/JLHwung/hexo-offline">hexo-offline</a>的官方文档<br>4. 在<code>主题配置文件</code>中开启 pwa 选项。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pwa:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">manifest:</span> <span class="string">/img/pwa/manifest.json</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/img/pwa/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">favicon_32_32:</span> <span class="string">/img/pwa/32.png</span></span><br><span class="line">  <span class="attr">favicon_16_16:</span> <span class="string">/img/pwa/16.png</span></span><br><span class="line">  <span class="attr">mask_icon:</span> <span class="string">/img/pwa/safari-pinned-tab.svg</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在创建<code>source/</code>目录中创建<code>manifest.json</code>文件。</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;:</span> <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;short_name&quot;:</span> <span class="string">&quot;Junzhou&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;theme_color&quot;:</span> <span class="string">&quot;#49b1f5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;background_color&quot;:</span> <span class="string">&quot;#49b1f5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;display&quot;:</span> <span class="string">&quot;standalone&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scope&quot;:</span> <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start_url&quot;:</span> <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;icons&quot;:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/36.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;36x36&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/48.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;48x48&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/72.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;72x72&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/96.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;96x96&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/144.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;144x144&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/192.png&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;192x192&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;src&quot;:</span> <span class="string">&quot;images/pwaicons/512.png&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;sizes&quot;:</span> <span class="string">&quot;512x512&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;splash_pages&quot;:</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以通过 <a href="https://app-manifest.firebaseapp.com/">Web App Manifest</a>快速创建manifest.json。（Web App Manifest 要求至少包含一个 512<em>512 像素的图标）<br>6. 可以通过<code>Chrome</code>插件<code>Lighthouse</code>检查 PWA 配置是否生效以及配置是否正确。<br>* 打开博客页面<br>* 启动<code>Lighthouse</code>插件 (<code>Lighthouse</code>插件要求至少包含一个 512</em>512 像素的图标)<br>关于 PWA（渐进式增强 Web 应用）的更多内容请参阅 <a href="https://web.dev/themed-omnibox/">Google Tools for Web Developers</a></p><h3 id="字数统计">字数统计</h3><ol><li><p>打开 hexo 工作目录</p></li><li><p><code>npm install hexo-wordcount --save</code> or <code>yarn add hexo-wordcount</code></p></li><li><p>修改 <code>主题配置文件</code>:</p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="图片大图查看模式">图片大图查看模式</h3><p>如果你并不想为某张图片添加大图查看模式，你可以使用 html 格式引用图片，并为图片添加 no-lightbox class 名。</p><div class="note info simple"><p>只能开启一个</p></div><div class="tabs" id="test6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test6-1">fancybox</button></li><li class="tab"><button type="button" data-href="#test6-2">medium_zoom</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test6-1"><p>这个是默认开启的<br>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fancybox http://fancyapps.com/fancybox/3/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/fancybox.gif" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test6-2"><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/medium_zoom.gif" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Snackbar-弹窗">Snackbar 弹窗</h3><p>Snackbar 弹窗,根据自己爱好开启<br>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Snackbar (Toast Notification 彈窗)</span></span><br><span class="line"><span class="comment"># https://github.com/polonel/SnackBar</span></span><br><span class="line"><span class="comment"># position 彈窗位置</span></span><br><span class="line"><span class="comment"># 可選 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right</span></span><br><span class="line"><span class="attr">snackbar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">bottom-left</span></span><br><span class="line">  <span class="attr">bg_light:</span> <span class="string">&#x27;#49b1f5&#x27;</span> <span class="comment"># The background color of Toast Notification in light mode</span></span><br><span class="line">  <span class="attr">bg_dark:</span> <span class="string">&#x27;#121212&#x27;</span> <span class="comment"># The background color of Toast Notification in dark mode</span></span><br></pre></td></tr></table></figure><h3 id="其他配置">其他配置</h3><h4 id="CSS前缀">CSS前缀</h4><p>有些 CSS 并不是所有浏览器都支持，需要增加对应的前缀才会生效。</p><p>开启 <code>css_prefix</code> 后，会自动为一些 CSS 增加前缀。（会增加 20%的体积）</p><p>默认开启</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add the vendor prefixes to ensure compatibility</span></span><br><span class="line"><span class="attr">css_prefix:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Open-Graph">Open Graph</h4><p>在 <code>head</code> 里增加一些 meta 资料，例如缩略图、标题、时间等等。当你分享网页到一些平台时，平臺会读取 Open Graph 的内容，展示缩略图，标题等等信息。</p><p>默认开启</p><p>修改 <code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Open graph meta tags</span></span><br><span class="line"><span class="comment"># https://developers.facebook.com/docs/sharing/webmasters/</span></span><br><span class="line"><span class="attr">Open_Graph_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Instantpage">Instantpage</h4><p>当鼠标悬停到链接上超过 65 毫秒时，Instantpage 会对该链接进行预加载，可以提升访问速度。</p><p>修改<code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://instant.page/</span></span><br><span class="line"><span class="comment"># prefetch (預加載)</span></span><br><span class="line"><span class="attr">instantpage:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Pangu">Pangu</h4><p><code>Pangu</code>它会自动替你在网页中所有的中文字和半形的英文、数字、符号之间插入空白。<br>修改<code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span></span><br><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></table></figure><h3 id="Pjax">Pjax</h3><p>当用户点击链接，通过ajax更新页面需要变化的部分，然后使用HTML5的pushState修改浏览器的URL地址。</p><p>这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pjax</span></span><br><span class="line"><span class="comment"># It may contain bugs and unstable, give feedback when you find the bugs.</span></span><br><span class="line"><span class="comment"># https://github.com/MoOx/pjax</span></span><br><span class="line"><span class="attr">pjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - /music/</span></span><br><span class="line">    <span class="comment"># - /no-pjax/</span></span><br><span class="line">    <span class="comment"># - /movie/</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>对于一些第三方插件，有些并不支持 pjax 。<br>你可以把网页加入到 <code>exclude</code> 里，这个网页会被 pjax 排除在外。<br>点击该网页会重新加载网站</p><p>使用pjax后，一些自己DIY的js可能会无效，跳转页面时需要重新调用，请参考<a href="https://github.com/MoOx/pjax">Pjax文档</a><br>使用pjax后，一些个别页面加载的js/css，将会改为所有页面都加载</p></div><div class="note info simple"><p>Butterfly的Pjax目前仍有一些问题，请留意</p><ul><li>使用谷歌广告可能会报错（例如自动广告）</li></ul></div><h3 id="Inject">Inject</h3><p>如想添加额外的js/css/meta等等东西，可以在Inject里添加，支持添加到head(<code>&lt;/body&gt;</code>标签之前)和bottom(<code>&lt;/html&gt;</code>标籤之前)。</p><p>请注意：以标准的html格式添加内容</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/self.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>留意: 如果你的网站根目录不是’/',使用本地图片时，需加上你的根目录。<br>例如：网站是 <code>https://yoursite.com/blog,引用css/xx.css</code>，则设置为<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/blog/css/xx.css&quot;&gt;</code></p><h3 id="CDN">CDN</h3><p>配置文件中最后一部分<a href="https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/">CDN</a>，里面是主题所引用到的文件，可自行配置CDN。（非必要请勿修改，配置后请确认链接是否能访问）</p><p>以下是一些CDN提供商：</p><ul><li><a href="https://www.jsdelivr.com/">jsdelivr</a></li><li><a href="https://www.bootcdn.cn/">bootcdn</a></li><li><a href="https://cdnjs.com/">cdnjs</a></li></ul><h2 id="进阶教程">进阶教程</h2><h3 id="建议">建议</h3><ol><li>不要把个人需要的文件/图片放在主题source文件夹里，因为在升级主题的过程中，可能会把文件覆盖删除了。<br>在Hexo根目录的source文件夹里，创建一个文件夹来放置个人文件/图片。<br>引用文件直接为/文件夹名称/文件名</li></ol><h3 id="音乐">音乐</h3><p>全局音乐播放设置<br>音乐界面使用插件<code>hexo-tag-aplayer</code></p><p>详细使用方法请参考插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">文档</a></p><p><a href="https://easyhexo.com/3-Plugins-use-and-config/3-1-hexo-tag-aplayer/">教程</a></p><p>我的做法如下：<br>我使用的是<code>Metingjs</code></p><ol><li>安装<code>hexo-tag-aplayer</code>插件,在博客目录执行</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer -save</span><br></pre></td></tr></table></figure><ol start="2"><li>关闭 asset_inject<br>在<code>Hexo的配置文件</code>中</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="3"><li>开启主题的aplayerInject<br>在<code>主题配置文件</code>中，enable设为true和per_page设为true</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject the css and script (aplayer/meting)</span></span><br><span class="line"><span class="attr">aplayerInject:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="4"><li>插入Aplayer html<br>为了适配hexo-tag-aplayer，主题内置的Meting js 仍为1.2版本，并非最新的2.x版本。</li></ol><p>把aplayer代码插入到主题配置文件的inject.bottom去</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;3136952023&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-mini=&quot;false&quot;</span> <span class="string">data-loop=&quot;all&quot;</span> <span class="string">data-listFolded=&quot;false&quot;</span> <span class="string">data-order=&quot;list&quot;</span> <span class="string">data-preload=&quot;none&quot;</span> <span class="string">data-autoplay=&quot;true&quot;</span> <span class="string">muted&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><code>3136952023</code>是id,  <code>neteas</code>是平台，  <code>playlist</code>是类型</p><p>QQ音乐</p><p>搜索歌曲，歌曲地址就是 id ，如果是音乐列表，列表地址就是 id , 同理，歌手也是一样的。</p><p><img src="https://easyhexo.com/assets/img/1.eb1f69ab.png" alt=""></p><p>网易云音乐</p><p>网易云音乐比较实在，直接告诉你 id 是什么了</p><p><img src="/img/example8.png" alt=""></p><p>其他平台的，也是类似，只要花点时间研究一下就能找到。</p><p>详细介绍</p><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>必须值</td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td>必须值</td><td>音乐平台: netease , tencent , kugou , xiami , baidu</td></tr><tr><td>type</td><td>必须值</td><td>song , playlist , album , search , artist</td></tr><tr><td>fixed</td><td>false</td><td>开启固定模式</td></tr><tr><td>mini</td><td>false</td><td>开启迷你模式</td></tr><tr><td>loop</td><td>all</td><td>列表循环模式： all , one , none</td></tr><tr><td>order</td><td>list</td><td>列表播放模式： list , random</td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td>false</td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td>metingjs</td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td>true</td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td>true</td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td>340px</td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td>auto</td><td>音乐文件预载入模式，可选项： none , metadata , auto</td></tr><tr><td>theme</td><td>#ad7a86</td><td>播放器风格色彩设置</td></tr></tbody></table><ol start="5"><li>UI 调整<br>按照上面的步骤设置完成后，浏览器左下角会出现Aplayer。打开文章页面时，你会发现打开Toc目录的按钮被遮挡了。我们需要修改CSS来改变按钮的位置。</li></ol><p>修改<code>主题配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;#toggle-sidebar &#123;bottom: 80px&#125;&lt;/style&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>最终如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;#toggle-sidebar &#123;bottom: 80px&#125;&lt;/style&gt;&#x27;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;3136952023&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-mini=&quot;false&quot;</span> <span class="string">data-loop=&quot;all&quot;</span> <span class="string">data-listFolded=&quot;false&quot;</span> <span class="string">data-order=&quot;list&quot;</span> <span class="string">data-preload=&quot;none&quot;</span> <span class="string">data-autoplay=&quot;true&quot;</span> <span class="string">muted&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="电影">电影</h3><p>电影界面使用了插件 <code>hexo-butterfly-douban</code><br>使用方法请参考插件的<a href="https://github.com/jerryc127/butterfly-plugins/tree/main/hexo-butterfly-douban">文档</a>。</p><p>注意：</p><ol><li>hexo-butterfly-douban 会主动生成页面，所以不需要自己创建（前提是你选择了builtin: true）。</li><li>如遇到无法抓取问题，显示 INFO 0 movies have been loaded in xxx ms, because you are offline or your network is bad<br>请过段时间再试试。</li></ol><p>这个其实就是抓取了你的豆瓣账号上的内容，如果你没有豆瓣账号或你的豆瓣账号为空，那也没什么用。</p><h3 id="说说">说说</h3><p>我采用的是<code>Artitalk</code>来配置的。</p><p>教程如下：</p><ol><li>安裝插件</li></ol><blockquote><p>npm install hexo-butterfly-artitalk</p></blockquote><ol start="2"><li><p>leancloud配置 参考<a href="https://artitalk.js.org/doc.html#%F0%9F%8C%88-leancloud-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%86%E5%A4%87">Artitalk 文档 - LeanCloud 的相关准备</a></p></li><li><p>前往 <a href="https://leancloud.app/">LeanCloud</a> 国际版，注册账号。</p></li><li><p>注册完成之后根据 LeanCloud 的提示绑定手机号和邮箱。</p></li><li><p>绑定完成之后点击创建应用，应用名称随意，接着在结构化数据中创建 class，命名为 <code>shuoshuo</code>。</p></li><li><p>在你新建的应用中找到<code>结构化数据</code>下的<code>_User</code>。点击<code>添加行</code>，输入想用的用户名及密码。</p></li><li><p>回到<code>结构化数据</code>中，点击 <code>class</code> 下的 <code>shuoshuo</code>。找到权限，在 <code>Class 访问权限</code>中将 <code>add_fields</code> 以及 <code>create</code> 权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将 <code>delete</code> 和 <code>update</code> 也设置为跟它们一样的权限。</p></li><li><p>然后新建一个名为<code>atComment</code>的class，权限什么的使用默认的即可。</p></li><li><p>点击 <code>class</code> 下的 <code>_User</code> 添加列，列名称为 <code>img</code>，默认值填上你这个账号想要用的发布说说的头像url，这一项不进行配置，说说头像会显示为默认头像 —— Artitalk 的 logo。</p></li><li><p>在最菜单栏中找到设置-&gt; 应用 keys，记下来 <code>AppID</code> 和 <code>AppKey</code> ，一会会用。</p></li><li><p>最后将 <code>_User</code> 中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据以达到强制发布说说</p></li><li><p>这几步一定要设置好，才可以保证不被 “闲人” 破解发布说说的验证</p></li><li><p>创建页面source\artitalk\<a href="http://index.md">index.md</a></p></li></ol><p>我的写法如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: artitalk</span><br><span class="line">date: 2022-01-23 22:28:21</span><br><span class="line">type: artitalk</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/artitalk&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;artitalk_main&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line">  new Artitalk(&#123;</span><br><span class="line"><span class="code">    appId: &#x27;EfTHJsYzXKKdIsxz1ibFndD6-MdYXbMMI&#x27;,</span></span><br><span class="line"><span class="code">    appKey: &#x27;WCtHUMA1xWqisTWv1w9Rf0rm&#x27;,</span></span><br><span class="line"><span class="code">    atComment: 1,</span></span><br><span class="line"><span class="code">  &#125;)</span></span><br><span class="line"><span class="code">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加配置信息 在 <code>Hexo （根目录下）的配置文件</code> 或者 <code>主题配置文件</code>中添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Artitalk</span></span><br><span class="line"> <span class="comment"># see https://artitalk.js.org/</span></span><br><span class="line"> <span class="attr">artitalk:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">appId:</span></span><br><span class="line">   <span class="attr">appKey:</span></span><br><span class="line">   <span class="attr">path:</span></span><br><span class="line">   <span class="attr">js:</span></span><br><span class="line">   <span class="attr">option:</span></span><br><span class="line">   <span class="attr">front_matter:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>appId</td><td>【必须】LeanCloud 创建的应用中的 AppID</td></tr><tr><td>appKey</td><td>【必须】LeanCloud 创建的应用中的 AppKEY</td></tr><tr><td>path</td><td>【可选】Artitalk 的路径名称（默认为 artitalk，生成的页面为 artitalk/index.html）</td></tr><tr><td>js</td><td>【可选】更换 Artitalk 的 js CDN（默认为 <a href="https://cdn.jsdelivr.net/npm/artitalk%EF%BC%89">https://cdn.jsdelivr.net/npm/artitalk）</a></td></tr><tr><td>option</td><td>【可选】Artitalk 需要的额外配置</td></tr><tr><td>front_matter</td><td>【可选】Artitalk 页面的 front_matter 配置</td></tr></tbody></table><h3 id="自定义代码配色">自定义代码配色</h3><p><a href="https://butterfly.js.org/posts/b37b5fe3/">详细教程</a></p><h3 id="自定义侧边栏">自定义侧边栏</h3><p><a href="https://butterfly.js.org/posts/ea33ab97/">详细教程</a></p><h3 id="Icon">Icon</h3><p>Butterfly主题内置了<a href="https://fontawesome.com/">Font Awesome V5</a> 图标，目前已更新到 5.13.0，总共有1,588个免费图标。由于是国外的图标网站，对于国内的一些网站Icon并不支持。如有需要，你可以引入其它的图标服务商。</p><h4 id="iconfont">iconfont</h4><p>国内最出名的莫过于<a href="https://www.iconfont.cn/">iconfont</a>,功能很强大且图标内容很丰富的矢量图标库。很多<code>Font Awesome</code>不支持的图标都可以在这里找到。同时，<code>iconfont</code>支持选择需要的图标生成css链接，减少不必要的CSS加载。</p><p><a href="https://butterfly.js.org/posts/4073eda/#iconfont">详细使用教程</a></p><h3 id="图片压缩">图片压缩</h3><p><a href="https://butterfly.js.org/posts/4073eda/#%E5%9C%96%E7%89%87%E5%A3%93%E7%B8%AE">详细教程</a></p><h3 id="插件推荐">插件推荐</h3><ul><li><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a><br>可以把链接permalink转为数字的插件，配置容易，生成时自动转为数字。</li><li><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a><br>生成RSS文件的插件</li><li><a href="https://github.com/hexojs/hexo-filter-nofollow">hexo-filter-nofollow</a><br>为网站使用到的所有外链添加<code>rel=&quot;noopener external nofollow noreferrer&quot;</code>, 可以有效地加强网站SEO和防止权重流失</li><li><a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap</a><br>生成sitemap的插件</li><li><a href="https://github.com/coneycode/hexo-generator-baidu-sitemap">hexo-generator-baidu-sitemap</a><br>看名字就知道，是专门为百度生成sitemap的插件</li></ul><h3 id="留言板配置">留言板配置</h3><p>在站点根目录执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-envelope --save</span><br></pre></td></tr></table></figure><p>安装完成之后打开<code>站点的配置文件</code>或<code>主题的配置文件</code>，添加如下配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 留言板</span></span><br><span class="line"><span class="attr">envelope_comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cover:</span> <span class="string">https://ae01.alicdn.com/kf/U5bb04af32be544c4b41206d9a42fcacfd.jpg</span> <span class="comment"># 信笺封面图</span></span><br><span class="line">  <span class="attr">message:</span>  <span class="comment"># 信笺内容，支持多行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">来自木雁的留言</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想问的？</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想说的？</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">有什么想吐槽的？</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">自动书记人偶竭诚为您服务!</span>   <span class="comment"># 信笺结束语，只能单行</span></span><br><span class="line">  <span class="attr">height:</span>                          <span class="comment"># 调整信笺划出高度，默认1050px</span></span><br><span class="line">  <span class="attr">path:</span>                           <span class="comment"># 【可选】comments 的路径名称。默认为 comments ， 生成的页面为 comments/index.html</span></span><br><span class="line">  <span class="attr">front_matter:</span>                    <span class="comment"># 【可选】comments页面的 front_matter 配置</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">留言板</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">aside:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后在站点根目录执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page comments</span><br></pre></td></tr></table></figure><h3 id="主题更新">主题更新</h3><p>了减少升级主题后带来的不便，请使用以下方法（建议，可以不做）。</p><p>在 hexo 的根目录创建一个文件 <code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复制到 <code>_config.butterfly.ym</code>l 去。( 注意: 复製的是主题的 <code>_config.yml</code> ,而不是 hexo 的<code> _config.yml</code>)</p><p>注意： 不要把主题目录的 _config.yml 删掉</p><p>注意： 以后只需要在 <code>_config.butterfly.yml</code>进行配置就行。<br>如果使用了 <code>_config.butterfly.yml</code>， 配置主题的 <code>_config.yml</code> 将不会有效果。</p><p>Hexo会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code>里的配置，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。</p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/butterfly-docs-install-suggestion-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> 教程 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法教程</title>
      <link href="/2022/01/18/markdown%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/18/markdown%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="标题语法">标题语法</h2><p>创建标题，在单词或短语前添加井号（#）。#的数量代表标题的大小，越多越小</p><h2 id="段落语法">段落语法</h2><p>用空白行来分隔文本，不要用空格（spaces）或制表符（ tabs）缩进段落。</p><h2 id="Markdown换行语法">Markdown换行语法</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行</p><h3 id="换行语法的最佳实践">换行语法的最佳实践</h3><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 结尾空格（trailing whitespace) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <br> 标签。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <br> 标签来实现换行。<br>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 () 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（return）即可实现换行。</p><h2 id="Markdown-强调语法">Markdown 强调语法</h2><h3 id="粗体">粗体</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><h3 id="斜体">斜体</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><h3 id="同时粗体-斜体">同时粗体+斜体</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><h2 id="Markdown-引用语法">Markdown 引用语法</h2><p>要创建块引用，请在段落前添加一个 &gt; 符号。<br>举例：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h3 id="多个段落的块引用">多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号<br>举例：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="嵌套块引用">嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。<br>举例：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h3 id="带有其他元素的块引用">带有其他元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。<br>举例：</p><blockquote><h4 id="The-quarterly-results-look-great">The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h1>Markdown列表语法</h1><p>可以将多个条目组织成有序或无序列表。</p><h3 id="有序列表">有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>举例：</p><ol><li>First item</li><li>Second item</li><li>Third item<ol><li>Indented item</li><li>Indented item</li></ol></li><li>Fourth item</li></ol><h3 id="无序列表">无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><h3 id="在列表中嵌套其他元素">在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块">引用块</h4><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块">代码块</h4><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><h2 id="Markdown-代码语法">Markdown 代码语法</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。</p><h3 id="代码块-2">代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。<br>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>😊</p><h3 id="Markdown-围栏代码块">Markdown 围栏代码块</h3><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。</p><h2 id="Markdown分割线语法">Markdown分割线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。<br>如：</p><hr><hr><hr><h2 id="Markdown-链接语法">Markdown 链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接显示名</a></p><p>对应的HTML代码：<a href="超链接地址" title="超链接title">超链接显示名</a><br>举例：<br>这是一个链接 <a href="https://markdown.com.cn">Markdown语法</a>。</p><h3 id="给链接增加-Title">给链接增加 Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。<br>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。</span><br></pre></td></tr></table></figure><p>这是一个链接 <a href="https://markdown.com.cn" title="最好的markdown教程">Markdown语法</a>。</p><h3 id="网址和Email地址">网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接<br>如：<br><a href="https://markdown.com.cn">https://markdown.com.cn</a><br><a href="mailto:fake@example.com">fake@example.com</a></p><h3 id="格式化链接">格式化链接</h3><p>强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。<br>举例：<br>I love supporting the <strong><a href="https://eff.org">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h3 id="引用类型链接">引用类型链接</h3><p>1.放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。<br>2.链接的URL，可以选择将其括在尖括号中。<br>3.链接的可选标题，可以将其括在双引号，单引号或括号中。<br>举例：<br>[1]: <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">https://en.wikipedia.org/wiki/Hobbit#Lifestyle</a><br>[1]: <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">https://en.wikipedia.org/wiki/Hobbit#Lifestyle</a> “Hobbit lifestyles”<br>[1]: <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">https://en.wikipedia.org/wiki/Hobbit#Lifestyle</a> ‘Hobbit lifestyles’<br>[1]: <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">https://en.wikipedia.org/wiki/Hobbit#Lifestyle</a> (Hobbit lifestyles)<br>[1]: <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">https://en.wikipedia.org/wiki/Hobbit#Lifestyle</a> “Hobbit lifestyles”</p><h3 id="注意：">注意：</h3><p>不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。</p><h2 id="Markdown-图片语法">Markdown 图片语法</h2><p>要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\ ![图片alt](图片链接 &quot;图片title&quot;)。</span><br></pre></td></tr></table></figure><p>对应的HTML代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这是图片](/img/a.jpg &quot;风景图&quot;)</span><br></pre></td></tr></table></figure><p><img src="/img/a.jpg" alt="这是图片" title="风景图"></p><h3 id="链接图片">链接图片</h3><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。<br>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![图片](/img/a.jpg &quot;Shiprock&quot;)](https://markdown.com.cn)</span><br></pre></td></tr></table></figure><p><a href="https://markdown.com.cn"><img src="/img/a.jpg" alt="图片" title="Shiprock"></a></p><h2 id="转义字符语法">转义字符语法</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。<br>举例：<br>* Without the backslash, this would be a bullet in an unordered list.</p><h2 id="Markdown内嵌-HTML-标签">Markdown内嵌 HTML 标签</h2><h3 id="行级內联标签">行级內联标签</h3><p>HTML 的行级內联标签如 <code>&lt;span&gt;、&lt;cite&gt;、&lt;del&gt;</code> 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。<br>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic.</span><br></pre></td></tr></table></figure><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="区块标签">区块标签</h3><p>区块元素──比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 &lt;p&gt; 标签。</p><h2 id="扩展教程">扩展教程</h2><p>markdown扩展语法](<a href="https://markdown.com.cn/extended-syntax/">https://markdown.com.cn/extended-syntax/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2022/01/18/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/18/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化版本库">初始化版本库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h2 id="添加文件">添加文件</h2><p>把一个文件放到Git仓库只需要两步<br>readme.txt内容如下：</p><blockquote><p>Git is a version control system.<br>Git is free software.<br>放在上文git init的目录下.<br>第一步，用命令git add告诉Git，可反复多次使用，添加多个文件,把文件添加到仓库：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>第二步，用命令git commit告诉Git，把文件提交到仓库,commit可以一次提交很多文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行）</p><h2 id="时空穿梭">时空穿梭</h2><h3 id="修改历史查询">修改历史查询</h3><p>修改readme.txt文件</p><p>改成如下内容：</p><p><code>Git is a distributed version control system. </code></p><p><code>Git is free software.</code></p><p>运行git status命令看看结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>运行 <code>git diff</code>查看当前仓库状态。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 07fc819..b18bfcc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system</span><br><span class="line">+Git is a distributed version control system.^M</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p><p>提交修改和提交新文件是一样的两步.</p><h3 id="版本回退">版本回退</h3><p>用 <code>git log</code>命令查看历史记录<br>注：<br>和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用 <code>git reset</code>命令,版本号没必要写全，前几位就可以了，Git会自动去找：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git reset --hard 4439d</span><br><span class="line">HEAD is now at 4439dd9 add distributed</span><br></pre></td></tr></table></figure><p>想恢复到新版本怎么办？找不到新版本的commit id怎么办？<br>Git提供了一个命令git reflog用来记录你的每一次命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git reflog</span><br><span class="line">4439dd9 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4439d</span><br><span class="line">daffbfd HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">4439dd9 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">0c1e964 HEAD@&#123;3&#125;: commit (initial): write a readme file</span><br></pre></td></tr></table></figure><p>我们可以知道append GPL的commit id是daffbfd</p><h3 id="工作区和暂存区">工作区和暂存区</h3><p>当前我的 <code>E:\test</code>就是工作区</p><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p><code>git status</code>:</p><p>作两次对比，工作区 vs 暂存区 以及 暂存区 vs 仓库，并将两次对比的结果显示在输出中。哪个对比没差别，就不显示。两个对比都没差别，就显示working tree clean。</p><p><code>git diff</code>：</p><ol><li>git diff：是查看working tree与index的差别的。</li><li>git diff --cached：是查看index与repository的差别的。</li><li>git diff HEAD：是查看working tree和repository的差别的。其中：HEAD代表的是最近的一次commit的信息。</li></ol><h3 id="管理修改">管理修改</h3><p>Git跟踪并管理的是修改，而非文件<br>git add放在暂存区之后，如果修改相应文件，应该重新git add 再git commit -m。否则修改的内容不会被提交。</p><h3 id="撤销修改">撤销修改</h3><p><code>git checkout --file</code>可以丢弃工作区的修改<br>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>命令git reset HEAD <code>&lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><h3 id="删除文件">删除文件</h3><p>一、确实要从版本库中删除该文件，那就用命令 <code>git rm</code>删掉，并且 <code>git commit</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>二、删错了，用git checkout恢复</p><h2 id="远程仓库">远程仓库</h2><p>github创建SSH KEY</p><h3 id="添加远程库">添加远程库</h3><p>先在github上创建一个Git仓库，然后根据github上的提示，在本地仓库运行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git remote add origin git@github.com:winfredliu/learngit.git</span><br></pre></td></tr></table></figure><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。<br>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git push -u origin main</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用 <code>git push</code>命令，实际上是把当前分支main推送到远程。</p><p>由于远程库是空的，我们第一次推送main分支时，加上了-u参数，Git不但会把本地的main分支内容推送的远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin main</span><br></pre></td></tr></table></figure><p>把本地main分支的最新修改推送至GitHub.</p><h4 id="删除远程库">删除远程库</h4><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm <code>&lt;name&gt;</code>命令。使用前，建议先用git remote -v查看远程库信息，然后，根据名字删除，比如删除origin：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h3 id="从远程库克隆">从远程库克隆</h3><p>用 <code>git clone</code>把远程库克隆到本地库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:winfredliu/learngit.git</span><br></pre></td></tr></table></figure><p>GitHub给出的地址不止一个，还可以用https://github.com/winfredliu/learngit.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https</p><h2 id="分支管理">分支管理</h2><p>首先，我们创建dev分支，然后切换到dev分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上-b参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>然后，用 <code>git branch</code>命令查看当前分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git branch</span><br><span class="line">* dev</span><br><span class="line">  main</span><br></pre></td></tr></table></figure><p>git branch命令会列出所有分支，当前分支前面会标一个*号。<br>现在，我们把dev分支的工作成果合并到main分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git merge dev</span><br><span class="line">Updating f92c8e5..a7abaa2</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支.<br>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把main指向dev的当前提交，所以合并速度非常快。</p><h4 id="删除本地分支">删除本地分支</h4><p>合并完成后，就可以放心地删除dev分支了，<code>git branch -d dev</code>是删除指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git branch -d dev</span><br><span class="line">Deleted branch dev (was a7abaa2).</span><br></pre></td></tr></table></figure><p>我们注意到切换分支使用git checkout <code>&lt;branch&gt;</code>.实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的 <code>git switch</code>命令来切换分支：</p><h4 id="删除远程分支">删除远程分支</h4><p>指令：<code>git push &lt;远程主机名&gt; --detete &lt;删除分支名&gt;</code><br>删除出现如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git push origin --delete main</span><br><span class="line">To github.com:winfredliu/learngit.git</span><br><span class="line"> ! [remote rejected] main (refusing to delete the current branch: refs/heads/main)</span><br><span class="line">error: failed to push some refs to &#x27;github.com:winfredliu/learngit.git&#x27;</span><br></pre></td></tr></table></figure><p>这是因为在我们的远程仓库中main是默认分支，所以无法删除。所以我们需要将远程仓库中的默认分支改为另外的分支。</p><ol><li>进入github的远程仓库，点击如下界面中的setting</li><li>进入如下界面，再点击branch</li><li>设置branch中的default branch，更改为main之外的分支，这里我设置的master，然后点击一下update后确认。<br>然后再删除。</li></ol><p>创建并切换到新的dev分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch -c dev</span><br></pre></td></tr></table></figure><p>直接切换到已有的master分支，可以使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch master</span><br></pre></td></tr></table></figure><h3 id="解决冲突">解决冲突</h3><p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" title="廖雪峰的教程-解决分支冲突问题">解决冲突</a></p><p>简要来说，合并分支时，每个分支工作区的文件如果不一致的话就会产生冲突。这个时候要使工作区文件相同。</p><h3 id="分支管理策略">分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下–no-ff方式的git merge：</p><p>首先，仍然创建并切换dev分支,修改readme.txt文件，并提交一个新的commit,现在，我们切换回main.</p><p>准备合并dev分支，请注意 <code>--no-ff</code>参数，表示禁用 <code>Fast forward</code>：</p><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p><h4 id="分支历史变迁">分支历史变迁</h4><p>合并后，我们用git log看看分支历史</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/01/b7954a837df7139d.png" alt="merge图" title="分支可视图"></p><h3 id="BUG分支">BUG分支</h3><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支 <code>issue-101</code>来修复它，但是，等等，当前正在 <code>dev</code>上进行的工作还没有提交：<br>git提供了一个 <code>git stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>现在，用 <code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在main分支上修复，就从main创建临时分支 <code>issue-101</code>。</p><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到main分支，并完成合并，最后删除 <code>issue-101</code>分支.</p><p>修复完BUG后，是时候接着回到 <code>dev</code>分支干活了！</p><p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on main: bd67996 AND simple</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用 <code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用 <code>git stash drop</code>来删除；</p><p>另一种方式是用 <code>git stash pop</code>，恢复的同时把stash内容也删了：</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git stash pop</span><br><span class="line">Removing test.txt</span><br><span class="line">On branch main</span><br><span class="line">Your branch is ahead of &#x27;origin/main&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    test.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        img/</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (e4765582cca89fa0c52a11ccb8a254d504b3643b)</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在main分支上修复了bug后，我们要想一想，dev分支是早期从main分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把 <code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制 <code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个main分支merge过来。</p><p>为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick 4c805e2</span><br></pre></td></tr></table></figure><p>当然要确保当前分支在dev上。</p><h3 id="Feature分支">Feature分支</h3><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch -c feature-1</span><br><span class="line">git add 某个文件</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">git switch 起始分支</span><br></pre></td></tr></table></figure><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -D feature-1</span><br></pre></td></tr></table></figure><h3 id="多人协作">多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的分支和远程的m分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用 <code>git remote</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用 <code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git remote -v</span><br><span class="line">origin  git@github.com:winfredliu/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:winfredliu/learngit.git (push)</span><br></pre></td></tr></table></figure><h4 id="推送分支">推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li>master分支是主分支，因此要时刻与远程同步；</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="抓取分支">抓取分支</h4><p>人协作时，大家都会往master和dev分支上推送各自的修改。<br>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。<br>现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p><img src="https://i.bmp.ovh/imgs/2022/01/fc36a49ada8f0283.png" alt="这是图片"><br>注：如上图所示，你test目录下clone，但管理该项目应该在learngit目录下</p><p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。</p><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用 <code>git pull</code>把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<br>git pull前，应该指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><p>再pull.</p><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><h3 id="Rebase">Rebase</h3><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p>我们输入命令 <code>git rebase</code>,原本分叉的提交现在变成一条直线了.这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观</p><h2 id="标签管理">标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>commit号不如tag直观。</p><h3 id="创建标签">创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上,然后，敲命令 <code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令 <code>git tag</code>查看所有标签：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git log --pretty=oneline --abbrev-commit</span><br><span class="line">bd67996 (HEAD -&gt; master, tag: v1.0, origin/master, origin/dev, feature1, dev) AND simple</span><br><span class="line">a7abaa2 branch test</span><br><span class="line">f92c8e5 add test.txt</span><br><span class="line">4439dd9 add distributed</span><br><span class="line">0c1e964 write a readme file</span><br></pre></td></tr></table></figure><p>比方说要对 <code>add distributed</code>这次提交打标签，它对应的 <code>commit id</code>是 <code>4439dd9</code>，敲入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag v0.9 4439dd9</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用 <code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git show v0.9</span><br><span class="line">commit 4439dd984e2d83ff7c7a70df6d0519eef2600669 (tag: v0.9)</span><br><span class="line">Author: winfredliu &lt;3194769362@qq.com&gt;</span><br><span class="line">Date:   Thu Jan 13 18:31:47 2022 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 07fc819..b18bfcc 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system</span><br><span class="line">+Git is a distributed version control system.^M</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用 <code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag -a v0.1 -m &quot;version 0.1 released&quot; 0c1e964</span><br></pre></td></tr></table></figure><p>用命令 <code>git show &lt;tagname&gt;</code>可以看到说明文字:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag v0.1</span><br><span class="line">Tagger: winfredliu &lt;3194769362@qq.com&gt;</span><br><span class="line">Date:   Tue Jan 18 20:11:52 2022 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 0c1e9644bed1817dc3671747fd8da4825387bd9a (tag: v0.1)</span><br><span class="line">Author: winfredliu &lt;3194769362@qq.com&gt;</span><br><span class="line">Date:   Thu Jan 13 18:07:40 2022 +0800</span><br><span class="line"></span><br><span class="line">    write a readme file</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>注：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签">操作标签</h3><p>如果标签打错了，也可以删除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag -d v0.1</span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was 2acd0d6)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><h4 id="推送标签到远程">推送标签到远程</h4><p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:winfredliu/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:winfredliu/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><h4 id="删除远程标签">删除远程标签</h4><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt;git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was 4439dd9)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\test&gt; git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:winfredliu/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><h2 id="Github删除仓库">Github删除仓库</h2><p>如果我们想要删除Github中没有用的仓库，应该如何去做呢？</p><p>进入到我们需要删除的仓库里面，找到“settings”即仓库设置,<br>然后，在仓库设置里拉到最底部，找到“Danger Zone”即危险区域,<br>点击“Delete this repository”这样就可以删除该仓库了。</p><h2 id="重命名某个文件">重命名某个文件</h2><p>比如将<code>readme.md</code>改为<code>README.md</code>要先<code>git add</code>,<code>git commit</code> <code>readme.md</code>；再<code>git add</code>,<code>git commit</code> <code>README.md</code></p><h2 id="git-add-命令">git add 命令</h2><p>我们可以使用命令git add将所加入的文件添加进来</p><p><code>git add .</code>将仓库文件夹中的内容都添加进来</p><p><code>git add *.</code>文件类型//添加指定文件类型的文件</p><h2 id="Git报错“-（no-branch-rebasing-master）”">Git报错“*（no branch, rebasing master）”</h2><p>本次出现这个错误是因为本地提交了<code>commit</code>但是未<code>push</code>成功，所以使用<code>git pull --rebase</code>，由于远程仓库和本地的<code>commit</code>有冲突，Git无法自动解决冲突时，会切换到一个匿名分支，然后使用<code>git branch</code>发现报错<code>“no branch, rebasing master”</code>。</p><p>解决办法：</p><p>在当前匿名分支下，解决完冲突，然后使用命令<code>git rebase --continue</code>，可以将代码合并到之前操作时的分支（我当时是在master分支所以后面都说master分支），执行完<code>git rebase --continue</code>后就自动回到了<code>master</code>分支，但是之前提交的commit没有在本地仓库区(<code>Repository</code>)了，回到了本地暂存区(Index / Stage)，这时候需要重新<code>commit</code>，之后再执行<code>git push origin master</code>就可以将变更推到远程仓库了。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
